--- linux-2.6.22.18/arch/arm/boot/compressed/head-xscale.Sixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/boot/compressed/head-xscale.S	2008-07-09 15:14:37.000000000 +0200
@@ -41,11 +41,6 @@ __XScale_start:
 		mov	r7, #MACH_TYPE_COTULLA_IDP
 #endif
 
-#ifdef  CONFIG_MACH_GTWX5715
-               mov     r7, #(MACH_TYPE_GTWX5715 & 0xff)
-               orr     r7, r7, #(MACH_TYPE_GTWX5715 & 0xff00)
-#endif
-
 #ifdef CONFIG_ARCH_IXP2000
 		mov	r1, #-1
 		mov	r0, #0xd6000000
--- linux-2.6.22.18/arch/arm/configs/ixp4xx_defconfigixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/configs/ixp4xx_defconfig	2008-07-09 15:14:37.000000000 +0200
@@ -1,53 +1,83 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.15
-# Tue Jan  3 03:20:40 2006
+# Linux kernel version: 2.6.22-rc5
+# Sun Jun 24 12:06:23 2007
 #
 CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_MMU=y
-CONFIG_UID16=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 
 #
 # Code maturity level options
 #
 CONFIG_EXPERIMENTAL=y
-CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
-CONFIG_BSD_PROCESS_ACCT=y
-# CONFIG_BSD_PROCESS_ACCT_V3 is not set
-CONFIG_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
 # CONFIG_AUDIT is not set
-# CONFIG_HOTPLUG is not set
-CONFIG_KOBJECT_UEVENT=y
-# CONFIG_IKCONFIG is not set
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+# CONFIG_BLK_DEV_INITRD is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
 CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
 CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
+CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_VM_EVENT_COUNTERS is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
 
@@ -55,8 +85,8 @@ CONFIG_BASE_SMALL=0
 # Loadable module support
 #
 CONFIG_MODULES=y
-# CONFIG_MODULE_UNLOAD is not set
-CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
 CONFIG_MODVERSIONS=y
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_KMOD=y
@@ -64,45 +94,59 @@ CONFIG_KMOD=y
 #
 # Block layer
 #
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
 
 #
 # IO Schedulers
 #
 CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_AS is not set
 CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-CONFIG_DEFAULT_AS=y
-# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
 # CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_DEFAULT_IOSCHED="deadline"
 
 #
 # System Type
 #
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
 # CONFIG_ARCH_CO285 is not set
 # CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_INTEGRATOR is not set
-# CONFIG_ARCH_IOP3XX is not set
-CONFIG_ARCH_IXP4XX=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_IXP2000 is not set
+CONFIG_ARCH_IXP4XX=y
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_SHARK is not set
 # CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
-# CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_REALVIEW is not set
-# CONFIG_ARCH_IMX is not set
-# CONFIG_ARCH_H720X is not set
-# CONFIG_ARCH_AAEC2000 is not set
 CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
 
 #
@@ -112,24 +156,29 @@ CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
 #
 # IXP4xx Platforms
 #
-CONFIG_ARCH_AVILA=y
-CONFIG_ARCH_ADI_COYOTE=y
+CONFIG_MACH_NSLU2=y
+CONFIG_MACH_AVILA=y
+CONFIG_MACH_LOFT=y
+# CONFIG_ARCH_ADI_COYOTE is not set
 CONFIG_ARCH_IXDP425=y
-CONFIG_MACH_IXDPG425=y
-CONFIG_MACH_IXDP465=y
-CONFIG_MACH_KIXRP435=y
+# CONFIG_MACH_IXDPG425 is not set
+# CONFIG_MACH_IXDP465 is not set
+# CONFIG_MACH_KIXRP435 is not set
 CONFIG_ARCH_IXCDP1100=y
-CONFIG_ARCH_PRPMC1100=y
+# CONFIG_ARCH_PRPMC1100 is not set
 CONFIG_MACH_NAS100D=y
+CONFIG_MACH_DSMG600=y
 CONFIG_ARCH_IXDP4XX=y
-CONFIG_CPU_IXP46X=y
-CONFIG_CPU_IXP43X=y
+CONFIG_MACH_FSG=y
 # CONFIG_MACH_GTWX5715 is not set
 
 #
 # IXP4xx Options
 #
+CONFIG_DMABOUNCE=y
 # CONFIG_IXP4XX_INDIRECT_PCI is not set
+CONFIG_IXP4XX_QMGR=y
+CONFIG_IXP4XX_NPE=y
 
 #
 # Processor Type
@@ -140,22 +189,25 @@ CONFIG_CPU_32v5=y
 CONFIG_CPU_ABRT_EV5T=y
 CONFIG_CPU_CACHE_VIVT=y
 CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
 
 #
 # Processor Features
 #
-# CONFIG_ARM_THUMB is not set
+CONFIG_ARM_THUMB=y
 CONFIG_CPU_BIG_ENDIAN=y
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+# CONFIG_IWMMXT is not set
 CONFIG_XSCALE_PMU=y
-CONFIG_DMABOUNCE=y
 
 #
 # Bus support
 #
-CONFIG_ISA_DMA_API=y
 CONFIG_PCI=y
-CONFIG_PCI_LEGACY_PROC=y
-# CONFIG_PCI_DEBUG is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_PCI_DEBUG=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
@@ -165,8 +217,13 @@ CONFIG_PCI_LEGACY_PROC=y
 #
 # Kernel Features
 #
-# CONFIG_PREEMPT is not set
-# CONFIG_NO_IDLE_HZ is not set
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
 # CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
@@ -176,6 +233,8 @@ CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 # CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
 CONFIG_ALIGNMENT_TRAP=y
 
 #
@@ -183,8 +242,9 @@ CONFIG_ALIGNMENT_TRAP=y
 #
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="console=ttyS0,115200 ip=bootp root=/dev/nfs"
+CONFIG_CMDLINE="root=/dev/nfs rootfstype=nfs ip=dhcp noirqdebug console=ttyS0,115200n8"
 # CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
 
 #
 # Floating point emulation
@@ -203,13 +263,11 @@ CONFIG_FPE_NWFPE=y
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_ARTHUR is not set
 
 #
 # Power management options
 #
 # CONFIG_PM is not set
-# CONFIG_APM is not set
 
 #
 # Networking
@@ -219,77 +277,59 @@ CONFIG_NET=y
 #
 # Networking options
 #
-CONFIG_PACKET=m
+CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
 CONFIG_XFRM=y
 # CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-# CONFIG_IP_FIB_TRIE is not set
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_FWMARK=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
-CONFIG_IP_ROUTE_VERBOSE=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_BOOTP is not set
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
-CONFIG_NET_IPGRE=m
-CONFIG_NET_IPGRE_BROADCAST=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
+# CONFIG_NET_IPGRE is not set
 # CONFIG_ARPD is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
 CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=m
 CONFIG_INET_DIAG=y
 CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_BIC=y
-
-#
-# IP: Virtual Server Configuration
-#
-CONFIG_IP_VS=m
-CONFIG_IP_VS_DEBUG=y
-CONFIG_IP_VS_TAB_BITS=12
-
-#
-# IPVS transport protocol load balancing support
-#
-# CONFIG_IP_VS_PROTO_TCP is not set
-# CONFIG_IP_VS_PROTO_UDP is not set
-# CONFIG_IP_VS_PROTO_ESP is not set
-# CONFIG_IP_VS_PROTO_AH is not set
-
-#
-# IPVS scheduler
-#
-CONFIG_IP_VS_RR=m
-CONFIG_IP_VS_WRR=m
-CONFIG_IP_VS_LC=m
-CONFIG_IP_VS_WLC=m
-CONFIG_IP_VS_LBLC=m
-CONFIG_IP_VS_LBLCR=m
-CONFIG_IP_VS_DH=m
-CONFIG_IP_VS_SH=m
-# CONFIG_IP_VS_SED is not set
-# CONFIG_IP_VS_NQ is not set
-
-#
-# IPVS application helper
-#
-# CONFIG_IPV6 is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_TUNNEL=m
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_NETWORK_SECMARK is not set
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_BRIDGE_NETFILTER=y
@@ -297,98 +337,155 @@ CONFIG_BRIDGE_NETFILTER=y
 #
 # Core Netfilter Configuration
 #
-# CONFIG_NETFILTER_NETLINK is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK_ENABLED=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
 
 #
 # IP: Netfilter Configuration
 #
-CONFIG_IP_NF_CONNTRACK=m
-# CONFIG_IP_NF_CT_ACCT is not set
-# CONFIG_IP_NF_CONNTRACK_MARK is not set
-# CONFIG_IP_NF_CONNTRACK_EVENTS is not set
-# CONFIG_IP_NF_CT_PROTO_SCTP is not set
-CONFIG_IP_NF_FTP=m
-CONFIG_IP_NF_IRC=m
-# CONFIG_IP_NF_NETBIOS_NS is not set
-# CONFIG_IP_NF_TFTP is not set
-# CONFIG_IP_NF_AMANDA is not set
-# CONFIG_IP_NF_PPTP is not set
-CONFIG_IP_NF_QUEUE=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
 CONFIG_IP_NF_IPTABLES=m
-CONFIG_IP_NF_MATCH_LIMIT=m
-# CONFIG_IP_NF_MATCH_IPRANGE is not set
-CONFIG_IP_NF_MATCH_MAC=m
-# CONFIG_IP_NF_MATCH_PKTTYPE is not set
-CONFIG_IP_NF_MATCH_MARK=m
-CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
 CONFIG_IP_NF_MATCH_TOS=m
-# CONFIG_IP_NF_MATCH_RECENT is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_DSCP is not set
-CONFIG_IP_NF_MATCH_AH_ESP=m
-CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_AH=m
 CONFIG_IP_NF_MATCH_TTL=m
-CONFIG_IP_NF_MATCH_TCPMSS=m
-# CONFIG_IP_NF_MATCH_HELPER is not set
-CONFIG_IP_NF_MATCH_STATE=m
-# CONFIG_IP_NF_MATCH_CONNTRACK is not set
 CONFIG_IP_NF_MATCH_OWNER=m
-# CONFIG_IP_NF_MATCH_PHYSDEV is not set
-# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
-# CONFIG_IP_NF_MATCH_REALM is not set
-# CONFIG_IP_NF_MATCH_SCTP is not set
-# CONFIG_IP_NF_MATCH_DCCP is not set
-# CONFIG_IP_NF_MATCH_COMMENT is not set
-# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
-# CONFIG_IP_NF_MATCH_STRING is not set
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
 CONFIG_IP_NF_FILTER=m
 CONFIG_IP_NF_TARGET_REJECT=m
 CONFIG_IP_NF_TARGET_LOG=m
 CONFIG_IP_NF_TARGET_ULOG=m
-CONFIG_IP_NF_TARGET_TCPMSS=m
-# CONFIG_IP_NF_TARGET_NFQUEUE is not set
-CONFIG_IP_NF_NAT=m
-CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
 CONFIG_IP_NF_TARGET_MASQUERADE=m
 CONFIG_IP_NF_TARGET_REDIRECT=m
-# CONFIG_IP_NF_TARGET_NETMAP is not set
-# CONFIG_IP_NF_TARGET_SAME is not set
-CONFIG_IP_NF_NAT_SNMP_BASIC=m
-CONFIG_IP_NF_NAT_IRC=m
-CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_DSCP is not set
-CONFIG_IP_NF_TARGET_MARK=m
-# CONFIG_IP_NF_TARGET_CLASSIFY is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
 CONFIG_IP_NF_ARPTABLES=m
 CONFIG_IP_NF_ARPFILTER=m
-# CONFIG_IP_NF_ARP_MANGLE is not set
+CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# Bridge: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
-# CONFIG_BRIDGE_NF_EBTABLES is not set
+CONFIG_NF_CONNTRACK_IPV6=m
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_RAW=m
 
 #
-# DCCP Configuration (EXPERIMENTAL)
+# Bridge: Netfilter Configuration
 #
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
 # CONFIG_IP_DCCP is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
 # CONFIG_IP_SCTP is not set
-CONFIG_ATM=y
-CONFIG_ATM_CLIP=y
-# CONFIG_ATM_CLIP_NO_ICMP is not set
-CONFIG_ATM_LANE=m
-CONFIG_ATM_MPOA=m
-CONFIG_ATM_BR2684=m
-# CONFIG_ATM_BR2684_IPFILTER is not set
+CONFIG_TIPC=m
+# CONFIG_TIPC_ADVANCED is not set
+# CONFIG_TIPC_DEBUG is not set
+# CONFIG_ATM is not set
 CONFIG_BRIDGE=m
 CONFIG_VLAN_8021Q=m
 # CONFIG_DECNET is not set
@@ -397,62 +494,20 @@ CONFIG_LLC=m
 CONFIG_IPX=m
 # CONFIG_IPX_INTERN is not set
 CONFIG_ATALK=m
-CONFIG_DEV_APPLETALK=y
+CONFIG_DEV_APPLETALK=m
 CONFIG_IPDDP=m
 CONFIG_IPDDP_ENCAP=y
 CONFIG_IPDDP_DECAP=y
-CONFIG_X25=m
-CONFIG_LAPB=m
-# CONFIG_NET_DIVERT is not set
-CONFIG_ECONET=m
-CONFIG_ECONET_AUNUDP=y
-CONFIG_ECONET_NATIVE=y
-CONFIG_WAN_ROUTER=m
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
 
 #
 # QoS and/or fair queueing
 #
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CLK_JIFFIES=y
-# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
-# CONFIG_NET_SCH_CLK_CPU is not set
-
-#
-# Queueing/Scheduling
-#
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_ATM is not set
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-CONFIG_NET_SCH_DSMARK=m
-# CONFIG_NET_SCH_NETEM is not set
-CONFIG_NET_SCH_INGRESS=m
-
-#
-# Classification
-#
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_BASIC is not set
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
+# CONFIG_NET_SCHED is not set
 CONFIG_NET_CLS_ROUTE=y
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_CLS_U32_MARK is not set
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-# CONFIG_NET_EMATCH is not set
-# CONFIG_NET_CLS_ACT is not set
-CONFIG_NET_CLS_POLICE=y
-# CONFIG_NET_CLS_IND is not set
-CONFIG_NET_ESTIMATOR=y
 
 #
 # Network testing
@@ -460,8 +515,45 @@ CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_PKTGEN=m
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_IEEE80211 is not set
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+CONFIG_BT_SCO=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+# CONFIG_BT_CMTP is not set
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIUSB=m
+CONFIG_BT_HCIUSB_SCO=y
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIBCM203X=m
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=m
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+CONFIG_IEEE80211_SOFTMAC=m
+# CONFIG_IEEE80211_SOFTMAC_DEBUG is not set
+# CONFIG_RFKILL is not set
 
 #
 # Device Drivers
@@ -472,24 +564,22 @@ CONFIG_NET_PKTGEN=m
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
 
 #
 # Connector - unified userspace <-> kernelspace linker
 #
 # CONFIG_CONNECTOR is not set
-
-#
-# Memory Technology Devices (MTD)
-#
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_CONCAT=y
 CONFIG_MTD_PARTITIONS=y
 CONFIG_MTD_REDBOOT_PARTS=y
 CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
-# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
 # CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 # CONFIG_MTD_AFS_PARTS is not set
@@ -498,11 +588,14 @@ CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
 # User Modules And Translation Layers
 #
 CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 # CONFIG_FTL is not set
-# CONFIG_NFTL is not set
+CONFIG_NFTL=y
+CONFIG_NFTL_RW=y
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -510,10 +603,14 @@ CONFIG_MTD_BLOCK=y
 CONFIG_MTD_CFI=y
 # CONFIG_MTD_JEDECPROBE is not set
 CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+# CONFIG_MTD_CFI_NOSWAP is not set
+CONFIG_MTD_CFI_BE_BYTE_SWAP=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
 CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
 # CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
 # CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
 # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
@@ -521,6 +618,7 @@ CONFIG_MTD_CFI_I1=y
 CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_CFI_I4 is not set
 # CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
 CONFIG_MTD_CFI_INTELEXT=y
 # CONFIG_MTD_CFI_AMDSTD is not set
 # CONFIG_MTD_CFI_STAA is not set
@@ -528,7 +626,6 @@ CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
 
 #
 # Mapping drivers for chip access
@@ -547,7 +644,6 @@ CONFIG_MTD_IXP4XX=y
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLKMTD is not set
 # CONFIG_MTD_BLOCK2MTD is not set
 
 #
@@ -556,20 +652,13 @@ CONFIG_MTD_IXP4XX=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
 
 #
-# NAND Flash Device Drivers
-#
-CONFIG_MTD_NAND=m
-# CONFIG_MTD_NAND_VERIFY_WRITE is not set
-CONFIG_MTD_NAND_IDS=m
-# CONFIG_MTD_NAND_DISKONCHIP is not set
-# CONFIG_MTD_NAND_NANDSIM is not set
-
-#
-# OneNAND Flash Device Drivers
+# UBI - Unsorted block images
 #
-# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_UBI is not set
 
 #
 # Parallel port support
@@ -579,6 +668,7 @@ CONFIG_MTD_NAND_IDS=m
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
@@ -588,94 +678,185 @@ CONFIG_MTD_NAND_IDS=m
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP=m
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_NBD=m
 # CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=8192
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-CONFIG_BLK_DEV_IDEPCI=y
-# CONFIG_IDEPCI_SHARE_IRQ is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_GENERIC is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_SL82C105 is not set
-CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
-# CONFIG_IDEDMA_PCI_AUTO is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-CONFIG_BLK_DEV_CMD64X=y
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_HPT34X is not set
-CONFIG_BLK_DEV_HPT366=y
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-CONFIG_BLK_DEV_PDC202XX_NEW=y
-# CONFIG_PDC202XX_FORCE is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_IDE_ARM is not set
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_IDEDMA_IVB is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=10240
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
 # CONFIG_RAID_ATTRS is not set
-# CONFIG_SCSI is not set
+CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+CONFIG_ISCSI_TCP=m
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_SRP is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+CONFIG_SATA_VIA=y
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+CONFIG_PATA_ARTOP=y
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_PLATFORM is not set
+CONFIG_PATA_IXP4XX_CF=y
 
 #
 # Multi-device support (RAID and LVM)
 #
-# CONFIG_MD is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+CONFIG_MD_RAID5_RESHAPE=y
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
 
 #
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
 #
+# CONFIG_FIREWIRE is not set
 # CONFIG_IEEE1394 is not set
 
 #
@@ -687,19 +868,11 @@ CONFIG_BLK_DEV_IDEDMA=y
 # Network device support
 #
 CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
+# CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-
-#
-# ARCnet devices
-#
+CONFIG_TUN=m
 # CONFIG_ARCNET is not set
-
-#
-# PHY device support
-#
 # CONFIG_PHYLIB is not set
 
 #
@@ -707,6 +880,7 @@ CONFIG_DUMMY=y
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+CONFIG_IXP4XX_ETH=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_CASSINI is not set
@@ -726,7 +900,7 @@ CONFIG_NET_PCI=y
 # CONFIG_B44 is not set
 # CONFIG_FORCEDETH is not set
 # CONFIG_DGRS is not set
-CONFIG_EEPRO100=y
+# CONFIG_EEPRO100 is not set
 # CONFIG_E100 is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
@@ -738,10 +912,8 @@ CONFIG_EEPRO100=y
 # CONFIG_SUNDANCE is not set
 # CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
-
-#
-# Ethernet (1000 Mbit)
-#
+# CONFIG_SC92031 is not set
+CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
 # CONFIG_E1000 is not set
@@ -751,122 +923,122 @@ CONFIG_EEPRO100=y
 # CONFIG_R8169 is not set
 # CONFIG_SIS190 is not set
 # CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
 # CONFIG_SK98LIN is not set
-# CONFIG_VIA_VELOCITY is not set
+CONFIG_VIA_VELOCITY=y
 # CONFIG_TIGON3 is not set
 # CONFIG_BNX2 is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
 
 #
-# Ethernet (10000 Mbit)
-#
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_IXGB is not set
-# CONFIG_S2IO is not set
-
-#
-# Token Ring devices
+# Wireless LAN
 #
-# CONFIG_TR is not set
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+# CONFIG_LIBERTAS_DEBUG is not set
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+CONFIG_USB_ZD1201=m
+# CONFIG_HOSTAP is not set
+# CONFIG_BCM43XX is not set
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET_MII=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_MPPE=m
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+CONFIG_NETCONSOLE=m
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
 
 #
-# Wireless LAN (non-hamradio)
+# ISDN subsystem
 #
-CONFIG_NET_RADIO=y
+CONFIG_ISDN=m
 
 #
-# Obsolete Wireless cards support (pre-802.11)
+# Old ISDN4Linux
 #
-# CONFIG_STRIP is not set
+# CONFIG_ISDN_I4L is not set
 
 #
-# Wireless 802.11b ISA/PCI cards support
+# CAPI subsystem
 #
-# CONFIG_AIRO is not set
-CONFIG_HERMES=y
-# CONFIG_PLX_HERMES is not set
-# CONFIG_TMD_HERMES is not set
-# CONFIG_NORTEL_HERMES is not set
-CONFIG_PCI_HERMES=y
-# CONFIG_ATMEL is not set
+CONFIG_ISDN_CAPI=m
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON=y
+CONFIG_CAPI_TRACE=y
+# CONFIG_ISDN_CAPI_MIDDLEWARE is not set
+CONFIG_ISDN_CAPI_CAPI20=m
 
 #
-# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+# CAPI hardware drivers
 #
-# CONFIG_PRISM54 is not set
-# CONFIG_HOSTAP is not set
-CONFIG_NET_WIRELESS=y
 
 #
-# Wan interfaces
+# Active AVM cards
 #
-CONFIG_WAN=y
-# CONFIG_DSCC4 is not set
-# CONFIG_LANMEDIA is not set
-# CONFIG_SYNCLINK_SYNCPPP is not set
-CONFIG_HDLC=m
-CONFIG_HDLC_RAW=y
-# CONFIG_HDLC_RAW_ETH is not set
-CONFIG_HDLC_CISCO=y
-CONFIG_HDLC_FR=y
-CONFIG_HDLC_PPP=y
-CONFIG_HDLC_X25=y
-# CONFIG_PCI200SYN is not set
-# CONFIG_WANXL is not set
-# CONFIG_PC300 is not set
-# CONFIG_FARSYNC is not set
-CONFIG_DLCI=m
-CONFIG_DLCI_COUNT=24
-CONFIG_DLCI_MAX=8
-CONFIG_WAN_ROUTER_DRIVERS=y
-# CONFIG_CYCLADES_SYNC is not set
-# CONFIG_LAPBETHER is not set
-# CONFIG_X25_ASY is not set
-
-#
-# ATM drivers
-#
-# CONFIG_ATM_DUMMY is not set
-CONFIG_ATM_TCP=m
-# CONFIG_ATM_LANAI is not set
-# CONFIG_ATM_ENI is not set
-# CONFIG_ATM_FIRESTREAM is not set
-# CONFIG_ATM_ZATM is not set
-# CONFIG_ATM_NICSTAR is not set
-# CONFIG_ATM_IDT77252 is not set
-# CONFIG_ATM_AMBASSADOR is not set
-# CONFIG_ATM_HORIZON is not set
-# CONFIG_ATM_IA is not set
-# CONFIG_ATM_FORE200E_MAYBE is not set
-# CONFIG_ATM_HE is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_SHAPER is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_CAPI_AVM is not set
 
 #
-# ISDN subsystem
+# Active Eicon DIVA Server cards
 #
-# CONFIG_ISDN is not set
+# CONFIG_CAPI_EICON is not set
 
 #
 # Input device support
 #
 CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
 
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
+CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
@@ -875,8 +1047,16 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_IXP4XX_BEEPER=y
+CONFIG_INPUT_ATI_REMOTE=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+# CONFIG_INPUT_POWERMATE is not set
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_UINPUT=m
 
 #
 # Hardware I/O ports
@@ -888,14 +1068,32 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # Character devices
 #
 # CONFIG_VT is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_MOXA_SMARTIO_NEW is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+CONFIG_N_HDLC=m
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
 
 #
 # Serial drivers
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=m
 CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -905,17 +1103,12 @@ CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_LEGACY_PTYS is not set
 
 #
 # IPMI
 #
 # CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
 CONFIG_WATCHDOG=y
 # CONFIG_WATCHDOG_NOWAYOUT is not set
 
@@ -923,22 +1116,23 @@ CONFIG_WATCHDOG=y
 # Watchdog Device Drivers
 #
 # CONFIG_SOFT_WATCHDOG is not set
-CONFIG_IXP4XX_WATCHDOG=y
+CONFIG_IXP4XX_WATCHDOG=m
 
 #
 # PCI-based Watchdog Cards
 #
 # CONFIG_PCIPCWATCHDOG is not set
 # CONFIG_WDTPCI is not set
-# CONFIG_NVRAM is not set
-# CONFIG_RTC is not set
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
 
 #
-# Ftape, the floppy tape device driver
+# USB-based Watchdog Cards
 #
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_IXP4XX=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
@@ -946,12 +1140,9 @@ CONFIG_IXP4XX_WATCHDOG=y
 # TPM devices
 #
 # CONFIG_TCG_TPM is not set
-# CONFIG_TELCLOCK is not set
-
-#
-# I2C support
-#
+CONFIG_DEVPORT=y
 CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_CHARDEV=y
 
 #
@@ -969,24 +1160,26 @@ CONFIG_I2C_ALGOBIT=y
 # CONFIG_I2C_ALI15X3 is not set
 # CONFIG_I2C_AMD756 is not set
 # CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_GPIO=y
 # CONFIG_I2C_I801 is not set
 # CONFIG_I2C_I810 is not set
 # CONFIG_I2C_PIIX4 is not set
 # CONFIG_I2C_IOP3XX is not set
-CONFIG_I2C_IXP4XX=y
+# CONFIG_I2C_IXP4XX is not set
 # CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_PROSAVAGE is not set
 # CONFIG_I2C_SAVAGE4 is not set
-# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIMTEC is not set
 # CONFIG_I2C_SIS5595 is not set
 # CONFIG_I2C_SIS630 is not set
 # CONFIG_I2C_SIS96X is not set
 # CONFIG_I2C_STUB is not set
+CONFIG_I2C_TINY_USB=m
 # CONFIG_I2C_VIA is not set
 # CONFIG_I2C_VIAPRO is not set
 # CONFIG_I2C_VOODOO3 is not set
-# CONFIG_I2C_PCA_ISA is not set
 
 #
 # Miscellaneous I2C Chip support
@@ -994,30 +1187,55 @@ CONFIG_I2C_IXP4XX=y
 # CONFIG_SENSORS_DS1337 is not set
 # CONFIG_SENSORS_DS1374 is not set
 CONFIG_SENSORS_EEPROM=y
-# CONFIG_SENSORS_PCF8574 is not set
+CONFIG_SENSORS_PCF8574=m
 # CONFIG_SENSORS_PCA9539 is not set
 # CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_SENSORS_RTC8564 is not set
 # CONFIG_SENSORS_MAX6875 is not set
-# CONFIG_RTC_X1205_I2C is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
 # CONFIG_I2C_DEBUG_CHIP is not set
 
 #
-# Hardware Monitoring support
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+CONFIG_W1=m
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_MATROX is not set
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_W1_MASTER_DS2482=m
+# CONFIG_W1_MASTER_DS1WM is not set
+
+#
+# 1-wire Slaves
 #
-CONFIG_HWMON=y
-# CONFIG_HWMON_VID is not set
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_W1_SLAVE_SMEM=m
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_W1_SLAVE_DS2433_CRC=y
+CONFIG_HWMON=m
+CONFIG_HWMON_VID=m
+# CONFIG_SENSORS_ABITUGURU is not set
+CONFIG_SENSORS_AD7418=m
 # CONFIG_SENSORS_ADM1021 is not set
 # CONFIG_SENSORS_ADM1025 is not set
 # CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
 # CONFIG_SENSORS_ADM1031 is not set
 # CONFIG_SENSORS_ADM9240 is not set
 # CONFIG_SENSORS_ASB100 is not set
 # CONFIG_SENSORS_ATXP1 is not set
 # CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
 # CONFIG_SENSORS_FSCHER is not set
 # CONFIG_SENSORS_FSCPOS is not set
 # CONFIG_SENSORS_GL518SM is not set
@@ -1034,13 +1252,20 @@ CONFIG_HWMON=y
 # CONFIG_SENSORS_LM90 is not set
 # CONFIG_SENSORS_LM92 is not set
 # CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
 # CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
 # CONFIG_SENSORS_SIS5595 is not set
 # CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
 # CONFIG_SENSORS_SMSC47B397 is not set
 # CONFIG_SENSORS_VIA686A is not set
-# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+CONFIG_SENSORS_W83781D=m
+# CONFIG_SENSORS_W83791D is not set
 # CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
 # CONFIG_SENSORS_W83L785TS is not set
 # CONFIG_SENSORS_W83627HF is not set
 # CONFIG_SENSORS_W83627EHF is not set
@@ -1049,51 +1274,426 @@ CONFIG_HWMON=y
 #
 # Misc devices
 #
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
 
 #
-# Multimedia Capabilities Port drivers
+# Multifunction device drivers
 #
+# CONFIG_MFD_SM501 is not set
 
 #
-# Multimedia devices
+# LED devices
+#
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
 #
-# CONFIG_VIDEO_DEV is not set
+# LED drivers
+#
+CONFIG_LEDS_IXP4XX=y
 
 #
-# Digital Video Broadcasting Devices
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU_ACTIVITY=y
+
+#
+# Multimedia devices
 #
-# CONFIG_DVB is not set
+CONFIG_VIDEO_DEV=m
+# CONFIG_VIDEO_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_VIVI=m
+CONFIG_VIDEO_SAA5246A=m
+CONFIG_VIDEO_SAA5249=m
+CONFIG_VIDEO_SAA7134=m
+# CONFIG_VIDEO_SAA7134_ALSA is not set
+CONFIG_VIDEO_HEXIUM_ORION=m
+CONFIG_VIDEO_HEXIUM_GEMINI=m
+CONFIG_VIDEO_CX88=m
+CONFIG_VIDEO_CX88_ALSA=m
+# CONFIG_VIDEO_CX88_BLACKBIRD is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_SN9C102 is not set
+CONFIG_USB_ZR364XX=m
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_SAA7146=m
+CONFIG_VIDEO_SAA7146_VV=m
+CONFIG_VIDEO_TUNER=m
+CONFIG_VIDEO_BUF=m
+CONFIG_VIDEO_BTCX=m
+CONFIG_VIDEO_IR=m
+CONFIG_VIDEO_TVEEPROM=m
+# CONFIG_DAB is not set
 
 #
 # Graphics support
 #
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_VGASTATE is not set
 # CONFIG_FB is not set
 
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# PCI devices
+#
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+
+#
+# ALSA ARM devices
+#
+
+#
+# USB devices
+#
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+
+#
+# System on Chip audio support
+#
+# CONFIG_SND_SOC is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=m
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+CONFIG_USB_KBD=m
+# CONFIG_USB_MOUSE is not set
 
 #
 # USB support
 #
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_SPLIT_ISO=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_BIG_ENDIAN_MMIO is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_U132_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
 #
 
 #
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP2101=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_HP4X is not set
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+# CONFIG_USB_SERIAL_OPTION is not set
+CONFIG_USB_SERIAL_OMNINET=m
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_EZUSB=y
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+CONFIG_USB_ADUTUX=m
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+CONFIG_USB_PHIDGET=m
+CONFIG_USB_PHIDGETKIT=m
+CONFIG_USB_PHIDGETMOTORCONTROL=m
+CONFIG_USB_PHIDGETSERVO=m
+# CONFIG_USB_IDMOUSE is not set
+CONFIG_USB_FTDI_ELAN=m
+# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
 
 #
-# MMC/SD Card support
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_RTC_DRV_DS1672=y
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+CONFIG_RTC_DRV_ISL1208=y
+CONFIG_RTC_DRV_X1205=y
+CONFIG_RTC_DRV_PCF8563=y
+# CONFIG_RTC_DRV_PCF8583 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
 #
-# CONFIG_MMC is not set
 
 #
 # File systems
@@ -1101,50 +1701,69 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
-# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT2_FS_SECURITY=y
 # CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
-# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4DEV_FS is not set
 CONFIG_JBD=y
 # CONFIG_JBD_DEBUG is not set
 CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
+CONFIG_REISERFS_FS=y
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
 CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_FUSE_FS is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
 #
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
 
 #
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
-# CONFIG_RELAYFS_FS is not set
+# CONFIG_CONFIGFS_FS is not set
 
 #
 # Miscellaneous filesystems
@@ -1156,11 +1775,11 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
 CONFIG_JFFS2_FS_WRITEBUFFER=y
 # CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
 # CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
 CONFIG_JFFS2_ZLIB=y
 CONFIG_JFFS2_RTIME=y
@@ -1180,16 +1799,30 @@ CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
-# CONFIG_NFSD is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_TCP=y
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -1213,12 +1846,58 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
 
 #
 # Native Language Support
 #
-# CONFIG_NLS is not set
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
 
 #
 # Profiling support
@@ -1229,25 +1908,38 @@ CONFIG_MSDOS_PARTITION=y
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_MUST_CHECK=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
 # CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
-CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
 # CONFIG_DEBUG_INFO is not set
-# CONFIG_DEBUG_FS is not set
 # CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
 CONFIG_FRAME_POINTER=y
+CONFIG_FORCED_INLINING=y
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
 # CONFIG_DEBUG_USER is not set
-CONFIG_DEBUG_ERRORS=y
-CONFIG_DEBUG_LL=y
-# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_LL is not set
 
 #
 # Security options
@@ -1258,7 +1950,44 @@ CONFIG_DEBUG_LL=y
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -1267,9 +1996,19 @@ CONFIG_DEBUG_LL=y
 #
 # Library routines
 #
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_ITU_T is not set
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.22.18/arch/arm/kernel/head.Sixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/kernel/head.S	2008-07-09 15:14:37.000000000 +0200
@@ -76,6 +76,13 @@
 	.section ".text.head", "ax"
 	.type	stext, %function
 ENTRY(stext)
+	/* HACK ALERT: The DS101 boot loader passes in the machine type for
+	 * the IXDP425, which disables the DS101-specific initialisation code.
+	 * Enforce machine type DS101 == 833 == 0x340 + 0x001 here.
+	 * XXX: OpenEmbedded prefixes the zImage instead?
+	 */
+	mov	r1, #832
+	add	r1, r1, #1
 	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
 						@ and irqs disabled
 	mrc	p15, 0, r9, c0, c0		@ get processor id
--- linux-2.6.22.18/arch/arm/kernel/process.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/kernel/process.c	2008-07-09 15:14:37.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/kallsyms.h>
 #include <linux/init.h>
 #include <linux/cpu.h>
+#include <linux/leds.h>
 #include <linux/elfcore.h>
 #include <linux/pm.h>
 #include <linux/tick.h>
@@ -121,6 +122,12 @@ EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 
 /*
+ * CPU activity indicator.
+ */
+void (*leds_idle)(int is_idle);
+EXPORT_SYMBOL(leds_idle);
+
+/*
  * This is our default idle handler.  We need to disable
  * interrupts here to ensure we don't miss a wakeup call.
  */
@@ -161,9 +168,13 @@ void cpu_idle(void)
 		if (!idle)
 			idle = default_idle;
 		leds_event(led_idle_start);
+		if (leds_idle)
+			leds_idle(1);
 		tick_nohz_stop_sched_tick();
 		while (!need_resched())
 			idle();
+		if (leds_idle)
+			leds_idle(0);
 		leds_event(led_idle_end);
 		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();
--- linux-2.6.22.18/arch/arm/kernel/relocate_kernel.Sixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/kernel/relocate_kernel.S	2008-07-09 15:14:37.000000000 +0200
@@ -7,6 +7,23 @@
 	.globl relocate_new_kernel
 relocate_new_kernel:
 
+	/* Move boot params back to where the kernel expects them */
+
+	ldr	r0,kexec_boot_params_address
+	teq	r0,#0
+	beq	8f
+	
+	ldr	r1,kexec_boot_params_copy
+	mov	r6,#KEXEC_BOOT_PARAMS_SIZE/4
+7:
+	ldr	r5,[r1],#4
+	str	r5,[r0],#4
+	subs	r6,r6,#1
+	bne	7b
+	
+8:	
+	/* Boot params moved, now go on with the kernel */
+	
 	ldr	r0,kexec_indirection_page
 	ldr	r1,kexec_start_address
 
@@ -50,7 +67,7 @@ relocate_new_kernel:
 	mov lr,r1
 	mov r0,#0
 	ldr r1,kexec_mach_type
-	mov r2,#0
+	ldr r2,kexec_boot_params_address
 	mov pc,lr
 
 	.globl kexec_start_address
@@ -65,6 +82,16 @@ kexec_indirection_page:
 kexec_mach_type:
 	.long	0x0
 
+	/* phy addr where new kernel will expect to find boot params */
+	.globl kexec_boot_params_address
+kexec_boot_params_address:
+	.long	0x0
+
+	/* phy addr where old kernel put a copy of orig boot params */
+	.globl kexec_boot_params_copy
+kexec_boot_params_copy:
+	.long	0x0
+
 relocate_new_kernel_end:
 
 	.globl relocate_new_kernel_size
--- linux-2.6.22.18/arch/arm/kernel/setup.cixp42x.2	2008-07-09 15:13:36.000000000 +0200
+++ linux-2.6.22.18/arch/arm/kernel/setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
+#include <linux/kexec.h>
 
 #include <asm/cpu.h>
 #include <asm/elf.h>
@@ -768,6 +769,23 @@ static int __init customize_machine(void
 }
 arch_initcall(customize_machine);
 
+#ifdef CONFIG_KEXEC
+
+/* Physical addr of where the boot params should be for this machine */
+extern unsigned long kexec_boot_params_address;
+
+/* Physical addr of the buffer into which the boot params are copied */
+extern unsigned long kexec_boot_params_copy;
+
+/* Pointer to the boot params buffer, for manipulation and display */
+unsigned long kexec_boot_params;
+EXPORT_SYMBOL(kexec_boot_params);
+
+/* The buffer itself - make sure it is sized correctly */
+static unsigned long kexec_boot_params_buf[(KEXEC_BOOT_PARAMS_SIZE + 3) / 4];
+
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
@@ -784,6 +802,13 @@ void __init setup_arch(char **cmdline_p)
 	if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
+#ifdef CONFIG_KEXEC
+	kexec_boot_params_address = mdesc->boot_params;
+	kexec_boot_params_copy = virt_to_phys(kexec_boot_params_buf);
+	kexec_boot_params = (unsigned long)kexec_boot_params_buf;
+	if (mdesc->boot_params)
+		memcpy((void *)kexec_boot_params, tags, KEXEC_BOOT_PARAMS_SIZE);
+#endif
 	/*
 	 * If we have the old style parameters, convert them to
 	 * a tag list.
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/Kconfigixp42x.2	2008-07-09 15:13:36.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/Kconfig	2008-07-09 15:14:37.000000000 +0200
@@ -104,11 +104,28 @@ config MACH_DSMG600
 	  DSM-G600 RevA device. For more information on this platform,
 	  see http://www.nslu2-linux.org/wiki/DSMG600/HomePage
 
+config MACH_DS101
+	bool
+	prompt "Synology DS101"
+	help
+	  Say 'Y' here if you want your kernel to support Synology's
+	  DiskStation DS101(j) device. For more information on this
+	  platform see http://www.nslu2-linux.org/wiki/DS101/HomePage
+
 config	ARCH_IXDP4XX
 	bool
 	depends on ARCH_IXDP425 || MACH_IXDP465 || MACH_KIXRP435
 	default y
 
+config MACH_FSG
+	bool
+	prompt "Freecom FSG-3"
+	select PCI
+	help
+	  Say 'Y' here if you want your kernel to support Freecom's
+	  FSG-3 device. For more information on this platform
+	  see http://www.nslu2-linux.org/wiki/FSG3/HomePage
+
 #
 # Certain registers and IRQs are only enabled if supporting IXP465 CPUs
 #
@@ -205,6 +222,20 @@ config IXP400_LIB
 	  in your build.
 
 
+config IXP4XX_QMGR
+	tristate "IXP4xx Queue Manager support"
+	help
+	  This driver supports IXP4xx built-in hardware queue manager
+	  and is automatically selected by the Ethernet driver.
+
+config IXP4XX_NPE
+	tristate "IXP4xx Network Processor Engine support"
+	select HOTPLUG
+	select FW_LOADER
+	help
+	  This driver supports IXP4xx built-in network coprocessors
+	  and is automatically selected by the Ethernet driver.
+
 endmenu
 
 endif
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/Makefileixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/Makefile	2008-07-09 15:14:37.000000000 +0200
@@ -13,6 +13,8 @@ obj-pci-$(CONFIG_MACH_GTWX5715)		+= gtwx
 obj-pci-$(CONFIG_MACH_NSLU2)		+= nslu2-pci.o
 obj-pci-$(CONFIG_MACH_NAS100D)		+= nas100d-pci.o
 obj-pci-$(CONFIG_MACH_DSMG600)		+= dsmg600-pci.o
+obj-pci-$(CONFIG_MACH_FSG)		+= fsg-pci.o
+obj-pci-$(CONFIG_MACH_DS101)		+= ds101-pci.o
 
 obj-y	+= common.o
 
@@ -24,5 +26,9 @@ obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-
 obj-$(CONFIG_MACH_NSLU2)	+= nslu2-setup.o nslu2-power.o
 obj-$(CONFIG_MACH_NAS100D)	+= nas100d-setup.o nas100d-power.o
 obj-$(CONFIG_MACH_DSMG600)      += dsmg600-setup.o dsmg600-power.o
+obj-$(CONFIG_MACH_FSG)		+= fsg-setup.o
+obj-$(CONFIG_MACH_DS101)	+= ds101-setup.o ds101-buttons.o
 
 obj-$(CONFIG_PCI)		+= $(obj-pci-$(CONFIG_PCI)) common-pci.o
+obj-$(CONFIG_IXP4XX_QMGR)	+= ixp4xx_qmgr.o
+obj-$(CONFIG_IXP4XX_NPE)	+= ixp4xx_npe.o
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/avila-setup.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/avila-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -18,6 +18,11 @@
 #include <linux/tty.h>
 #include <linux/serial_8250.h>
 #include <linux/slab.h>
+#include <linux/i2c-gpio.h>
+#ifdef CONFIG_SENSORS_EEPROM
+#include <linux/i2c.h>
+#include <linux/eeprom.h>
+#endif
 
 #include <asm/types.h>
 #include <asm/setup.h>
@@ -47,18 +52,17 @@ static struct platform_device avila_flas
 	.resource	= &avila_flash_resource,
 };
 
-static struct ixp4xx_i2c_pins avila_i2c_gpio_pins = {
+static struct i2c_gpio_platform_data avila_i2c_gpio_data = {
 	.sda_pin	= AVILA_SDA_PIN,
 	.scl_pin	= AVILA_SCL_PIN,
 };
 
-static struct platform_device avila_i2c_controller = {
-	.name		= "IXP4XX-I2C",
+static struct platform_device avila_i2c_gpio = {
+	.name		= "i2c-gpio",
 	.id		= 0,
-	.dev		= {
-		.platform_data = &avila_i2c_gpio_pins,
+	.dev	 = {
+		.platform_data	= &avila_i2c_gpio_data,
 	},
-	.num_resources	= 0
 };
 
 static struct resource avila_uart_resources[] = {
@@ -132,12 +136,88 @@ static struct platform_device avila_pata
 	.resource		= avila_pata_resources,
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct mac_plat_info avila_plat_mac[] = {
+        {
+                .phy            = 0,
+                .rxq            = 3,
+        }, {
+                .phy            = 1,
+                .rxq            = 4,
+	}
+};
+
+static struct platform_device avila_mac[] = {
+        {
+                .name                   = "ixp4xx_eth",
+                .id                     = IXP4XX_ETH_NPEB,
+                .dev.platform_data      = avila_plat_mac,
+        }, {
+                .name                   = "ixp4xx_eth",
+                .id                     = IXP4XX_ETH_NPEC,
+                .dev.platform_data      = avila_plat_mac + 1,
+	}
+};
+
 static struct platform_device *avila_devices[] __initdata = {
-	&avila_i2c_controller,
+	&avila_i2c_gpio,
 	&avila_flash,
-	&avila_uart
+	&avila_uart,
+	&avila_mac[0],
+	&avila_mac[1],
 };
 
+#ifdef CONFIG_SENSORS_EEPROM
+static int avila_eeprom_do(struct notifier_block *self, unsigned long event, void *t)
+{
+       struct eeprom_data *data = t;
+
+       char macs[12];
+
+       /* The MACs are the first 12 bytes in the eeprom at address 0x51 */
+       if (event == EEPROM_REGISTER && data->client.addr == 0x51) {
+               data->attr->read(&data->client.dev.kobj, macs, 0, 12);
+               memcpy(avila_plat_mac[0].hwaddr, macs, 6);
+               memcpy(avila_plat_mac[1].hwaddr, macs + 6, 6);
+       }
+
+       return NOTIFY_DONE;
+}
+
+static struct notifier_block avila_eeprom_notifier = {
+       .notifier_call = avila_eeprom_do
+};
+#endif
+
+static char avila_rtc_probe[] __initdata = "rtc-ds1672.probe=0,0x68 ";
+
+static void __init avila_fixup(struct machine_desc *desc,
+                struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+    struct tag *t = tags;
+    char *p = *cmdline;
+
+    /* Find the end of the tags table, taking note of any cmdline tag. */
+    for (; t->hdr.size; t = tag_next(t)) {
+        if (t->hdr.tag == ATAG_CMDLINE) {
+            p = t->u.cmdline.cmdline;
+        }
+    }
+
+    /* Overwrite the end of the table with a new cmdline tag. */
+    t->hdr.tag = ATAG_CMDLINE;
+    t->hdr.size = (sizeof (struct tag_header) +
+        strlen(avila_rtc_probe) + strlen(p) + 1 + 4) >> 2;
+    strlcpy(t->u.cmdline.cmdline, avila_rtc_probe, COMMAND_LINE_SIZE);
+    strlcpy(t->u.cmdline.cmdline + strlen(avila_rtc_probe), p,
+        COMMAND_LINE_SIZE - strlen(avila_rtc_probe));
+
+    /* Terminate the table. */
+    t = tag_next(t);
+    t->hdr.tag = ATAG_NONE;
+    t->hdr.size = 0;
+}
+
 static void __init avila_init(void)
 {
 	ixp4xx_sys_init();
@@ -159,12 +239,16 @@ static void __init avila_init(void)
 
 	platform_device_register(&avila_pata);
 
+#ifdef CONFIG_SENSORS_EEPROM
+       register_eeprom_notifier(&avila_eeprom_notifier);
+#endif
 }
 
 MACHINE_START(AVILA, "Gateworks Avila Network Platform")
 	/* Maintainer: Deepak Saxena <dsaxena@plexity.net> */
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xfffc,
+	.fixup          = avila_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer		= &ixp4xx_timer,
@@ -182,6 +266,7 @@ MACHINE_START(LOFT, "Giant Shoulder Inc 
 	/* Maintainer: Tom Billman <kernel@giantshoulderinc.com> */
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xfffc,
+	.fixup          = avila_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer		= &ixp4xx_timer,
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/common.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/common.c	2008-07-09 15:14:37.000000000 +0200
@@ -475,6 +475,7 @@ static struct clock_event_device clockev
 
 static int __init ixp4xx_clockevent_init(void)
 {
+	/* XXX: should this FREQ be ixp4xx_timer_freq??? */
 	clockevent_ixp4xx.mult = div_sc(FREQ, NSEC_PER_SEC,
 					clockevent_ixp4xx.shift);
 	clockevent_ixp4xx.max_delta_ns =
@@ -486,3 +487,17 @@ static int __init ixp4xx_clockevent_init
 	clockevents_register_device(&clockevent_ixp4xx);
 	return 0;
 }
+
+/* fuses */
+
+u32 ixp4xx_read_fuses(void)
+{
+	unsigned int fuses = ~*IXP4XX_EXP_CFG2;
+	fuses &= ~IXP4XX_FUSE_RESERVED;
+	if (!cpu_is_ixp46x())
+		fuses &= ~IXP4XX_FUSE_IXP46X_ONLY;
+
+	return fuses;
+}
+
+EXPORT_SYMBOL(ixp4xx_read_fuses);
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-buttons.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-buttons.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * arch/arm/mach-ixp4xx/ds101-buttons.c
+ *
+ * DS101 Button driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+
+#include <asm/mach-types.h>
+
+static int usbcopyb_irqcount = 0;
+static int resetb_irqcount = 0;
+static int powerb_irqcount = 0;
+
+static irqreturn_t ds101_usbcopy_handler(int irq, void *dev_id)
+{
+	usbcopyb_irqcount++;
+	if (usbcopyb_irqcount > 1)  /* Init creates one IRQ. Ignore it */
+	{
+		/* The GPIO line is shared between the button and the led.
+		 * Make sure the GPIO is GPIO_OUT, so we don't recieve
+		 * irqs from the led going on/off. Disable the irq just in
+		 * case.
+		 */
+		gpio_line_config(DS101_USBCOPYB_IRQ, IXP4XX_GPIO_OUT);
+		disable_irq(DS101_USBCOPYB_IRQ);
+		printk(KERN_INFO "Usbcopy\n");
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ds101_power_handler(int irq, void *dev_id)
+{
+	powerb_irqcount++;
+	if (powerb_irqcount > 1)
+	{
+		/* Make the power led flash */
+		gpio_line_set(DS101_POWER_LED_GPIO, IXP4XX_GPIO_HIGH);
+		ctrl_alt_del();
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ds101_reset_handler(int irq, void *dev_id)
+{
+	resetb_irqcount++;
+	if (resetb_irqcount > 1)
+	{
+		machine_power_off();
+	}
+	return IRQ_HANDLED;
+}
+
+static int __init ds101_buttons_init(void)
+{
+	if (!(machine_is_ds101()))
+		return 0;
+	printk(KERN_INFO "DiskStation DS101 button driver v0.2\n");
+	gpio_line_config(DS101_POWERB_GPIO, (IXP4XX_GPIO_IN|IRQT_FALLING));
+	gpio_line_config(DS101_RESETB_GPIO, (IXP4XX_GPIO_IN|IRQT_FALLING));
+	gpio_line_config(DS101_USBCOPYB_GPIO, (IXP4XX_GPIO_IN|IRQT_FALLING));
+	set_irq_type(DS101_USBCOPYB_IRQ, IRQT_FALLING);
+	set_irq_type(DS101_POWERB_IRQ, IRQT_FALLING);
+	set_irq_type(DS101_RESETB_IRQ, IRQT_FALLING);
+	if (request_irq(DS101_USBCOPYB_IRQ, &ds101_usbcopy_handler, IRQF_DISABLED,
+		"DS101 USBCopy button", NULL) < 0)
+	{
+		printk(KERN_DEBUG "Could not get USBCopy button IRQ (%d)\n",
+				DS101_USBCOPYB_IRQ);
+
+		return -EIO;
+	}
+
+	if (request_irq(DS101_POWERB_IRQ, &ds101_power_handler, IRQF_DISABLED,
+		"DS101 Powerbutton", NULL) < 0)
+	{
+		printk(KERN_DEBUG "Could not get powerbutton IRQ (%d)\n",
+				DS101_POWERB_IRQ);
+		return -EIO;
+	}
+
+	if (request_irq(DS101_RESETB_IRQ, &ds101_reset_handler, IRQF_DISABLED,
+		"DS101 Resetbutton", NULL) < 0)
+	{
+		printk(KERN_DEBUG "Could not get resetbutton IRQ (%d)\n",
+				DS101_RESETB_IRQ);
+		return -EIO;
+	}
+	return 0;
+}
+
+static void __exit ds101_buttons_exit(void)
+{
+	if (!(machine_is_ds101()))
+		return;
+
+	disable_irq(DS101_USBCOPYB_IRQ);
+	disable_irq(DS101_POWERB_IRQ);
+	disable_irq(DS101_RESETB_IRQ);
+	free_irq(DS101_USBCOPYB_IRQ, NULL);
+	free_irq(DS101_POWERB_IRQ, NULL);
+	free_irq(DS101_RESETB_IRQ, NULL);
+}
+
+module_init(ds101_buttons_init);
+module_exit(ds101_buttons_exit);
+
+MODULE_AUTHOR("OEyvind Repvik <nail@nslu2-linux.org>");
+MODULE_DESCRIPTION("DS101 Button driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-pci.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-pci.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * DS101 board-level PCI initialization
+ *
+ * based on ixdp425-pci.c:
+ * 	Copyright (C) 2002 Intel Corporation.
+ * 	Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Maintainer: http://www.nslu2-linux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/mach/pci.h>
+#include <asm/mach-types.h>
+
+void __init ds101_pci_preinit(void)
+{
+	set_irq_type(IRQ_DS101_PCI_INTA, IRQT_LOW);
+	set_irq_type(IRQ_DS101_PCI_INTB, IRQT_LOW);
+	set_irq_type(IRQ_DS101_PCI_INTC, IRQT_LOW);
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init ds101_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	static int pci_irq_table[DS101_PCI_MAX_DEV][DS101_PCI_IRQ_LINES] =
+	{
+		{ IRQ_DS101_PCI_INTA, -1, -1 },
+		{ IRQ_DS101_PCI_INTB, IRQ_DS101_PCI_INTB, IRQ_DS101_PCI_INTC },
+	};
+
+	int irq = -1;
+
+	if (slot >= 1 && slot <= DS101_PCI_MAX_DEV &&
+		pin >= 1 && pin <= DS101_PCI_IRQ_LINES)
+			irq = pci_irq_table[slot-1][pin-1];
+
+	return irq;
+}
+
+struct hw_pci __initdata ds101_pci = {
+	.nr_controllers	= 1,
+	.preinit	= ds101_pci_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= ixp4xx_setup,
+	.scan		= ixp4xx_scan_bus,
+	.map_irq	= ds101_map_irq,
+};
+
+int __init ds101_pci_init(void)
+{
+	if (machine_is_ds101())
+		pci_common_init(&ds101_pci);
+
+	return 0;
+}
+
+subsys_initcall(ds101_pci_init);
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-setup.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ds101-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,248 @@
+/*
+ * Synology DS101 board setup
+ *
+ * based ixdp425-setup.c:
+ * 	Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ * Author: Rod Whitby <rod@whitby.id.au>
+ * Author: OEyvind Repvik <oyvind@repvik.org>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/leds.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/time.h>
+
+#ifdef CONFIG_LEDS_IXP4XX
+static struct resource ds101_led_resources[] = {
+	{
+		.name	= "power",
+		.start	= DS101_POWER_LED_GPIO,
+		.end	= DS101_POWER_LED_GPIO,
+		.flags	= IXP4XX_GPIO_LOW,
+	},
+	{
+		.name	= "usbcopy-solid",
+		.start	= DS101_USBCOPY_SOLID_LED_GPIO,
+		.end	= DS101_USBCOPY_SOLID_LED_GPIO,
+		.flags	= IXP4XX_GPIO_LOW,
+	},
+	{
+		.name	= "usbcopy-blink",
+		.start	= DS101_USBCOPY_BLINK_LED_GPIO,
+		.end	= DS101_USBCOPY_BLINK_LED_GPIO,
+		.flags	= IXP4XX_GPIO_LOW,
+	},
+	{
+		.name	= "status-ready",
+		.start	= DS101_STATUSOK_LED_GPIO,
+		.end	= DS101_STATUSOK_LED_GPIO,
+		.flags	= IXP4XX_GPIO_LOW,
+	},
+	{
+		.name	= "status-error",
+		.start	= DS101_STATUSBAD_LED_GPIO,
+		.start	= DS101_STATUSBAD_LED_GPIO,
+		.flags	= IXP4XX_GPIO_LOW,
+	}
+};
+
+
+static struct platform_device ds101_leds = {
+	.name		= "IXP4XX-GPIO-LED",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(ds101_led_resources),
+	.resource	= ds101_led_resources,
+};
+#endif
+
+static struct i2c_gpio_platform_data ds101_i2c_gpio_data = {
+	.sda_pin	= DS101_SDA_PIN,
+	.scl_pin	= DS101_SCL_PIN,
+};
+
+static struct platform_device ds101_i2c_gpio = {
+	.name			= "i2c-gpio",
+	.id			= 0,
+	.dev = {
+		.platform_data	= &ds101_i2c_gpio_data,
+	},
+};
+
+static struct platform_device ds101_beeper = {
+	.name		= "ixp4xx-beeper",
+	.id		= DS101_BUZZ_GPIO,
+	.num_resources	= 0,
+};
+
+static struct resource ds101_uart_resources[] = {
+	{
+		.start	= IXP4XX_UART1_BASE_PHYS,
+		.end	= IXP4XX_UART1_BASE_PHYS + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IXP4XX_UART2_BASE_PHYS,
+		.end	= IXP4XX_UART2_BASE_PHYS + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct plat_serial8250_port ds101_uart_data[] = {
+	{
+		.mapbase	= IXP4XX_UART1_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART1,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{
+		.mapbase	= IXP4XX_UART2_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART2,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{ }
+};
+
+static struct platform_device ds101_uart = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev.platform_data	= ds101_uart_data,
+	.num_resources		= ARRAY_SIZE(ds101_uart_resources),
+	.resource		= ds101_uart_resources,
+};
+
+static struct platform_device *ds101_devices[] __initdata = {
+	&ds101_i2c_gpio,
+	&ds101_beeper,
+#ifdef CONFIG_LEDS_IXP4XX
+	&ds101_leds,
+#endif
+};
+
+static void ds101_power_off(void)
+{
+	/* Simple, but effective */
+	gpio_line_set(DS101_POWEROFF_GPIO, IXP4XX_GPIO_LOW);
+}
+
+static void __init ds101_timer_init(void)
+{
+    /* The xtal on this machine is non-standard. */
+    ixp4xx_timer_freq = DS101_FREQ;
+
+    /* Call standard timer_init function. */
+    ixp4xx_timer_init();
+}
+
+static struct sys_timer ds101_timer = {
+    .init   = ds101_timer_init,
+};
+
+static void ds101_gpio_setup(void)
+{
+	/* Set up buzzer */
+	gpio_line_config(DS101_BUZZ_GPIO, IXP4XX_GPIO_OUT);
+	gpio_line_set(DS101_BUZZ_GPIO, IXP4XX_GPIO_LOW);
+
+	/* Set up power led */
+	gpio_line_config(DS101_POWER_LED_GPIO, IXP4XX_GPIO_OUT);
+	gpio_line_set(DS101_POWER_LED_GPIO, IXP4XX_GPIO_LOW);
+
+	/* Poweroff */
+	gpio_line_config(DS101_POWEROFF_GPIO, IXP4XX_GPIO_OUT);
+	gpio_line_set(DS101_POWEROFF_GPIO, IXP4XX_GPIO_HIGH);
+
+	/* Status leds */
+	*IXP4XX_GPIO_GPCLKR = 0;
+
+	/* XXX can't the leds subsystem take care of those? */
+	gpio_line_config(DS101_STATUSOK_LED_GPIO, IXP4XX_GPIO_OUT);
+	gpio_line_config(DS101_STATUSBAD_LED_GPIO, IXP4XX_GPIO_OUT);
+	gpio_line_set(DS101_STATUSOK_LED_GPIO, IXP4XX_GPIO_HIGH);
+	gpio_line_set(DS101_STATUSBAD_LED_GPIO, IXP4XX_GPIO_LOW);
+};
+
+static void ds101_cs0_setup(void)
+{
+	/* XXX don't use macro */
+	*IXP4XX_EXP_CS0 = DS101_EXP_CS0_INIT;
+};
+
+static void __init ds101_init(void)
+{
+	ixp4xx_sys_init();
+
+	ds101_cs0_setup(); /* Needed for DoC support */
+	ds101_gpio_setup();
+	pm_power_off = ds101_power_off;
+
+	/*
+	 * This is only useful on a modified machine, but it is valuable
+	 * to have it first in order to see debug messages, and so that
+	 * it does *not* get removed if platform_add_devices fails!
+	 */
+	(void)platform_device_register(&ds101_uart);
+
+	platform_add_devices(ds101_devices, ARRAY_SIZE(ds101_devices));
+}
+
+/*
+ * DS101 bootstrap may pass in parameters, but we zap the mem
+ * settings to be safe (DS101 always has 64MByte at 0, DS101J has
+ * 32MB). The passed in command line can override this default, we
+ * prepend to the config'ed default.
+ *
+ * NOTE: the startup sequence is:
+ *     1) Call the machine fixup
+ *     2) Parse the ATAG list, the ATAG_CMDLINE is copied in
+ *	to default_command_line which is the value of *from
+ *     3) Parse the command line in *from (*not*
+ *	default_command_line unless they are the same!)
+ *
+ * Setting mi->nr_banks causes (2) to 'squash' (set to ATAG_NONE)
+ * any ATAG_MEM tags, but mem= command line options cause nr_banks
+ * to be reset to 0 (on the first mem=)
+ */
+
+static void __init ds101_fixup(struct machine_desc *desc,
+		struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+	/* The DS101 has one bank of 64MByte memory.
+	 * NOTE: setting nr_banks != 0 causes kernel/setup.c to remove
+	 * the mem tags from the tag list. We need do nothing here!
+	 */
+	mi->nr_banks = 1;
+	mi->bank[0].start = 0;
+	mi->bank[0].size = (64*1024*1024);
+	mi->bank[0].node = PHYS_TO_NID(0);
+}
+
+MACHINE_START(DS101, "Synology DiskStation DS101")
+	/* Maintainer: www.nslu2-linux.org */
+	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
+	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.fixup		= ds101_fixup,
+	.map_io		= ixp4xx_map_io,
+	.init_irq	= ixp4xx_init_irq,
+	.timer		= &ds101_timer,
+	.init_machine	= ds101_init,
+MACHINE_END
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/dsmg600-power.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/dsmg600-power.c	2008-07-09 15:14:37.000000000 +0200
@@ -50,6 +50,13 @@ static void dsmg600_power_handler(unsign
 	if (*IXP4XX_GPIO_GPINR & DSMG600_PB_BM) {
 
 		/* IO Pin is 1 (button pushed) */
+		if (power_button_countdown > 0) {
+			power_button_countdown--;
+		}
+
+	} else {
+
+		/* Done on button release, to allow for auto-power-on mods. */
 		if (power_button_countdown == 0) {
 			/* Signal init to do the ctrlaltdel action, this will bypass
 			 * init if it hasn't started and do a kernel_restart.
@@ -58,11 +65,9 @@ static void dsmg600_power_handler(unsign
 
 			/* Change the state of the power LED to "blink" */
 			gpio_line_set(DSMG600_LED_PWR_GPIO, IXP4XX_GPIO_LOW);
+		} else {
+			power_button_countdown = PBUTTON_HOLDDOWN_COUNT;
 		}
-		power_button_countdown--;
-
-	} else {
-		power_button_countdown = PBUTTON_HOLDDOWN_COUNT;
 	}
 
 	mod_timer(&dsmg600_power_timer, jiffies + msecs_to_jiffies(500));
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/dsmg600-setup.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/dsmg600-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -14,7 +14,9 @@
 #include <linux/kernel.h>
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
+#include <linux/i2c-gpio.h>
 
+#include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -37,15 +39,17 @@ static struct platform_device dsmg600_fl
 	.resource		= &dsmg600_flash_resource,
 };
 
-static struct ixp4xx_i2c_pins dsmg600_i2c_gpio_pins = {
+static struct i2c_gpio_platform_data dsmg600_i2c_gpio_data = {
 	.sda_pin		= DSMG600_SDA_PIN,
 	.scl_pin		= DSMG600_SCL_PIN,
 };
 
-static struct platform_device dsmg600_i2c_controller = {
-	.name			= "IXP4XX-I2C",
+static struct platform_device dsmg600_i2c_gpio = {
+	.name			= "i2c-gpio",
 	.id			= 0,
-	.dev.platform_data	= &dsmg600_i2c_gpio_pins,
+	.dev	 = {
+		.platform_data	= &dsmg600_i2c_gpio_data,
+	},
 };
 
 #ifdef CONFIG_LEDS_CLASS
@@ -116,7 +120,7 @@ static struct platform_device dsmg600_ua
 };
 
 static struct platform_device *dsmg600_devices[] __initdata = {
-	&dsmg600_i2c_controller,
+	&dsmg600_i2c_gpio,
 	&dsmg600_flash,
 };
 
@@ -142,6 +146,35 @@ static struct sys_timer dsmg600_timer = 
     .init   = dsmg600_timer_init,
 };
 
+static char dsmg600_rtc_probe[] __initdata = "rtc-pcf8563.probe=0,0x51 ";
+
+static void __init dsmg600_fixup(struct machine_desc *desc,
+                struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+    struct tag *t = tags;
+    char *p = *cmdline;
+
+    /* Find the end of the tags table, taking note of any cmdline tag. */
+    for (; t->hdr.size; t = tag_next(t)) {
+        if (t->hdr.tag == ATAG_CMDLINE) {
+            p = t->u.cmdline.cmdline;
+        }
+    }
+
+    /* Overwrite the end of the table with a new cmdline tag. */
+    t->hdr.tag = ATAG_CMDLINE;
+    t->hdr.size = (sizeof (struct tag_header) +
+        strlen(dsmg600_rtc_probe) + strlen(p) + 1 + 4) >> 2;
+    strlcpy(t->u.cmdline.cmdline, dsmg600_rtc_probe, COMMAND_LINE_SIZE);
+    strlcpy(t->u.cmdline.cmdline + strlen(dsmg600_rtc_probe), p,
+        COMMAND_LINE_SIZE - strlen(dsmg600_rtc_probe));
+
+    /* Terminate the table. */
+    t = tag_next(t);
+    t->hdr.tag = ATAG_NONE;
+    t->hdr.size = 0;
+}
+
 static void __init dsmg600_init(void)
 {
 	ixp4xx_sys_init();
@@ -174,6 +207,7 @@ MACHINE_START(DSMG600, "D-Link DSM-G600 
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
 	.boot_params	= 0x00000100,
+	.fixup          = dsmg600_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer          = &dsmg600_timer,
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/fsg-pci.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/fsg-pci.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,71 @@
+/*
+ * arch/arch/mach-ixp4xx/fsg-pci.c
+ *
+ * FSG board-level PCI initialization
+ *
+ * Author: Rod Whitby <rod@whitby.id.au>
+ * Maintainer: http://www.nslu2-linux.org/
+ *
+ * based on ixdp425-pci.c:
+ *	Copyright (C) 2002 Intel Corporation.
+ *	Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/mach/pci.h>
+#include <asm/mach-types.h>
+
+void __init fsg_pci_preinit(void)
+{
+	set_irq_type(IRQ_FSG_PCI_INTA, IRQT_LOW);
+	set_irq_type(IRQ_FSG_PCI_INTB, IRQT_LOW);
+	set_irq_type(IRQ_FSG_PCI_INTC, IRQT_LOW);
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init fsg_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	static int pci_irq_table[FSG_PCI_IRQ_LINES] = {
+		IRQ_FSG_PCI_INTC,
+		IRQ_FSG_PCI_INTB,
+		IRQ_FSG_PCI_INTA,
+	};
+
+	int irq = -1;
+	slot = slot - 11;
+
+	if (slot >= 1 && slot <= FSG_PCI_MAX_DEV &&
+		pin >= 1 && pin <= FSG_PCI_IRQ_LINES) {
+			irq = pci_irq_table[(slot - 1)];
+	}
+        printk("%s: Mapped slot %d pin %d to IRQ %d\n", __FUNCTION__,slot, pin, irq);
+
+        return irq;
+}
+
+struct hw_pci fsg_pci __initdata = {
+	.nr_controllers = 1,
+	.preinit =        fsg_pci_preinit,
+	.swizzle =        pci_std_swizzle,
+	.setup =          ixp4xx_setup,
+	.scan =           ixp4xx_scan_bus,
+	.map_irq =        fsg_map_irq,
+};
+
+int __init fsg_pci_init(void)
+{
+	if (machine_is_fsg())
+		pci_common_init(&fsg_pci);
+	return 0;
+}
+
+subsys_initcall(fsg_pci_init);
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/fsg-setup.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/fsg-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,242 @@
+/*
+ * arch/arm/mach-ixp4xx/fsg-setup.c
+ *
+ * FSG board-setup
+ *
+ * based ixdp425-setup.c:
+ *      Copyright (C) 2003-2004 MontaVista Software, Inc.
+ *
+ * Author: Rod Whitby <rod@whitby.id.au>
+ * Maintainers: http://www.nslu2-linux.org/
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/leds.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+
+static struct flash_platform_data fsg_flash_data = {
+	.map_name		= "cfi_probe",
+	.width			= 2,
+};
+
+static struct resource fsg_flash_resource = {
+	.flags			= IORESOURCE_MEM,
+};
+
+static struct platform_device fsg_flash = {
+	.name			= "IXP4XX-Flash",
+	.id			= 0,
+	.dev.platform_data	= &fsg_flash_data,
+	.num_resources		= 1,
+	.resource		= &fsg_flash_resource,
+};
+
+static struct i2c_gpio_platform_data fsg_i2c_gpio_data = {
+	.sda_pin		= FSG_SDA_PIN,
+	.scl_pin		= FSG_SCL_PIN,
+};
+
+static struct platform_device fsg_i2c_gpio = {
+	.name			= "i2c-gpio",
+	.id			= 0,
+	.dev	 = {
+		.platform_data	= &fsg_i2c_gpio_data,
+	},
+};
+
+#ifdef CONFIG_LEDS_CLASS
+static struct resource fsg_led_resources[] = {
+	{
+		.name           = "ring",
+		.start          = FSG_LED_RING_GPIO,
+		.end            = FSG_LED_RING_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+	{
+		.name           = "sync",
+		.start          = FSG_LED_SYNC_GPIO,
+		.end            = FSG_LED_SYNC_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+	{
+		.name           = "usb",
+		.start          = FSG_LED_USB_GPIO,
+		.end            = FSG_LED_USB_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+	{
+		.name           = "sata",
+		.start          = FSG_LED_SATA_GPIO,
+		.end            = FSG_LED_SATA_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+	{
+		.name           = "wan",
+		.start          = FSG_LED_WAN_GPIO,
+		.end            = FSG_LED_WAN_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+	{
+		.name           = "wlan",
+		.start          = FSG_LED_WLAN_GPIO,
+		.end            = FSG_LED_WLAN_GPIO,
+		.flags          = IXP4XX_GPIO_HIGH,
+	},
+};
+
+static struct platform_device fsg_leds = {
+        .name                   = "IXP4XX-GPIO-LED",
+        .id                     = -1,
+        .num_resources          = ARRAY_SIZE(fsg_led_resources),
+        .resource               = fsg_led_resources,
+};
+#endif
+
+static struct resource fsg_uart_resources[] = {
+	{
+		.start		= IXP4XX_UART1_BASE_PHYS,
+		.end		= IXP4XX_UART1_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= IXP4XX_UART2_BASE_PHYS,
+		.end		= IXP4XX_UART2_BASE_PHYS + 0x0fff,
+		.flags		= IORESOURCE_MEM,
+	}
+};
+
+static struct plat_serial8250_port fsg_uart_data[] = {
+	{
+		.mapbase	= IXP4XX_UART1_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{
+		.mapbase	= IXP4XX_UART2_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART2_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{ }
+};
+
+static struct platform_device fsg_uart = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev.platform_data	= fsg_uart_data,
+	.num_resources		= ARRAY_SIZE(fsg_uart_resources),
+	.resource		= fsg_uart_resources,
+};
+
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct mac_plat_info fsg_plat_mac[] = {
+        {
+                .phy            = 5,
+                .rxq            = 3,
+        }, {
+                .phy            = 4,
+                .rxq            = 4,
+        }
+};
+
+static struct platform_device fsg_mac[] = {
+        {
+                .name                   = "ixp4xx_eth",
+                .id                     = IXP4XX_ETH_NPEB,
+                .dev.platform_data      = fsg_plat_mac,
+        }, {
+                .name                   = "ixp4xx_eth",
+                .id                     = IXP4XX_ETH_NPEC,
+                .dev.platform_data      = fsg_plat_mac + 1,
+        }
+};
+
+static struct platform_device *fsg_devices[] __initdata = {
+	&fsg_i2c_gpio,
+	&fsg_flash,
+#ifdef CONFIG_LEDS_IXP4XX
+	&fsg_leds,
+#endif
+	&fsg_mac[0],
+	&fsg_mac[1],
+};
+
+static void fsg_flash_add(struct mtd_info *mtd)
+{
+	if (strcmp(mtd->name, "RedBoot config") == 0) {
+		size_t retlen;
+		u_char mac[6];
+
+		if (mtd->read(mtd, 0x0422, 6, &retlen, mac) == 0 && retlen == 6) {
+			printk(KERN_INFO "eth0 mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			memcpy(fsg_plat_mac[0].hwaddr, mac, 6);
+			mac[5]++;
+			printk(KERN_INFO "eth1 mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			memcpy(fsg_plat_mac[1].hwaddr, mac, 6);
+		} else {
+			printk(KERN_ERR "fsg mac: read failed\n");
+		}
+	}
+}
+
+static void fsg_flash_remove(struct mtd_info *mtd) {
+}
+
+static struct mtd_notifier fsg_flash_notifier = {
+	.add = fsg_flash_add,
+	.remove = fsg_flash_remove,
+};
+
+static void __init fsg_init(void)
+{
+	ixp4xx_sys_init();
+
+	fsg_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+	fsg_flash_resource.end =
+		IXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;
+
+        *IXP4XX_EXP_CS0 |= IXP4XX_FLASH_WRITABLE;
+        *IXP4XX_EXP_CS1 = *IXP4XX_EXP_CS0;
+
+	/* Configure CS2 for operation, 8bit and writable */
+	*IXP4XX_EXP_CS2 = 0xbfff0002;
+
+	/* This is only useful on a modified machine, but it is valuable
+	 * to have it first in order to see debug messages, and so that
+	 * it does *not* get removed if platform_add_devices fails!
+	 */
+	(void)platform_device_register(&fsg_uart);
+
+	platform_add_devices(fsg_devices, ARRAY_SIZE(fsg_devices));
+
+	register_mtd_user(&fsg_flash_notifier);
+}
+
+MACHINE_START(FSG, "Freecom FSG-3")
+	/* Maintainer: www.nslu2-linux.org */
+	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
+	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xfffc,
+	.map_io		= ixp4xx_map_io,
+	.init_irq	= ixp4xx_init_irq,
+	.timer		= &ixp4xx_timer,
+	.boot_params	= 0x0100,
+	.init_machine	= fsg_init,
+MACHINE_END
+
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/gtwx5715-pci.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/gtwx5715-pci.c	2008-07-09 15:14:37.000000000 +0200
@@ -25,17 +25,14 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/irq.h>
+
 #include <asm/mach-types.h>
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/arch/gtwx5715.h>
 #include <asm/mach/pci.h>
 
-extern void ixp4xx_pci_preinit(void);
-extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
-extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
-
-
 /*
  * The exact GPIO pins and IRQs are defined in arch-ixp4xx/gtwx5715.h
  * Slot 0 isn't actually populated with a card connector but
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ixdp425-setup.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ixdp425-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/tty.h>
 #include <linux/serial_8250.h>
 #include <linux/slab.h>
+#include <linux/i2c-gpio.h>
 
 #include <asm/types.h>
 #include <asm/setup.h>
@@ -44,18 +45,17 @@ static struct platform_device ixdp425_fl
 	.resource	= &ixdp425_flash_resource,
 };
 
-static struct ixp4xx_i2c_pins ixdp425_i2c_gpio_pins = {
+static struct i2c_gpio_platform_data ixdp425_i2c_gpio_data = {
 	.sda_pin	= IXDP425_SDA_PIN,
 	.scl_pin	= IXDP425_SCL_PIN,
 };
 
-static struct platform_device ixdp425_i2c_controller = {
-	.name		= "IXP4XX-I2C",
+static struct platform_device ixdp425_i2c_gpio = {
+	.name		= "i2c-gpio",
 	.id		= 0,
-	.dev		= {
-		.platform_data = &ixdp425_i2c_gpio_pins,
+	.dev	 = {
+		.platform_data	= &ixdp425_i2c_gpio_data,
 	},
-	.num_resources	= 0
 };
 
 static struct resource ixdp425_uart_resources[] = {
@@ -101,10 +101,35 @@ static struct platform_device ixdp425_ua
 	.resource		= ixdp425_uart_resources
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct mac_plat_info ixdp425_plat_mac[] = {
+	{
+		.phy		= 0,
+		.rxq		= 3,
+	}, {
+		.phy		= 1,
+		.rxq		= 4,
+	}
+};
+
+static struct platform_device ixdp425_mac[] = {
+	{
+		.name			= "ixp4xx_eth",
+		.id			= IXP4XX_ETH_NPEB,
+		.dev.platform_data	= ixdp425_plat_mac,
+	}, {
+		.name			= "ixp4xx_eth",
+		.id			= IXP4XX_ETH_NPEC,
+		.dev.platform_data	= ixdp425_plat_mac + 1,
+	}
+};
+
 static struct platform_device *ixdp425_devices[] __initdata = {
-	&ixdp425_i2c_controller,
+	&ixdp425_i2c_gpio,
 	&ixdp425_flash,
-	&ixdp425_uart
+	&ixdp425_uart,
+	&ixdp425_mac[0],
+	&ixdp425_mac[1],
 };
 
 static void __init ixdp425_init(void)
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ixp4xx_npe.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ixp4xx_npe.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,737 @@
+/*
+ * Intel IXP4xx Network Processor Engine driver for Linux
+ *
+ * Copyright (C) 2007 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * The code is based on publicly available information:
+ * - Intel IXP4xx Developer's Manual and other e-papers
+ * - Intel IXP400 Access Library Software (BSD license)
+ * - previous works by Christian Hohnstaedt <chohnstaedt@innominate.com>
+ *   Thanks, Christian.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/arch/npe.h>
+
+#define DEBUG_MSG			0
+#define DEBUG_FW			0
+
+#define NPE_COUNT			3
+#define MAX_RETRIES			1000	/* microseconds */
+#define NPE_42X_DATA_SIZE		0x800	/* in dwords */
+#define NPE_46X_DATA_SIZE		0x1000
+#define NPE_A_42X_INSTR_SIZE		0x1000
+#define NPE_B_AND_C_42X_INSTR_SIZE	0x800
+#define NPE_46X_INSTR_SIZE		0x1000
+#define REGS_SIZE			0x1000
+
+#define NPE_PHYS_REG			32
+
+#define FW_MAGIC			0xFEEDF00D
+#define FW_BLOCK_TYPE_INSTR		0x0
+#define FW_BLOCK_TYPE_DATA		0x1
+#define FW_BLOCK_TYPE_EOF		0xF
+
+/* NPE exec status (read) and command (write) */
+#define CMD_NPE_STEP			0x01
+#define CMD_NPE_START			0x02
+#define CMD_NPE_STOP			0x03
+#define CMD_NPE_CLR_PIPE		0x04
+#define CMD_CLR_PROFILE_CNT		0x0C
+#define CMD_RD_INS_MEM			0x10 /* instruction memory */
+#define CMD_WR_INS_MEM			0x11
+#define CMD_RD_DATA_MEM			0x12 /* data memory */
+#define CMD_WR_DATA_MEM			0x13
+#define CMD_RD_ECS_REG			0x14 /* exec access register */
+#define CMD_WR_ECS_REG			0x15
+
+#define STAT_RUN			0x80000000
+#define STAT_STOP			0x40000000
+#define STAT_CLEAR			0x20000000
+#define STAT_ECS_K			0x00800000 /* pipeline clean */
+
+#define NPE_STEVT			0x1B
+#define NPE_STARTPC			0x1C
+#define NPE_REGMAP			0x1E
+#define NPE_CINDEX			0x1F
+
+#define INSTR_WR_REG_SHORT		0x0000C000
+#define INSTR_WR_REG_BYTE		0x00004000
+#define INSTR_RD_FIFO			0x0F888220
+#define INSTR_RESET_MBOX		0x0FAC8210
+
+#define ECS_BG_CTXT_REG_0		0x00 /* Background Executing Context */
+#define ECS_BG_CTXT_REG_1		0x01 /*		Stack level */
+#define ECS_BG_CTXT_REG_2		0x02
+#define ECS_PRI_1_CTXT_REG_0		0x04 /* Priority 1 Executing Context */
+#define ECS_PRI_1_CTXT_REG_1		0x05 /*		Stack level */
+#define ECS_PRI_1_CTXT_REG_2		0x06
+#define ECS_PRI_2_CTXT_REG_0		0x08 /* Priority 2 Executing Context */
+#define ECS_PRI_2_CTXT_REG_1		0x09 /*		Stack level */
+#define ECS_PRI_2_CTXT_REG_2		0x0A
+#define ECS_DBG_CTXT_REG_0		0x0C /* Debug Executing Context */
+#define ECS_DBG_CTXT_REG_1		0x0D /*		Stack level */
+#define ECS_DBG_CTXT_REG_2		0x0E
+#define ECS_INSTRUCT_REG		0x11 /* NPE Instruction Register */
+
+#define ECS_REG_0_ACTIVE		0x80000000 /* all levels */
+#define ECS_REG_0_NEXTPC_MASK		0x1FFF0000 /* BG/PRI1/PRI2 levels */
+#define ECS_REG_0_LDUR_BITS		8
+#define ECS_REG_0_LDUR_MASK		0x00000700 /* all levels */
+#define ECS_REG_1_CCTXT_BITS		16
+#define ECS_REG_1_CCTXT_MASK		0x000F0000 /* all levels */
+#define ECS_REG_1_SELCTXT_BITS		0
+#define ECS_REG_1_SELCTXT_MASK		0x0000000F /* all levels */
+#define ECS_DBG_REG_2_IF		0x00100000 /* debug level */
+#define ECS_DBG_REG_2_IE		0x00080000 /* debug level */
+
+/* NPE watchpoint_fifo register bit */
+#define WFIFO_VALID			0x80000000
+
+/* NPE messaging_status register bit definitions */
+#define MSGSTAT_OFNE	0x00010000 /* OutFifoNotEmpty */
+#define MSGSTAT_IFNF	0x00020000 /* InFifoNotFull */
+#define MSGSTAT_OFNF	0x00040000 /* OutFifoNotFull */
+#define MSGSTAT_IFNE	0x00080000 /* InFifoNotEmpty */
+#define MSGSTAT_MBINT	0x00100000 /* Mailbox interrupt */
+#define MSGSTAT_IFINT	0x00200000 /* InFifo interrupt */
+#define MSGSTAT_OFINT	0x00400000 /* OutFifo interrupt */
+#define MSGSTAT_WFINT	0x00800000 /* WatchFifo interrupt */
+
+/* NPE messaging_control register bit definitions */
+#define MSGCTL_OUT_FIFO			0x00010000 /* enable output FIFO */
+#define MSGCTL_IN_FIFO			0x00020000 /* enable input FIFO */
+#define MSGCTL_OUT_FIFO_WRITE		0x01000000 /* enable FIFO + WRITE */
+#define MSGCTL_IN_FIFO_WRITE		0x02000000
+
+/* NPE mailbox_status value for reset */
+#define RESET_MBOX_STAT			0x0000F0F0
+
+const char *npe_names[] = { "NPE-A", "NPE-B", "NPE-C" };
+
+#define print_npe(pri, npe, fmt, ...)					\
+	printk(pri "%s: " fmt, npe_name(npe), ## __VA_ARGS__)
+
+#if DEBUG_MSG
+#define debug_msg(npe, fmt, ...)					\
+	print_npe(KERN_DEBUG, npe, fmt, ## __VA_ARGS__)
+#else
+#define debug_msg(npe, fmt, ...)
+#endif
+
+static struct {
+	u32 reg, val;
+}ecs_reset[] = {
+	{ ECS_BG_CTXT_REG_0,	0xA0000000 },
+	{ ECS_BG_CTXT_REG_1,	0x01000000 },
+	{ ECS_BG_CTXT_REG_2,	0x00008000 },
+	{ ECS_PRI_1_CTXT_REG_0,	0x20000080 },
+	{ ECS_PRI_1_CTXT_REG_1,	0x01000000 },
+	{ ECS_PRI_1_CTXT_REG_2,	0x00008000 },
+	{ ECS_PRI_2_CTXT_REG_0,	0x20000080 },
+	{ ECS_PRI_2_CTXT_REG_1,	0x01000000 },
+	{ ECS_PRI_2_CTXT_REG_2,	0x00008000 },
+	{ ECS_DBG_CTXT_REG_0,	0x20000000 },
+	{ ECS_DBG_CTXT_REG_1,	0x00000000 },
+	{ ECS_DBG_CTXT_REG_2,	0x001E0000 },
+	{ ECS_INSTRUCT_REG,	0x1003C00F },
+};
+
+static struct npe npe_tab[NPE_COUNT] = {
+	{
+		.id	= 0,
+		.regs	= (struct npe_regs __iomem *)IXP4XX_NPEA_BASE_VIRT,
+		.regs_phys = IXP4XX_NPEA_BASE_PHYS,
+	}, {
+		.id	= 1,
+		.regs	= (struct npe_regs __iomem *)IXP4XX_NPEB_BASE_VIRT,
+		.regs_phys = IXP4XX_NPEB_BASE_PHYS,
+	}, {
+		.id	= 2,
+		.regs	= (struct npe_regs __iomem *)IXP4XX_NPEC_BASE_VIRT,
+		.regs_phys = IXP4XX_NPEC_BASE_PHYS,
+	}
+};
+
+int npe_running(struct npe *npe)
+{
+	return (__raw_readl(&npe->regs->exec_status_cmd) & STAT_RUN) != 0;
+}
+
+static void npe_cmd_write(struct npe *npe, u32 addr, int cmd, u32 data)
+{
+	__raw_writel(data, &npe->regs->exec_data);
+	__raw_writel(addr, &npe->regs->exec_addr);
+	__raw_writel(cmd, &npe->regs->exec_status_cmd);
+}
+
+static u32 npe_cmd_read(struct npe *npe, u32 addr, int cmd)
+{
+	__raw_writel(addr, &npe->regs->exec_addr);
+	__raw_writel(cmd, &npe->regs->exec_status_cmd);
+	/* Iintroduce extra read cycles after issuing read command to NPE
+	   so that we read the register after the NPE has updated it.
+	   This is to overcome race condition between XScale and NPE */
+	__raw_readl(&npe->regs->exec_data);
+	__raw_readl(&npe->regs->exec_data);
+	return __raw_readl(&npe->regs->exec_data);
+}
+
+static void npe_clear_active(struct npe *npe, u32 reg)
+{
+	u32 val = npe_cmd_read(npe, reg, CMD_RD_ECS_REG);
+	npe_cmd_write(npe, reg, CMD_WR_ECS_REG, val & ~ECS_REG_0_ACTIVE);
+}
+
+static void npe_start(struct npe *npe)
+{
+	/* ensure only Background Context Stack Level is active */
+	npe_clear_active(npe, ECS_PRI_1_CTXT_REG_0);
+	npe_clear_active(npe, ECS_PRI_2_CTXT_REG_0);
+	npe_clear_active(npe, ECS_DBG_CTXT_REG_0);
+
+	__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);
+	__raw_writel(CMD_NPE_START, &npe->regs->exec_status_cmd);
+}
+
+static void npe_stop(struct npe *npe)
+{
+	__raw_writel(CMD_NPE_STOP, &npe->regs->exec_status_cmd);
+	__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd); /*FIXME?*/
+}
+
+static int __must_check npe_debug_instr(struct npe *npe, u32 instr, u32 ctx,
+					u32 ldur)
+{
+	u32 wc;
+	int i;
+
+	/* set the Active bit, and the LDUR, in the debug level */
+	npe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG,
+		      ECS_REG_0_ACTIVE | (ldur << ECS_REG_0_LDUR_BITS));
+
+	/* set CCTXT at ECS DEBUG L3 to specify in which context to execute
+	   the instruction, and set SELCTXT at ECS DEBUG Level to specify
+	   which context store to access.
+	   Debug ECS Level Reg 1 has form 0x000n000n, where n = context number
+	*/
+	npe_cmd_write(npe, ECS_DBG_CTXT_REG_1, CMD_WR_ECS_REG,
+		      (ctx << ECS_REG_1_CCTXT_BITS) |
+		      (ctx << ECS_REG_1_SELCTXT_BITS));
+
+	/* clear the pipeline */
+	__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);
+
+	/* load NPE instruction into the instruction register */
+	npe_cmd_write(npe, ECS_INSTRUCT_REG, CMD_WR_ECS_REG, instr);
+
+	/* we need this value later to wait for completion of NPE execution
+	   step */
+	wc = __raw_readl(&npe->regs->watch_count);
+
+	/* issue a Step One command via the Execution Control register */
+	__raw_writel(CMD_NPE_STEP, &npe->regs->exec_status_cmd);
+
+	/* Watch Count register increments when NPE completes an instruction */
+	for (i = 0; i < MAX_RETRIES; i++) {
+		if (wc != __raw_readl(&npe->regs->watch_count))
+			return 0;
+		udelay(1);
+	}
+
+	print_npe(KERN_ERR, npe, "reset: npe_debug_instr(): timeout\n");
+	return -ETIMEDOUT;
+}
+
+static int __must_check npe_logical_reg_write8(struct npe *npe, u32 addr,
+					       u8 val, u32 ctx)
+{
+	/* here we build the NPE assembler instruction: mov8 d0, #0 */
+	u32 instr = INSTR_WR_REG_BYTE |	/* OpCode */
+		addr << 9 |		/* base Operand */
+		(val & 0x1F) << 4 |	/* lower 5 bits to immediate data */
+		(val & ~0x1F) << (18 - 5);/* higher 3 bits to CoProc instr. */
+	return npe_debug_instr(npe, instr, ctx, 1); /* execute it */
+}
+
+static int __must_check npe_logical_reg_write16(struct npe *npe, u32 addr,
+						u16 val, u32 ctx)
+{
+	/* here we build the NPE assembler instruction: mov16 d0, #0 */
+	u32 instr = INSTR_WR_REG_SHORT | /* OpCode */
+		addr << 9 |		/* base Operand */
+		(val & 0x1F) << 4 |	/* lower 5 bits to immediate data */
+		(val & ~0x1F) << (18 - 5);/* higher 11 bits to CoProc instr. */
+	return npe_debug_instr(npe, instr, ctx, 1); /* execute it */
+}
+
+static int __must_check npe_logical_reg_write32(struct npe *npe, u32 addr,
+						u32 val, u32 ctx)
+{
+	/* write in 16 bit steps first the high and then the low value */
+	if (npe_logical_reg_write16(npe, addr, val >> 16, ctx))
+		return -ETIMEDOUT;
+	return npe_logical_reg_write16(npe, addr + 2, val & 0xFFFF, ctx);
+}
+
+static int npe_reset(struct npe *npe)
+{
+	u32 val, ctl, exec_count, ctx_reg2;
+	int i;
+
+	ctl = (__raw_readl(&npe->regs->messaging_control) | 0x3F000000) &
+		0x3F3FFFFF;
+
+	/* disable parity interrupt */
+	__raw_writel(ctl & 0x3F00FFFF, &npe->regs->messaging_control);
+
+	/* pre exec - debug instruction */
+	/* turn off the halt bit by clearing Execution Count register. */
+	exec_count = __raw_readl(&npe->regs->exec_count);
+	__raw_writel(0, &npe->regs->exec_count);
+	/* ensure that IF and IE are on (temporarily), so that we don't end up
+	   stepping forever */
+	ctx_reg2 = npe_cmd_read(npe, ECS_DBG_CTXT_REG_2, CMD_RD_ECS_REG);
+	npe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2 |
+		      ECS_DBG_REG_2_IF | ECS_DBG_REG_2_IE);
+
+	/* clear the FIFOs */
+	while (__raw_readl(&npe->regs->watchpoint_fifo) & WFIFO_VALID)
+		;
+	while (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE)
+		/* read from the outFIFO until empty */
+		print_npe(KERN_DEBUG, npe, "npe_reset: read FIFO = 0x%X\n",
+			  __raw_readl(&npe->regs->in_out_fifo));
+
+	while (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)
+		/* step execution of the NPE intruction to read inFIFO using
+		   the Debug Executing Context stack */
+		if (npe_debug_instr(npe, INSTR_RD_FIFO, 0, 0))
+			return -ETIMEDOUT;
+
+	/* reset the mailbox reg from the XScale side */
+	__raw_writel(RESET_MBOX_STAT, &npe->regs->mailbox_status);
+	/* from NPE side */
+	if (npe_debug_instr(npe, INSTR_RESET_MBOX, 0, 0))
+		return -ETIMEDOUT;
+
+	/* Reset the physical registers in the NPE register file */
+	for (val = 0; val < NPE_PHYS_REG; val++) {
+		if (npe_logical_reg_write16(npe, NPE_REGMAP, val >> 1, 0))
+			return -ETIMEDOUT;
+		/* address is either 0 or 4 */
+		if (npe_logical_reg_write32(npe, (val & 1) * 4, 0, 0))
+			return -ETIMEDOUT;
+	}
+
+	/* Reset the context store = each context's Context Store registers */
+
+	/* Context 0 has no STARTPC. Instead, this value is used to set NextPC
+	   for Background ECS, to set where NPE starts executing code */
+	val = npe_cmd_read(npe, ECS_BG_CTXT_REG_0, CMD_RD_ECS_REG);
+	val &= ~ECS_REG_0_NEXTPC_MASK;
+	val |= (0 /* NextPC */ << 16) & ECS_REG_0_NEXTPC_MASK;
+	npe_cmd_write(npe, ECS_BG_CTXT_REG_0, CMD_WR_ECS_REG, val);
+
+	for (i = 0; i < 16; i++) {
+		if (i) {	/* Context 0 has no STEVT nor STARTPC */
+			/* STEVT = off, 0x80 */
+			if (npe_logical_reg_write8(npe, NPE_STEVT, 0x80, i))
+				return -ETIMEDOUT;
+			if (npe_logical_reg_write16(npe, NPE_STARTPC, 0, i))
+				return -ETIMEDOUT;
+		}
+		/* REGMAP = d0->p0, d8->p2, d16->p4 */
+		if (npe_logical_reg_write16(npe, NPE_REGMAP, 0x820, i))
+			return -ETIMEDOUT;
+		if (npe_logical_reg_write8(npe, NPE_CINDEX, 0, i))
+			return -ETIMEDOUT;
+	}
+
+	/* post exec */
+	/* clear active bit in debug level */
+	npe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG, 0);
+	/* clear the pipeline */
+	__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);
+	/* restore previous values */
+	__raw_writel(exec_count, &npe->regs->exec_count);
+	npe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2);
+
+	/* write reset values to Execution Context Stack registers */
+	for (val = 0; val < ARRAY_SIZE(ecs_reset); val++)
+		npe_cmd_write(npe, ecs_reset[val].reg, CMD_WR_ECS_REG,
+			      ecs_reset[val].val);
+
+	/* clear the profile counter */
+	__raw_writel(CMD_CLR_PROFILE_CNT, &npe->regs->exec_status_cmd);
+
+	__raw_writel(0, &npe->regs->exec_count);
+	__raw_writel(0, &npe->regs->action_points[0]);
+	__raw_writel(0, &npe->regs->action_points[1]);
+	__raw_writel(0, &npe->regs->action_points[2]);
+	__raw_writel(0, &npe->regs->action_points[3]);
+	__raw_writel(0, &npe->regs->watch_count);
+
+	val = ixp4xx_read_fuses();
+	/* reset the NPE */
+	ixp4xx_write_fuses(val & ~(IXP4XX_FUSE_RESET_NPEA << npe->id));
+	for (i = 0; i < MAX_RETRIES; i++) {
+		if (!(ixp4xx_read_fuses() &
+		      (IXP4XX_FUSE_RESET_NPEA << npe->id)))
+			break;	/* reset completed */
+		udelay(1);
+	}
+	if (i == MAX_RETRIES)
+		return -ETIMEDOUT;
+
+	/* deassert reset */
+	ixp4xx_write_fuses(val | (IXP4XX_FUSE_RESET_NPEA << npe->id));
+	for (i = 0; i < MAX_RETRIES; i++) {
+		if (ixp4xx_read_fuses() & (IXP4XX_FUSE_RESET_NPEA << npe->id))
+			break;	/* NPE is back alive */
+		udelay(1);
+	}
+	if (i == MAX_RETRIES)
+		return -ETIMEDOUT;
+
+	npe_stop(npe);
+
+	/* restore NPE configuration bus Control Register - parity settings */
+	__raw_writel(ctl, &npe->regs->messaging_control);
+	return 0;
+}
+
+
+int npe_send_message(struct npe *npe, const void *msg, const char *what)
+{
+	const u32 *send = msg;
+	int cycles = 0;
+
+	debug_msg(npe, "Trying to send message %s [%08X:%08X]\n",
+		  what, send[0], send[1]);
+
+	if (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE) {
+		debug_msg(npe, "NPE input FIFO not empty\n");
+		return -EIO;
+	}
+
+	__raw_writel(send[0], &npe->regs->in_out_fifo);
+
+	if (!(__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNF)) {
+		debug_msg(npe, "NPE input FIFO full\n");
+		return -EIO;
+	}
+
+	__raw_writel(send[1], &npe->regs->in_out_fifo);
+
+	while ((cycles < MAX_RETRIES) &&
+	       (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)) {
+		udelay(1);
+		cycles++;
+	}
+
+	if (cycles == MAX_RETRIES) {
+		debug_msg(npe, "Timeout sending message\n");
+		return -ETIMEDOUT;
+	}
+
+	debug_msg(npe, "Sending a message took %i cycles\n", cycles);
+	return 0;
+}
+
+int npe_recv_message(struct npe *npe, void *msg, const char *what)
+{
+	u32 *recv = msg;
+	int cycles = 0, cnt = 0;
+
+	debug_msg(npe, "Trying to receive message %s\n", what);
+
+	while (cycles < MAX_RETRIES) {
+		if (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE) {
+			recv[cnt++] = __raw_readl(&npe->regs->in_out_fifo);
+			if (cnt == 2)
+				break;
+		} else {
+			udelay(1);
+			cycles++;
+		}
+	}
+
+	switch(cnt) {
+	case 1:
+		debug_msg(npe, "Received [%08X]\n", recv[0]);
+		break;
+	case 2:
+		debug_msg(npe, "Received [%08X:%08X]\n", recv[0], recv[1]);
+		break;
+	}
+
+	if (cycles == MAX_RETRIES) {
+		debug_msg(npe, "Timeout waiting for message\n");
+		return -ETIMEDOUT;
+	}
+
+	debug_msg(npe, "Receiving a message took %i cycles\n", cycles);
+	return 0;
+}
+
+int npe_send_recv_message(struct npe *npe, void *msg, const char *what)
+{
+	int result;
+	u32 *send = msg, recv[2];
+
+	if ((result = npe_send_message(npe, msg, what)) != 0)
+		return result;
+	if ((result = npe_recv_message(npe, recv, what)) != 0)
+		return result;
+
+	if ((recv[0] != send[0]) || (recv[1] != send[1])) {
+		debug_msg(npe, "Message %s: unexpected message received\n",
+			  what);
+		return -EIO;
+	}
+	return 0;
+}
+
+
+int npe_load_firmware(struct npe *npe, const char *name, struct device *dev)
+{
+	const struct firmware *fw_entry;
+
+	struct dl_block {
+		u32 type;
+		u32 offset;
+	} *blk;
+
+	struct dl_image {
+		u32 magic;
+		u32 id;
+		u32 size;
+		union {
+			u32 data[0];
+			struct dl_block blocks[0];
+		};
+	} *image;
+
+	struct dl_codeblock {
+		u32 npe_addr;
+		u32 size;
+		u32 data[0];
+	} *cb;
+
+	int i, j, err, data_size, instr_size, blocks, table_end;
+	u32 cmd;
+
+	if ((err = request_firmware(&fw_entry, name, dev)) != 0)
+		return err;
+
+	err = -EINVAL;
+	if (fw_entry->size < sizeof(struct dl_image)) {
+		print_npe(KERN_ERR, npe, "incomplete firmware file\n");
+		goto err;
+	}
+	image = (struct dl_image*)fw_entry->data;
+
+#if DEBUG_FW
+	print_npe(KERN_DEBUG, npe, "firmware: %08X %08X %08X (0x%X bytes)\n",
+		  image->magic, image->id, image->size, image->size * 4);
+#endif
+
+	if (image->magic == swab32(FW_MAGIC)) { /* swapped file */
+		image->id = swab32(image->id);
+		image->size = swab32(image->size);
+	} else if (image->magic != FW_MAGIC) {
+		print_npe(KERN_ERR, npe, "bad firmware file magic: 0x%X\n",
+			  image->magic);
+		goto err;
+	}
+	if ((image->size * 4 + sizeof(struct dl_image)) != fw_entry->size) {
+		print_npe(KERN_ERR, npe,
+			  "inconsistent size of firmware file\n");
+		goto err;
+	}
+	if (((image->id >> 24) & 0xF /* NPE ID */) != npe->id) {
+		print_npe(KERN_ERR, npe, "firmware file NPE ID mismatch\n");
+		goto err;
+	}
+	if (image->magic == swab32(FW_MAGIC))
+		for (i = 0; i < image->size; i++)
+			image->data[i] = swab32(image->data[i]);
+
+	if (!cpu_is_ixp46x() && ((image->id >> 28) & 0xF /* device ID */)) {
+		print_npe(KERN_INFO, npe, "IXP46x firmware ignored on "
+			  "IXP42x\n");
+		goto err;
+	}
+
+	if (npe_running(npe)) {
+		print_npe(KERN_INFO, npe, "unable to load firmware, NPE is "
+			  "already running\n");
+		err = -EBUSY;
+		goto err;
+	}
+#if 0
+	npe_stop(npe);
+	npe_reset(npe);
+#endif
+
+	print_npe(KERN_INFO, npe, "firmware functionality 0x%X, "
+		  "revision 0x%X:%X\n", (image->id >> 16) & 0xFF,
+		  (image->id >> 8) & 0xFF, image->id & 0xFF);
+
+	if (!cpu_is_ixp46x()) {
+		if (!npe->id)
+			instr_size = NPE_A_42X_INSTR_SIZE;
+		else
+			instr_size = NPE_B_AND_C_42X_INSTR_SIZE;
+		data_size = NPE_42X_DATA_SIZE;
+	} else {
+		instr_size = NPE_46X_INSTR_SIZE;
+		data_size = NPE_46X_DATA_SIZE;
+	}
+
+	for (blocks = 0; blocks * sizeof(struct dl_block) / 4 < image->size;
+	     blocks++)
+		if (image->blocks[blocks].type == FW_BLOCK_TYPE_EOF)
+			break;
+	if (blocks * sizeof(struct dl_block) / 4 >= image->size) {
+		print_npe(KERN_INFO, npe, "firmware EOF block marker not "
+			  "found\n");
+		goto err;
+	}
+
+#if DEBUG_FW
+	print_npe(KERN_DEBUG, npe, "%i firmware blocks found\n", blocks);
+#endif
+
+	table_end = blocks * sizeof(struct dl_block) / 4 + 1 /* EOF marker */;
+	for (i = 0, blk = image->blocks; i < blocks; i++, blk++) {
+		if (blk->offset > image->size - sizeof(struct dl_codeblock) / 4
+		    || blk->offset < table_end) {
+			print_npe(KERN_INFO, npe, "invalid offset 0x%X of "
+				  "firmware block #%i\n", blk->offset, i);
+			goto err;
+		}
+
+		cb = (struct dl_codeblock*)&image->data[blk->offset];
+		if (blk->type == FW_BLOCK_TYPE_INSTR) {
+			if (cb->npe_addr + cb->size > instr_size)
+				goto too_big;
+			cmd = CMD_WR_INS_MEM;
+		} else if (blk->type == FW_BLOCK_TYPE_DATA) {
+			if (cb->npe_addr + cb->size > data_size)
+				goto too_big;
+			cmd = CMD_WR_DATA_MEM;
+		} else {
+			print_npe(KERN_INFO, npe, "invalid firmware block #%i "
+				  "type 0x%X\n", i, blk->type);
+			goto err;
+		}
+		if (blk->offset + sizeof(*cb) / 4 + cb->size > image->size) {
+			print_npe(KERN_INFO, npe, "firmware block #%i doesn't "
+				  "fit in firmware image: type %c, start 0x%X,"
+				  " length 0x%X\n", i,
+				  blk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',
+				  cb->npe_addr, cb->size);
+			goto err;
+		}
+
+		for (j = 0; j < cb->size; j++)
+			npe_cmd_write(npe, cb->npe_addr + j, cmd, cb->data[j]);
+	}
+
+	npe_start(npe);
+	if (!npe_running(npe))
+		print_npe(KERN_ERR, npe, "unable to start\n");
+	release_firmware(fw_entry);
+	return 0;
+
+too_big:
+	print_npe(KERN_INFO, npe, "firmware block #%i doesn't fit in NPE "
+		  "memory: type %c, start 0x%X, length 0x%X\n", i,
+		  blk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',
+		  cb->npe_addr, cb->size);
+err:
+	release_firmware(fw_entry);
+	return err;
+}
+
+
+struct npe *npe_request(int id)
+{
+	if (id < NPE_COUNT)
+		if (npe_tab[id].valid)
+			if (try_module_get(THIS_MODULE))
+				return &npe_tab[id];
+	return NULL;
+}
+
+void npe_release(struct npe *npe)
+{
+	module_put(THIS_MODULE);
+}
+
+
+static int __init npe_init_module(void)
+{
+
+	int i, found = 0;
+
+	for (i = 0; i < NPE_COUNT; i++) {
+		struct npe *npe = &npe_tab[i];
+		if (!(ixp4xx_read_fuses() & (IXP4XX_FUSE_RESET_NPEA << i)))
+			continue; /* NPE already disabled or not present */
+		if (!(npe->mem_res = request_mem_region(npe->regs_phys,
+							REGS_SIZE,
+							npe_name(npe)))) {
+			print_npe(KERN_ERR, npe,
+				  "failed to request memory region\n");
+			continue;
+		}
+
+		if (npe_reset(npe))
+			continue;
+		npe->valid = 1;
+		found++;
+	}
+
+	if (!found)
+		return -ENOSYS;
+	return 0;
+}
+
+static void __exit npe_cleanup_module(void)
+{
+	int i;
+
+	for (i = 0; i < NPE_COUNT; i++)
+		if (npe_tab[i].mem_res) {
+			npe_reset(&npe_tab[i]);
+			release_resource(npe_tab[i].mem_res);
+		}
+}
+
+module_init(npe_init_module);
+module_exit(npe_cleanup_module);
+
+MODULE_AUTHOR("Krzysztof Halasa");
+MODULE_LICENSE("GPL v2");
+
+EXPORT_SYMBOL(npe_names);
+EXPORT_SYMBOL(npe_running);
+EXPORT_SYMBOL(npe_request);
+EXPORT_SYMBOL(npe_release);
+EXPORT_SYMBOL(npe_load_firmware);
+EXPORT_SYMBOL(npe_send_message);
+EXPORT_SYMBOL(npe_recv_message);
+EXPORT_SYMBOL(npe_send_recv_message);
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/ixp4xx_qmgr.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/ixp4xx_qmgr.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * Intel IXP4xx Queue Manager driver for Linux
+ *
+ * Copyright (C) 2007 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/arch/qmgr.h>
+
+#define DEBUG		0
+
+struct qmgr_regs __iomem *qmgr_regs;
+static struct resource *mem_res;
+static spinlock_t qmgr_lock;
+static u32 used_sram_bitmap[4]; /* 128 16-dword pages */
+static void (*irq_handlers[HALF_QUEUES])(void *pdev);
+static void *irq_pdevs[HALF_QUEUES];
+
+void qmgr_set_irq(unsigned int queue, int src,
+		  void (*handler)(void *pdev), void *pdev)
+{
+	u32 __iomem *reg = &qmgr_regs->irqsrc[queue / 8]; /* 8 queues / u32 */
+	int bit = (queue % 8) * 4; /* 3 bits + 1 reserved bit per queue */
+	unsigned long flags;
+
+	src &= 7;
+	spin_lock_irqsave(&qmgr_lock, flags);
+	__raw_writel((__raw_readl(reg) & ~(7 << bit)) | (src << bit), reg);
+	irq_handlers[queue] = handler;
+	irq_pdevs[queue] = pdev;
+	spin_unlock_irqrestore(&qmgr_lock, flags);
+}
+
+
+static irqreturn_t qmgr_irq1(int irq, void *pdev)
+{
+	int i;
+	u32 val = __raw_readl(&qmgr_regs->irqstat[0]);
+	__raw_writel(val, &qmgr_regs->irqstat[0]); /* ACK */
+
+	for (i = 0; i < HALF_QUEUES; i++)
+		if (val & (1 << i))
+			irq_handlers[i](irq_pdevs[i]);
+
+	return val ? IRQ_HANDLED : 0;
+}
+
+
+void qmgr_enable_irq(unsigned int queue)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&qmgr_lock, flags);
+	__raw_writel(__raw_readl(&qmgr_regs->irqen[0]) | (1 << queue),
+		     &qmgr_regs->irqen[0]);
+	spin_unlock_irqrestore(&qmgr_lock, flags);
+}
+
+void qmgr_disable_irq(unsigned int queue)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&qmgr_lock, flags);
+	__raw_writel(__raw_readl(&qmgr_regs->irqen[0]) & ~(1 << queue),
+		     &qmgr_regs->irqen[0]);
+	spin_unlock_irqrestore(&qmgr_lock, flags);
+}
+
+static inline void shift_mask(u32 *mask)
+{
+	mask[3] = mask[3] << 1 | mask[2] >> 31;
+	mask[2] = mask[2] << 1 | mask[1] >> 31;
+	mask[1] = mask[1] << 1 | mask[0] >> 31;
+	mask[0] <<= 1;
+}
+
+int qmgr_request_queue(unsigned int queue, unsigned int len /* dwords */,
+		       unsigned int nearly_empty_watermark,
+		       unsigned int nearly_full_watermark)
+{
+	u32 cfg, addr = 0, mask[4]; /* in 16-dwords */
+	int err;
+
+	if (queue >= HALF_QUEUES)
+		return -ERANGE;
+
+	if ((nearly_empty_watermark | nearly_full_watermark) & ~7)
+		return -EINVAL;
+
+	switch (len) {
+	case  16:
+		cfg = 0 << 24;
+		mask[0] = 0x1;
+		break;
+	case  32:
+		cfg = 1 << 24;
+		mask[0] = 0x3;
+		break;
+	case  64:
+		cfg = 2 << 24;
+		mask[0] = 0xF;
+		break;
+	case 128:
+		cfg = 3 << 24;
+		mask[0] = 0xFF;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cfg |= nearly_empty_watermark << 26;
+	cfg |= nearly_full_watermark << 29;
+	len /= 16;		/* in 16-dwords: 1, 2, 4 or 8 */
+	mask[1] = mask[2] = mask[3] = 0;
+
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
+
+	spin_lock_irq(&qmgr_lock);
+	if (__raw_readl(&qmgr_regs->sram[queue])) {
+		err = -EBUSY;
+		goto err;
+	}
+
+	while (1) {
+		if (!(used_sram_bitmap[0] & mask[0]) &&
+		    !(used_sram_bitmap[1] & mask[1]) &&
+		    !(used_sram_bitmap[2] & mask[2]) &&
+		    !(used_sram_bitmap[3] & mask[3]))
+			break; /* found free space */
+
+		addr++;
+		shift_mask(mask);
+		if (addr + len > ARRAY_SIZE(qmgr_regs->sram)) {
+			printk(KERN_ERR "qmgr: no free SRAM space for"
+			       " queue %i\n", queue);
+			err = -ENOMEM;
+			goto err;
+		}
+	}
+
+	used_sram_bitmap[0] |= mask[0];
+	used_sram_bitmap[1] |= mask[1];
+	used_sram_bitmap[2] |= mask[2];
+	used_sram_bitmap[3] |= mask[3];
+	__raw_writel(cfg | (addr << 14), &qmgr_regs->sram[queue]);
+	spin_unlock_irq(&qmgr_lock);
+
+#if DEBUG
+	printk(KERN_DEBUG "qmgr: requested queue %i, addr = 0x%02X\n",
+	       queue, addr);
+#endif
+	return 0;
+
+err:
+	spin_unlock_irq(&qmgr_lock);
+	module_put(THIS_MODULE);
+	return err;
+}
+
+void qmgr_release_queue(unsigned int queue)
+{
+	u32 cfg, addr, mask[4];
+
+	BUG_ON(queue >= HALF_QUEUES); /* not in valid range */
+
+	spin_lock_irq(&qmgr_lock);
+	cfg = __raw_readl(&qmgr_regs->sram[queue]);
+	addr = (cfg >> 14) & 0xFF;
+
+	BUG_ON(!addr);		/* not requested */
+
+	switch ((cfg >> 24) & 3) {
+	case 0: mask[0] = 0x1; break;
+	case 1: mask[0] = 0x3; break;
+	case 2: mask[0] = 0xF; break;
+	case 3: mask[0] = 0xFF; break;
+	}
+
+	while (addr--)
+		shift_mask(mask);
+
+	__raw_writel(0, &qmgr_regs->sram[queue]);
+
+	used_sram_bitmap[0] &= ~mask[0];
+	used_sram_bitmap[1] &= ~mask[1];
+	used_sram_bitmap[2] &= ~mask[2];
+	used_sram_bitmap[3] &= ~mask[3];
+	irq_handlers[queue] = NULL; /* catch IRQ bugs */
+	spin_unlock_irq(&qmgr_lock);
+
+	module_put(THIS_MODULE);
+#if DEBUG
+	printk(KERN_DEBUG "qmgr: released queue %i\n", queue);
+#endif
+}
+
+static int qmgr_init(void)
+{
+	int i, err;
+	mem_res = request_mem_region(IXP4XX_QMGR_BASE_PHYS,
+				     IXP4XX_QMGR_REGION_SIZE,
+				     "IXP4xx Queue Manager");
+	if (mem_res == NULL)
+		return -EBUSY;
+
+	qmgr_regs = ioremap(IXP4XX_QMGR_BASE_PHYS, IXP4XX_QMGR_REGION_SIZE);
+	if (qmgr_regs == NULL) {
+		err = -ENOMEM;
+		goto error_map;
+	}
+
+	/* reset qmgr registers */
+	for (i = 0; i < 4; i++) {
+		__raw_writel(0x33333333, &qmgr_regs->stat1[i]);
+		__raw_writel(0, &qmgr_regs->irqsrc[i]);
+	}
+	for (i = 0; i < 2; i++) {
+		__raw_writel(0, &qmgr_regs->stat2[i]);
+		__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[i]); /* clear */
+		__raw_writel(0, &qmgr_regs->irqen[i]);
+	}
+
+	for (i = 0; i < QUEUES; i++)
+		__raw_writel(0, &qmgr_regs->sram[i]);
+
+	err = request_irq(IRQ_IXP4XX_QM1, qmgr_irq1, 0,
+			  "IXP4xx Queue Manager", NULL);
+	if (err) {
+		printk(KERN_ERR "qmgr: failed to request IRQ%i\n",
+		       IRQ_IXP4XX_QM1);
+		goto error_irq;
+	}
+
+	used_sram_bitmap[0] = 0xF; /* 4 first pages reserved for config */
+	spin_lock_init(&qmgr_lock);
+
+	printk(KERN_INFO "IXP4xx Queue Manager initialized.\n");
+	return 0;
+
+error_irq:
+	iounmap(qmgr_regs);
+error_map:
+	release_resource(mem_res);
+	return err;
+}
+
+static void qmgr_remove(void)
+{
+	free_irq(IRQ_IXP4XX_QM1, NULL);
+	synchronize_irq(IRQ_IXP4XX_QM1);
+	iounmap(qmgr_regs);
+	release_resource(mem_res);
+}
+
+module_init(qmgr_init);
+module_exit(qmgr_remove);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Krzysztof Halasa");
+
+EXPORT_SYMBOL(qmgr_regs);
+EXPORT_SYMBOL(qmgr_set_irq);
+EXPORT_SYMBOL(qmgr_enable_irq);
+EXPORT_SYMBOL(qmgr_disable_irq);
+EXPORT_SYMBOL(qmgr_request_queue);
+EXPORT_SYMBOL(qmgr_release_queue);
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/nas100d-power.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/nas100d-power.c	2008-07-09 15:14:37.000000000 +0200
@@ -21,15 +21,60 @@
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/reboot.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
 
 #include <asm/mach-types.h>
 
-static irqreturn_t nas100d_reset_handler(int irq, void *dev_id)
+extern void ctrl_alt_del(void);
+
+/* This is used to make sure the power-button pusher is serious.  The button
+ * must be held until the value of this counter reaches zero.
+ */
+static volatile int power_button_countdown;
+
+/* Must hold the button down for at least this many counts to be processed */
+#define PBUTTON_HOLDDOWN_COUNT 4 /* 2 secs */
+
+static void nas100d_power_handler(unsigned long data);
+static DEFINE_TIMER(nas100d_power_timer, nas100d_power_handler, 0, 0);
+
+static void nas100d_power_handler(unsigned long data)
 {
-	/* Signal init to do the ctrlaltdel action, this will bypass init if
-	 * it hasn't started and do a kernel_restart.
+	/* This routine is called twice per second to check the
+	 * state of the power button.
 	 */
-	ctrl_alt_del();
+
+	if (*IXP4XX_GPIO_GPINR & NAS100D_PB_BM) {
+
+		/* IO Pin is 1 (button pushed) */
+		if (power_button_countdown > 0) {
+			power_button_countdown--;
+		}
+
+	} else {
+
+		/* Done on button release, to allow for auto-power-on mods. */
+		if (power_button_countdown == 0) {
+			/* Signal init to do the ctrlaltdel action, this will bypass
+			 * init if it hasn't started and do a kernel_restart.
+			 */
+			ctrl_alt_del();
+
+			/* Change the state of the power LED to "blink" */
+			gpio_line_set(NAS100D_LED_PWR_GPIO, IXP4XX_GPIO_LOW);
+		} else {
+			power_button_countdown = PBUTTON_HOLDDOWN_COUNT;
+		}
+	}
+
+	mod_timer(&nas100d_power_timer, jiffies + msecs_to_jiffies(500));
+}
+
+static irqreturn_t nas100d_reset_handler(int irq, void *dev_id)
+{
+	/* This is the paper-clip reset, it shuts the machine down directly. */
+	machine_power_off();
 
 	return IRQ_HANDLED;
 }
@@ -50,6 +95,19 @@ static int __init nas100d_power_init(voi
 		return -EIO;
 	}
 
+	/* The power button on the Iomega NAS100d is on GPIO 14, but
+	 * it cannot handle interrupts on that GPIO line.  So we'll
+	 * have to poll it with a kernel timer.
+	 */
+
+	/* Make sure that the power button GPIO is set up as an input */
+	gpio_line_config(NAS100D_PB_GPIO, IXP4XX_GPIO_IN);
+
+	/* Set the initial value for the power button IRQ handler */
+	power_button_countdown = PBUTTON_HOLDDOWN_COUNT;
+
+	mod_timer(&nas100d_power_timer, jiffies + msecs_to_jiffies(500));
+
 	return 0;
 }
 
@@ -58,6 +116,8 @@ static void __exit nas100d_power_exit(vo
 	if (!(machine_is_nas100d()))
 		return;
 
+	del_timer_sync(&nas100d_power_timer);
+
 	free_irq(NAS100D_RB_IRQ, NULL);
 }
 
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/nas100d-setup.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/nas100d-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -16,7 +16,10 @@
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
 #include <linux/leds.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
 
+#include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -68,16 +71,17 @@ static struct platform_device nas100d_le
 };
 #endif
 
-static struct ixp4xx_i2c_pins nas100d_i2c_gpio_pins = {
+static struct i2c_gpio_platform_data nas100d_i2c_gpio_data = {
 	.sda_pin		= NAS100D_SDA_PIN,
 	.scl_pin		= NAS100D_SCL_PIN,
 };
 
-static struct platform_device nas100d_i2c_controller = {
-	.name			= "IXP4XX-I2C",
+static struct platform_device nas100d_i2c_gpio = {
+	.name			= "i2c-gpio",
 	.id			= 0,
-	.dev.platform_data	= &nas100d_i2c_gpio_pins,
-	.num_resources		= 0,
+	.dev	 = {
+		.platform_data	= &nas100d_i2c_gpio_data,
+	},
 };
 
 static struct resource nas100d_uart_resources[] = {
@@ -123,12 +127,53 @@ static struct platform_device nas100d_ua
 	.resource		= nas100d_uart_resources,
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct mac_plat_info nas100d_plat_mac[] = {
+        {
+                .phy            = 0,
+                .rxq            = 3,
+        }
+};
+
+static struct platform_device nas100d_mac[] = {
+        {
+                .name                   = "ixp4xx_eth",
+                .id                     = IXP4XX_ETH_NPEB,
+                .dev.platform_data      = nas100d_plat_mac,
+        }
+};
+
 static struct platform_device *nas100d_devices[] __initdata = {
-	&nas100d_i2c_controller,
+	&nas100d_i2c_gpio,
 	&nas100d_flash,
 #ifdef CONFIG_LEDS_IXP4XX
 	&nas100d_leds,
 #endif
+	&nas100d_mac[0],
+};
+
+static void nas100d_flash_add(struct mtd_info *mtd)
+{
+	if (strcmp(mtd->name, "RedBoot config") == 0) {
+		size_t retlen;
+		u_char mac[6];
+
+		if (mtd->read(mtd, 0x0FD8, 6, &retlen, mac) == 0 && retlen == 6) {
+			printk(KERN_INFO "nas100d mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			memcpy(nas100d_plat_mac[0].hwaddr, mac, 6);
+		} else {
+			printk(KERN_ERR "nas100d mac: read failed\n");
+		}
+	}
+}
+
+static void nas100d_flash_remove(struct mtd_info *mtd) {
+}
+
+static struct mtd_notifier nas100d_flash_notifier = {
+	.add = nas100d_flash_add,
+	.remove = nas100d_flash_remove,
 };
 
 static void nas100d_power_off(void)
@@ -142,6 +187,35 @@ static void nas100d_power_off(void)
 	gpio_line_set(NAS100D_PO_GPIO, IXP4XX_GPIO_HIGH);
 }
 
+static char nas100d_rtc_probe[] __initdata = "rtc-pcf8563.probe=0,0x51 ";
+
+static void __init nas100d_fixup(struct machine_desc *desc,
+                struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+    struct tag *t = tags;
+    char *p = *cmdline;
+
+    /* Find the end of the tags table, taking note of any cmdline tag. */
+    for (; t->hdr.size; t = tag_next(t)) {
+        if (t->hdr.tag == ATAG_CMDLINE) {
+            p = t->u.cmdline.cmdline;
+        }
+    }
+
+    /* Overwrite the end of the table with a new cmdline tag. */
+    t->hdr.tag = ATAG_CMDLINE;
+    t->hdr.size = (sizeof (struct tag_header) +
+        strlen(nas100d_rtc_probe) + strlen(p) + 1 + 4) >> 2;
+    strlcpy(t->u.cmdline.cmdline, nas100d_rtc_probe, COMMAND_LINE_SIZE);
+    strlcpy(t->u.cmdline.cmdline + strlen(nas100d_rtc_probe), p,
+        COMMAND_LINE_SIZE - strlen(nas100d_rtc_probe));
+
+    /* Terminate the table. */
+    t = tag_next(t);
+    t->hdr.tag = ATAG_NONE;
+    t->hdr.size = 0;
+}
+
 static void __init nas100d_init(void)
 {
 	ixp4xx_sys_init();
@@ -163,6 +237,8 @@ static void __init nas100d_init(void)
 	(void)platform_device_register(&nas100d_uart);
 
 	platform_add_devices(nas100d_devices, ARRAY_SIZE(nas100d_devices));
+
+	register_mtd_user(&nas100d_flash_notifier);
 }
 
 MACHINE_START(NAS100D, "Iomega NAS 100d")
@@ -170,6 +246,7 @@ MACHINE_START(NAS100D, "Iomega NAS 100d"
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
 	.boot_params	= 0x00000100,
+	.fixup          = nas100d_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer          = &ixp4xx_timer,
--- linux-2.6.22.18/arch/arm/mach-ixp4xx/nslu2-setup.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mach-ixp4xx/nslu2-setup.c	2008-07-09 15:14:37.000000000 +0200
@@ -18,7 +18,10 @@
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
 #include <linux/leds.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/mtd.h>
 
+#include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -41,7 +44,7 @@ static struct platform_device nslu2_flas
 	.resource		= &nslu2_flash_resource,
 };
 
-static struct ixp4xx_i2c_pins nslu2_i2c_gpio_pins = {
+static struct i2c_gpio_platform_data nslu2_i2c_gpio_data = {
 	.sda_pin		= NSLU2_SDA_PIN,
 	.scl_pin		= NSLU2_SCL_PIN,
 };
@@ -82,11 +85,12 @@ static struct platform_device nslu2_leds
 };
 #endif
 
-static struct platform_device nslu2_i2c_controller = {
-	.name			= "IXP4XX-I2C",
+static struct platform_device nslu2_i2c_gpio = {
+	.name			= "i2c-gpio",
 	.id			= 0,
-	.dev.platform_data	= &nslu2_i2c_gpio_pins,
-	.num_resources		= 0,
+	.dev	 = {
+		.platform_data	= &nslu2_i2c_gpio_data,
+	},
 };
 
 static struct platform_device nslu2_beeper = {
@@ -138,13 +142,54 @@ static struct platform_device nslu2_uart
 	.resource		= nslu2_uart_resources,
 };
 
+/* Built-in 10/100 Ethernet MAC interfaces */
+static struct mac_plat_info nslu2_plat_mac[] = {
+	{
+		.phy		= 1,
+		.rxq		= 3,
+	}
+};
+
+static struct platform_device nslu2_mac[] = {
+	{
+		.name			= "ixp4xx_eth",
+		.id			= IXP4XX_ETH_NPEB,
+		.dev.platform_data	= nslu2_plat_mac,
+	}
+};
+
 static struct platform_device *nslu2_devices[] __initdata = {
-	&nslu2_i2c_controller,
+	&nslu2_i2c_gpio,
 	&nslu2_flash,
 	&nslu2_beeper,
 #ifdef CONFIG_LEDS_IXP4XX
 	&nslu2_leds,
 #endif
+	&nslu2_mac[0],
+};
+
+static void nslu2_flash_add(struct mtd_info *mtd)
+{
+	if (strcmp(mtd->name, "RedBoot") == 0) {
+		size_t retlen;
+		u_char mac[6];
+
+		if (mtd->read(mtd, 0x3FFB0, 6, &retlen, mac) == 0 && retlen == 6) {
+			printk(KERN_INFO "nslu2 mac: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			memcpy(nslu2_plat_mac[0].hwaddr, mac, 6);
+		} else {
+			printk(KERN_ERR "nslu2 mac: read failed\n");
+		}
+	}
+}
+
+static void nslu2_flash_remove(struct mtd_info *mtd) {
+}
+
+static struct mtd_notifier nslu2_flash_notifier = {
+	.add = nslu2_flash_add,
+	.remove = nslu2_flash_remove,
 };
 
 static void nslu2_power_off(void)
@@ -171,6 +216,35 @@ static struct sys_timer nslu2_timer = {
     .init   = nslu2_timer_init,
 };
 
+static char nslu2_rtc_probe[] __initdata = "rtc-x1205.probe=0,0x6f ";
+
+static void __init nslu2_fixup(struct machine_desc *desc,
+                struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+    struct tag *t = tags;
+    char *p = *cmdline;
+
+    /* Find the end of the tags table, taking note of any cmdline tag. */
+    for (; t->hdr.size; t = tag_next(t)) {
+        if (t->hdr.tag == ATAG_CMDLINE) {
+            p = t->u.cmdline.cmdline;
+        }
+    }
+
+    /* Overwrite the end of the table with a new cmdline tag. */
+    t->hdr.tag = ATAG_CMDLINE;
+    t->hdr.size = (sizeof (struct tag_header) +
+        strlen(nslu2_rtc_probe) + strlen(p) + 1 + 4) >> 2;
+    strlcpy(t->u.cmdline.cmdline, nslu2_rtc_probe, COMMAND_LINE_SIZE);
+    strlcpy(t->u.cmdline.cmdline + strlen(nslu2_rtc_probe), p,
+        COMMAND_LINE_SIZE - strlen(nslu2_rtc_probe));
+
+    /* Terminate the table. */
+    t = tag_next(t);
+    t->hdr.tag = ATAG_NONE;
+    t->hdr.size = 0;
+}
+
 static void __init nslu2_init(void)
 {
 	ixp4xx_sys_init();
@@ -189,6 +263,8 @@ static void __init nslu2_init(void)
 	(void)platform_device_register(&nslu2_uart);
 
 	platform_add_devices(nslu2_devices, ARRAY_SIZE(nslu2_devices));
+
+	register_mtd_user(&nslu2_flash_notifier);
 }
 
 MACHINE_START(NSLU2, "Linksys NSLU2")
@@ -196,6 +272,7 @@ MACHINE_START(NSLU2, "Linksys NSLU2")
 	.phys_io	= IXP4XX_PERIPHERAL_BASE_PHYS,
 	.io_pg_offst	= ((IXP4XX_PERIPHERAL_BASE_VIRT) >> 18) & 0xFFFC,
 	.boot_params	= 0x00000100,
+	.fixup          = nslu2_fixup,
 	.map_io		= ixp4xx_map_io,
 	.init_irq	= ixp4xx_init_irq,
 	.timer          = &nslu2_timer,
--- linux-2.6.22.18/arch/arm/mm/alignment.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/arch/arm/mm/alignment.c	2008-07-09 15:14:37.000000000 +0200
@@ -68,7 +68,7 @@ static unsigned long ai_half;
 static unsigned long ai_word;
 static unsigned long ai_dword;
 static unsigned long ai_multi;
-static int ai_usermode;
+static int ai_usermode = 3;
 
 #ifdef CONFIG_PROC_FS
 static const char *usermode_action[] = {
--- linux-2.6.22.18/drivers/ata/pata_artop.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/ata/pata_artop.c	2008-07-09 15:14:37.000000000 +0200
@@ -26,6 +26,7 @@
 #include <scsi/scsi_host.h>
 #include <linux/libata.h>
 #include <linux/ata.h>
+#include <asm/mach-types.h>
 
 #define DRV_NAME	"pata_artop"
 #define DRV_VERSION	"0.4.3"
@@ -480,6 +481,11 @@ static int artop_init_one (struct pci_de
 		pci_read_config_byte(pdev, 0x4a, &reg);
 		pci_write_config_byte(pdev, 0x4a, (reg & ~0x01) | 0x80);
 
+		/* NAS100D workaround - probing second port kills uhci_hcd */
+#ifdef CONFIG_MACH_NAS100D
+		if (machine_is_nas100d())
+			ppi[1] = &ata_dummy_port_info;
+#endif
 	}
 
 	BUG_ON(ppi[0] == NULL);
--- linux-2.6.22.18/drivers/ata/pata_ixp4xx_cf.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/ata/pata_ixp4xx_cf.c	2008-07-09 15:14:37.000000000 +0200
@@ -178,7 +178,6 @@ static __devinit int ixp4xx_pata_probe(s
 	struct ata_host *host;
 	struct ata_port *ap;
 	struct ixp4xx_pata_data *data = pdev->dev.platform_data;
-	int rc;
 
 	cs0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	cs1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
--- linux-2.6.22.18/drivers/char/random.cixp42x.2	2008-07-09 15:13:36.000000000 +0200
+++ linux-2.6.22.18/drivers/char/random.c	2008-07-09 15:14:37.000000000 +0200
@@ -258,9 +258,9 @@
 /*
  * Configuration information
  */
-#define INPUT_POOL_WORDS 128
-#define OUTPUT_POOL_WORDS 32
-#define SEC_XFER_SIZE 512
+#define INPUT_POOL_WORDS 256
+#define OUTPUT_POOL_WORDS 64
+#define SEC_XFER_SIZE 1024
 
 /*
  * The minimum number of bits of entropy before we wake up a read on
--- linux-2.6.22.18/drivers/i2c/chips/eeprom.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/i2c/chips/eeprom.c	2008-07-09 15:14:37.000000000 +0200
@@ -33,6 +33,8 @@
 #include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/eeprom.h>
 
 /* Addresses to scan */
 static unsigned short normal_i2c[] = { 0x50, 0x51, 0x52, 0x53, 0x54,
@@ -41,26 +43,7 @@ static unsigned short normal_i2c[] = { 0
 /* Insmod parameters */
 I2C_CLIENT_INSMOD_1(eeprom);
 
-
-/* Size of EEPROM in bytes */
-#define EEPROM_SIZE		256
-
-/* possible types of eeprom devices */
-enum eeprom_nature {
-	UNKNOWN,
-	VAIO,
-};
-
-/* Each client has this additional data */
-struct eeprom_data {
-	struct i2c_client client;
-	struct mutex update_lock;
-	u8 valid;			/* bitfield, bit!=0 if slice is valid */
-	unsigned long last_updated[8];	/* In jiffies, 8 slices */
-	u8 data[EEPROM_SIZE];		/* Register values */
-	enum eeprom_nature nature;
-};
-
+ATOMIC_NOTIFIER_HEAD(eeprom_chain);
 
 static int eeprom_attach_adapter(struct i2c_adapter *adapter);
 static int eeprom_detect(struct i2c_adapter *adapter, int address, int kind);
@@ -196,6 +179,7 @@ static int eeprom_detect(struct i2c_adap
 	data->valid = 0;
 	mutex_init(&data->update_lock);
 	data->nature = UNKNOWN;
+	data->attr = &eeprom_attr;
 
 	/* Tell the I2C layer a new client has arrived */
 	if ((err = i2c_attach_client(new_client)))
@@ -223,6 +207,9 @@ static int eeprom_detect(struct i2c_adap
 	if (err)
 		goto exit_detach;
 
+	/* call the notifier chain */
+	atomic_notifier_call_chain(&eeprom_chain, EEPROM_REGISTER, data);
+
 	return 0;
 
 exit_detach:
@@ -248,6 +235,41 @@ static int eeprom_detach_client(struct i
 	return 0;
 }
 
+/**
+ * register_eeprom_notifier - register a 'user' of EEPROM devices.
+ * @nb: pointer to notifier info structure
+ *
+ * Registers a callback function to be called upon detection
+ * of an EEPROM device.  Detection invokes the 'add' callback
+ * with the kobj of the mutex and a bin_attribute which allows
+ * read from the EEPROM.  The intention is that the notifier
+ * will be able to read system configuration from the notifier.
+ *
+ * Only EEPROMs detected *after* the addition of the notifier
+ * are notified.  I.e. EEPROMs already known to the system
+ * will not be notified - add the notifier from board level
+ * code!
+ */
+int register_eeprom_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&eeprom_chain, nb);
+}
+
+/**
+ *	unregister_eeprom_notifier - unregister a 'user' of EEPROM devices.
+ *	@old: pointer to notifier info structure
+ *
+ *	Removes a callback function from the list of 'users' to be
+ *	notified upon detection of EEPROM devices.
+ */
+int unregister_eeprom_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&eeprom_chain, nb);
+}
+
+EXPORT_SYMBOL_GPL(register_eeprom_notifier);
+EXPORT_SYMBOL_GPL(unregister_eeprom_notifier);
+
 static int __init eeprom_init(void)
 {
 	return i2c_add_driver(&eeprom_driver);
--- linux-2.6.22.18/drivers/leds/Kconfigixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/leds/Kconfig	2008-07-09 15:14:37.000000000 +0200
@@ -128,5 +128,14 @@ config LEDS_TRIGGER_HEARTBEAT
 	  load average.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_CPU_ACTIVITY
+	tristate "LED CPU activity trigger"
+	depends LEDS_TRIGGER_TIMER
+	help
+	  This allows LEDs to be set to show cpu activity via sysfs.
+	  The LED will blink when the cpu is active and stay steady
+	  (on or off according to the trigger selected) when idle.
+	  If unsure, say Y.
+
 endmenu
 
--- linux-2.6.22.18/drivers/leds/Makefileixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/leds/Makefile	2008-07-09 15:14:37.000000000 +0200
@@ -21,3 +21,4 @@ obj-$(CONFIG_LEDS_COBALT)		+= leds-cobal
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
 obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK)	+= ledtrig-ide-disk.o
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
+obj-$(CONFIG_LEDS_TRIGGER_CPU_ACTIVITY)	+= ledtrig-cpu.o
--- linux-2.6.22.18/drivers/leds/ledtrig-cpu.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/drivers/leds/ledtrig-cpu.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,487 @@
+/*
+ * LEDs CPU activity trigger
+ *
+ * Author: John Bowler <jbowler@acm.org>
+ *
+ * Copyright (c) 2006 John Bowler
+ *
+ * Permission is hereby granted, free of charge, to any
+ * person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the
+ * Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+ * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/device.h>
+
+#include <linux/leds.h>
+#include "leds.h"
+
+//#include <linux/list.h>
+//#include <linux/sysdev.h>
+
+
+/*
+ * To simplify this the LED state is given for each case of
+ * CPU state - idle or active.  The LED can be:
+ *
+ * off
+ * flash - slow for idle, fast (flicker) for active
+ * on
+ *
+ * This gives two useless states - off/off and on/on
+ */
+typedef enum cpu_trigger_led_state {
+	cpu_led_off,
+	cpu_led_flash,
+	cpu_led_on,
+	cpu_led_invalid
+} cpu_trigger_led_state;
+
+static const char *const cpu_trigger_names[] = {
+	"off",
+	"flash",
+	"on",
+	"invalid"
+};
+
+/* Forward declaration - this is called back when an LED property
+ * is changed.
+ */
+static void leds_cpu_trigger_state_change(void);
+
+/*
+ * These constants define the actual mark/space of the flashing
+ * in jiffies.  msecs_to_jiffies rounds up and is compile time
+ * evaluable for constant arguments.  Writing the ?: stuff below
+ * this way ensures the compiler doesn't think it needs to
+ * compile in the math of msecs_to_jiffies.
+ *
+ * These values have been determined by experiment to work well
+ * for the ready/status LED on a LinkSys NSLU2 (light piped) and
+ * for the user LED on a Loft (Gateway Avila variant) board where
+ * the LED was directly visible.  Light Output Varies Everywhere.
+ */
+#define LEDS_CPU_ACTIVE_MARK	msecs_to_jiffies(40)
+#define LEDS_CPU_IDLE_MARK	msecs_to_jiffies(800)
+#define LEDS_CPU_ACTIVE_SPACE	msecs_to_jiffies(60)
+#define LEDS_CPU_IDLE_SPACE	msecs_to_jiffies(800)
+
+
+/*
+ * Individual LEDs ------------------------------------------------------------
+ */
+struct cpu_trigger_data {
+	cpu_trigger_led_state active; /* Behaviour when the CPU is active. */
+	cpu_trigger_led_state idle;   /* Behaviour when the CPU is idle. */
+};
+
+/*
+ * LED state change - called when the state of a single LED might
+ * have changed.  Returns true if the LED is blinking.  The argument
+ * is the blink state - the brightness of the blinking LED.
+ */
+static int leds_cpu_trigger_led_state_change(struct led_classdev *led,
+		int is_active, enum led_brightness brightness)
+{
+	int is_blinking = 0;
+
+	struct cpu_trigger_data *data = led->trigger_data;
+
+	/* Find the new brightness for the LED, if the LED is
+	 * set to flash then the brightness passed in is the
+	 * required value.
+	 */
+	if (likely(data != 0))
+		switch (is_active ? data->active : data->idle) {
+		case cpu_led_off:   brightness = LED_OFF;  break;
+		case cpu_led_flash: is_blinking = 1;       break;
+		case cpu_led_on:    brightness = LED_FULL; break;
+		}
+	else
+		brightness = is_active ? LED_FULL : LED_OFF;
+
+	led_set_brightness(led, brightness);
+
+	return is_blinking;
+}
+
+/*
+ * sysfs properties, the property is output at an list of the
+ * values with the current setting enclosed in []
+ */
+static ssize_t leds_cpu_trigger_show_prop(struct class_device *dev, char *buf,
+		size_t where)
+{
+	struct led_classdev     *led = dev->class_data;
+	cpu_trigger_led_state  item = cpu_led_invalid, i;
+	char                  *next;
+
+	if (likely(led->trigger_data != 0))
+		item = *(const cpu_trigger_led_state*)(
+				led->trigger_data + where);
+
+	for (i=0, next=buf; i<cpu_led_invalid; ++i) {
+		const char *name = cpu_trigger_names[i];
+		size_t len = strlen(name);
+
+		if (i == item)
+			*next++ = '[';
+		memcpy(next, name, len);
+		next += len;
+		if (i == item)
+			*next++ = ']';
+		*next++ = ' ';
+	}
+
+	next[-1] = '\n';
+	*next++ = 0;
+
+	return next - buf;
+}
+
+static ssize_t leds_cpu_trigger_show_active(struct class_device *dev, char *buf)
+{
+	return leds_cpu_trigger_show_prop(dev, buf,
+			offsetof(struct cpu_trigger_data, active));
+}
+
+static ssize_t leds_cpu_trigger_show_idle(struct class_device *dev, char *buf)
+{
+	return leds_cpu_trigger_show_prop(dev, buf,
+			offsetof(struct cpu_trigger_data, idle));
+}
+
+/*
+ * Any matching leading substring selects a property - so "onoffonoff"
+ * sets the property to off.
+ */
+static ssize_t leds_cpu_trigger_store_prop(struct class_device *dev,
+		const char *buf, size_t size, size_t where)
+{
+	size_t rc = 0;
+	cpu_trigger_led_state value = 0/*sic*/;
+	struct led_classdev *led;
+
+	/* ignore space characters before the value. */
+	while (rc < size && isspace(buf[rc]))
+		++rc;
+	if (rc >= size)
+		return rc;
+
+	/* look for a simple match against the trigger name, case
+	 * sensitive.
+	 */
+	do {
+		const char *name = cpu_trigger_names[value];
+		size_t len = strlen(name);
+		if (len <= size && memcmp(buf+rc, name, len) == 0) {
+			rc = len;
+			break;
+		}
+		if (++value >= cpu_led_invalid)
+			return -EINVAL;
+	} while (1);
+
+	led = dev->class_data;
+	if (likely(led->trigger_data != 0))
+		*(cpu_trigger_led_state*)(
+				led->trigger_data + where) = value;
+
+	return rc;
+}
+
+static ssize_t leds_cpu_trigger_store_active(struct class_device *dev,
+		const char *buf, size_t size)
+{
+	ssize_t rc = leds_cpu_trigger_store_prop(dev, buf, size,
+			offsetof(struct cpu_trigger_data, active));
+	/*
+	 * At least one CPU must be active (otherwise who is doing this?)
+	 * Call down into the global state below to cause an update
+	 * to happen now.
+	 */
+	leds_cpu_trigger_state_change();
+	return rc;
+}
+
+static ssize_t leds_cpu_trigger_store_idle(struct class_device *dev,
+		const char *buf, size_t size)
+{
+	return leds_cpu_trigger_store_prop(dev, buf, size,
+			offsetof(struct cpu_trigger_data, idle));
+}
+
+static CLASS_DEVICE_ATTR(active, 0644, leds_cpu_trigger_show_active,
+					leds_cpu_trigger_store_active);
+
+static CLASS_DEVICE_ATTR(idle, 0644, leds_cpu_trigger_show_idle,
+					leds_cpu_trigger_store_idle);
+
+/*
+ * Activate and deactivate are called on individual LEDs when the
+ * LED trigger property is changed.
+ */
+static void leds_cpu_trigger_activate(struct led_classdev *led)
+{
+	/*
+	 * The initial setting of the trigger is simple CPU activity
+	 * with the LED off for idle and on for active.  Consequently
+	 * there is no need to mess with the global state initially,
+	 * we know the CPU is active at this moment!
+	 */
+	struct cpu_trigger_data *data = kmalloc(sizeof *data, GFP_KERNEL);
+	if (unlikely(data == 0))
+		return;
+
+	data->active = cpu_led_on;
+	data->idle = cpu_led_off;
+	led->trigger_data = data;
+
+	class_device_create_file(led->class_dev, &class_device_attr_active);
+	class_device_create_file(led->class_dev, &class_device_attr_idle);
+
+	led_set_brightness(led, LED_FULL);
+}
+
+static void leds_cpu_trigger_deactivate(struct led_classdev *led)
+{
+	struct cpu_trigger_data *data = led->trigger_data;
+	if (likely(data != 0)) {
+		led_set_brightness(led, LED_OFF);
+
+		class_device_remove_file(led->class_dev, &class_device_attr_idle);
+		class_device_remove_file(led->class_dev, &class_device_attr_active);
+
+		led->trigger_data = 0;
+		kfree(data);
+	}
+}
+
+
+/*
+ * Global state  --------------------------------------------------------------
+ *
+ * This is global because the CPU state is global and we only need one timer to
+ * do this stuff.
+ */
+typedef struct leds_cpu_trigger_data {
+	struct led_trigger trigger; /* the lock in here protects everything */
+	struct timer_list  timer;
+	unsigned long      last_active_time; /* record of last jiffies */
+	unsigned long      last_idle_time;   /* record of last jiffies */
+	int                count_active;     /* number of active CPUs */
+} leds_cpu_trigger_data;
+
+/*
+ * Mark state - uses the current time (jiffies) to work out
+ * whether this is a mark or space.
+ */
+static int leds_cpu_trigger_mark(struct leds_cpu_trigger_data *data,
+		unsigned long now) {
+	if (data->count_active > 0) {
+		unsigned long elapsed = now - data->last_active_time;
+		elapsed %= LEDS_CPU_ACTIVE_SPACE + LEDS_CPU_ACTIVE_MARK;
+		data->last_active_time = now - elapsed;
+		return elapsed > LEDS_CPU_ACTIVE_SPACE;
+	} else {
+		unsigned long elapsed = now - data->last_idle_time;
+		elapsed %= LEDS_CPU_IDLE_SPACE + LEDS_CPU_IDLE_MARK;
+		data->last_idle_time = now - elapsed;
+		return elapsed > LEDS_CPU_IDLE_SPACE;
+	}
+}
+
+
+/*
+ * State change - given information about the nature of the
+ * (possible) state change call up to each LED to adjust its
+ * state.  Returns true if any LED is blinking.  The lock
+ * must be held (a read lock is adequate).
+ */
+static int leds_cpu_trigger_scan_leds(struct leds_cpu_trigger_data *data,
+		unsigned long now)
+{
+	int blinking = 0;
+	const int active = data->count_active > 0;
+	const enum led_brightness brightness =
+		leds_cpu_trigger_mark(data, now) ? LED_FULL : LED_OFF;
+	struct list_head *entry;
+
+	list_for_each(entry, &data->trigger.led_cdevs) {
+		struct led_classdev *led =
+			list_entry(entry, struct led_classdev, trig_list);
+
+		blinking |= leds_cpu_trigger_led_state_change(led,
+				active, brightness);
+	}
+
+	return blinking;
+}
+
+/*
+ * Set the timer correctly according to the current state, the lock
+ * must be held for write.
+ */
+static void leds_cpu_trigger_set_timer(struct leds_cpu_trigger_data *state,
+		unsigned long now)
+{
+	unsigned long next;
+	if (state->count_active > 0) {
+		next = state->last_active_time;
+		if (now - next > LEDS_CPU_ACTIVE_SPACE)
+			next += LEDS_CPU_ACTIVE_MARK;
+		next += LEDS_CPU_ACTIVE_SPACE;
+	} else {
+		next = state->last_idle_time;
+		if (now - next > LEDS_CPU_IDLE_SPACE)
+			next += LEDS_CPU_IDLE_MARK;
+		next += LEDS_CPU_IDLE_SPACE;
+	}
+	mod_timer(&state->timer, next);
+}
+
+/*
+ * The timer callback if the LED is currently flashing, the callback
+ * calls the state change function and, if that returns true, meaning
+ * that at least one LED is still blinking, the timer is restarted
+ * with the correct timeout.
+ */
+static void leds_cpu_trigger_timer_callback(unsigned long data)
+{
+	struct leds_cpu_trigger_data *state =
+				(struct leds_cpu_trigger_data *)data;
+
+	write_lock(&state->trigger.leddev_list_lock);
+	{
+		unsigned long now = jiffies;
+
+		/* If at least one LED is set to flash; set the timer
+		 * again (this won't reset the timer set within the
+		 * idle loop).
+		 */
+		if (leds_cpu_trigger_scan_leds(state, now))
+			leds_cpu_trigger_set_timer(state, now);
+	}
+	write_unlock(&state->trigger.leddev_list_lock);
+}
+
+
+/*
+ * There is one global control structure, one timer and one set
+ * of state for active CPUs shared across all the LEDs.  Individual
+ * LEDs say how this state to be handled.  It is currently *not*
+ * possible to show per-cpu activity on individual LEDs, the code
+ * maintains a count of active CPUs and the state is only 'idle'
+ * if all CPUs are idle.
+ */
+static struct leds_cpu_trigger_data leds_cpu_trigger = {
+	.trigger = {
+		.name       = "cpu",
+		.activate   = leds_cpu_trigger_activate,
+		.deactivate = leds_cpu_trigger_deactivate,
+	} ,
+	.timer   = TIMER_INITIALIZER(leds_cpu_trigger_timer_callback, 0,
+			(unsigned long)&leds_cpu_trigger),
+	.last_active_time = 0,
+	.last_idle_time   = 0,
+	.count_active     = 0,
+};
+
+/*
+ * State change - callback from an individual LED on a property change which
+ * might require a redisplay.
+ */
+static void leds_cpu_trigger_state_change() {
+	write_lock(&leds_cpu_trigger.trigger.leddev_list_lock);
+	{
+		unsigned long now = jiffies;
+
+		if (leds_cpu_trigger_scan_leds(&leds_cpu_trigger, now) &&
+			!timer_pending(&leds_cpu_trigger.timer))
+			leds_cpu_trigger_set_timer(&leds_cpu_trigger, now);
+	}
+	write_unlock(&leds_cpu_trigger.trigger.leddev_list_lock);
+}
+
+/*
+ * Called from every CPU at the start and end of the idle loop.
+ * The active count is initially 0, even though CPUs are running,
+ * so the code below must check for the resultant underflow.
+ *
+ * If the idle behaviour is 'flash' then when the timer times out
+ * it will take the CPU out of idle, set the active state (which
+ * may also be flash), drop back into idle and reset the timer to
+ * the idle timeout...
+ */
+static void leds_cpu_trigger_idle(int is_idle)
+{
+	write_lock(&leds_cpu_trigger.trigger.leddev_list_lock);
+	if ((is_idle && leds_cpu_trigger.count_active > 0 &&
+				--leds_cpu_trigger.count_active == 0) ||
+	    (!is_idle && leds_cpu_trigger.count_active < num_online_cpus() &&
+	     			++leds_cpu_trigger.count_active == 1)) {
+		unsigned long now = jiffies;
+
+		/* State change - the system just became idle or active,
+		 * call the del_timer first in an attempt to minimise
+		 * getting a timer interrupt which will take us unnecessarily
+		 * out of idle (this doesn't matter).
+		 */
+		del_timer(&leds_cpu_trigger.timer);
+		if (leds_cpu_trigger_scan_leds(&leds_cpu_trigger, now))
+			leds_cpu_trigger_set_timer(&leds_cpu_trigger, now);
+	}
+	write_unlock(&leds_cpu_trigger.trigger.leddev_list_lock);
+}
+
+/*
+ * Module init and exit - register the trigger, then store
+ * the idle callback in the arch-specific global.  For this
+ * module to link (into the kernel) or load (into a running
+ * kernel) the architecture must define the leds_idle global.
+ */
+static int __init leds_cpu_trigger_init(void)
+{
+	int rc = led_trigger_register(&leds_cpu_trigger.trigger);
+	leds_idle = leds_cpu_trigger_idle;
+	return rc;
+}
+module_init(leds_cpu_trigger_init);
+
+static void __exit leds_cpu_trigger_exit(void)
+{
+	leds_idle = 0;
+	del_timer_sync(&leds_cpu_trigger.timer);
+	led_trigger_unregister(&leds_cpu_trigger.trigger);
+}
+module_exit(leds_cpu_trigger_exit);
+
+MODULE_AUTHOR("John Bowler <jbowler@acm.org>");
+MODULE_DESCRIPTION("CPU activity LED trigger");
+MODULE_LICENSE("MIT");
--- linux-2.6.22.18/drivers/net/arm/Kconfigixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/net/arm/Kconfig	2008-07-09 15:14:37.000000000 +0200
@@ -46,3 +46,13 @@ config EP93XX_ETH
 	help
 	  This is a driver for the ethernet hardware included in EP93xx CPUs.
 	  Say Y if you are building a kernel for EP93xx based devices.
+
+config IXP4XX_ETH
+	tristate "IXP4xx Ethernet support"
+	depends on NET_ETHERNET && ARM && ARCH_IXP4XX
+	select IXP4XX_NPE
+	select IXP4XX_QMGR
+	select MII
+	help
+	  Say Y here if you want to use built-in Ethernet ports
+	  on IXP4xx processor.
--- linux-2.6.22.18/drivers/net/arm/Makefileixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/net/arm/Makefile	2008-07-09 15:14:37.000000000 +0200
@@ -9,3 +9,4 @@ obj-$(CONFIG_ARM_ETHER3)	+= ether3.o
 obj-$(CONFIG_ARM_ETHER1)	+= ether1.o
 obj-$(CONFIG_ARM_AT91_ETHER)	+= at91_ether.o
 obj-$(CONFIG_EP93XX_ETH)	+= ep93xx_eth.o
+obj-$(CONFIG_IXP4XX_ETH)	+= ixp4xx_eth.o
--- linux-2.6.22.18/drivers/net/arm/ixp4xx_eth.cixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/drivers/net/arm/ixp4xx_eth.c	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,1124 @@
+/*
+ * Intel IXP4xx Ethernet driver for Linux
+ *
+ * Copyright (C) 2007 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * Ethernet port config (0x00 is not present on IXP42X):
+ *
+ * logical port		0x00		0x10		0x20
+ * NPE			0 (NPE-A)	1 (NPE-B)	2 (NPE-C)
+ * physical PortId	2		0		1
+ * TX queue		23		24		25
+ * RX-free queue	26		27		28
+ * TX-done queue is always 31, RX queue is configurable
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/kernel.h>
+#include <linux/mii.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/arch/npe.h>
+#include <asm/arch/qmgr.h>
+
+#define DEBUG_QUEUES	0
+#define DEBUG_RX	0
+#define DEBUG_TX	0
+#define DEBUG_PKT_BYTES	0
+#define DEBUG_MDIO	0
+#define DEBUG_CLOSE	0
+
+#define DRV_NAME	"ixp4xx_eth"
+
+#define TX_QUEUE_LEN	16 /* dwords */
+#define PKT_DESCS	64 /* also length of queues: TX-done, RX-ready, RX */
+
+#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (PKT_DESCS))
+#define REGS_SIZE		0x1000
+#define MAX_MRU			1536 /* 0x600 */
+
+#define MDIO_INTERVAL		(3 * HZ)
+#define MAX_MDIO_RETRIES	100 /* microseconds, typically 30 cycles */
+#define MAX_CLOSE_WAIT		1000 /* microseconds, typically 2-3 cycles */
+
+#define NPE_ID(port)		((port)->id >> 4)
+#define PHYSICAL_ID(port)	((NPE_ID(port) + 2) % 3)
+#define TX_QUEUE(plat)		(NPE_ID(port) + 23)
+#define RXFREE_QUEUE(plat)	(NPE_ID(port) + 26)
+#define TXDONE_QUEUE		31
+
+/* TX Control Registers */
+#define TX_CNTRL0_TX_EN		0x01
+#define TX_CNTRL0_HALFDUPLEX	0x02
+#define TX_CNTRL0_RETRY		0x04
+#define TX_CNTRL0_PAD_EN	0x08
+#define TX_CNTRL0_APPEND_FCS	0x10
+#define TX_CNTRL0_2DEFER	0x20
+#define TX_CNTRL0_RMII		0x40 /* reduced MII */
+#define TX_CNTRL1_RETRIES	0x0F /* 4 bits */
+
+/* RX Control Registers */
+#define RX_CNTRL0_RX_EN		0x01
+#define RX_CNTRL0_PADSTRIP_EN	0x02
+#define RX_CNTRL0_SEND_FCS	0x04
+#define RX_CNTRL0_PAUSE_EN	0x08
+#define RX_CNTRL0_LOOP_EN	0x10
+#define RX_CNTRL0_ADDR_FLTR_EN	0x20
+#define RX_CNTRL0_RX_RUNT_EN	0x40
+#define RX_CNTRL0_BCAST_DIS	0x80
+#define RX_CNTRL1_DEFER_EN	0x01
+
+/* Core Control Register */
+#define CORE_RESET		0x01
+#define CORE_RX_FIFO_FLUSH	0x02
+#define CORE_TX_FIFO_FLUSH	0x04
+#define CORE_SEND_JAM		0x08
+#define CORE_MDC_EN		0x10 /* MDIO using NPE-B ETH-0 only */
+
+#define DEFAULT_TX_CNTRL0	(TX_CNTRL0_TX_EN | TX_CNTRL0_RETRY |	\
+				 TX_CNTRL0_PAD_EN | TX_CNTRL0_APPEND_FCS | \
+				 TX_CNTRL0_2DEFER)
+#define DEFAULT_RX_CNTRL0	RX_CNTRL0_RX_EN
+#define DEFAULT_CORE_CNTRL	CORE_MDC_EN
+
+
+/* NPE message codes */
+#define NPE_GETSTATUS			0x00
+#define NPE_EDB_SETPORTADDRESS		0x01
+#define NPE_EDB_GETMACADDRESSDATABASE	0x02
+#define NPE_EDB_SETMACADDRESSSDATABASE	0x03
+#define NPE_GETSTATS			0x04
+#define NPE_RESETSTATS			0x05
+#define NPE_SETMAXFRAMELENGTHS		0x06
+#define NPE_VLAN_SETRXTAGMODE		0x07
+#define NPE_VLAN_SETDEFAULTRXVID	0x08
+#define NPE_VLAN_SETPORTVLANTABLEENTRY	0x09
+#define NPE_VLAN_SETPORTVLANTABLERANGE	0x0A
+#define NPE_VLAN_SETRXQOSENTRY		0x0B
+#define NPE_VLAN_SETPORTIDEXTRACTIONMODE 0x0C
+#define NPE_STP_SETBLOCKINGSTATE	0x0D
+#define NPE_FW_SETFIREWALLMODE		0x0E
+#define NPE_PC_SETFRAMECONTROLDURATIONID 0x0F
+#define NPE_PC_SETAPMACTABLE		0x11
+#define NPE_SETLOOPBACK_MODE		0x12
+#define NPE_PC_SETBSSIDTABLE		0x13
+#define NPE_ADDRESS_FILTER_CONFIG	0x14
+#define NPE_APPENDFCSCONFIG		0x15
+#define NPE_NOTIFY_MAC_RECOVERY_DONE	0x16
+#define NPE_MAC_RECOVERY_START		0x17
+
+
+struct eth_regs {
+	u32 tx_control[2], __res1[2];		/* 000 */
+	u32 rx_control[2], __res2[2];		/* 010 */
+	u32 random_seed, __res3[3];		/* 020 */
+	u32 partial_empty_threshold, __res4;	/* 030 */
+	u32 partial_full_threshold, __res5;	/* 038 */
+	u32 tx_start_bytes, __res6[3];		/* 040 */
+	u32 tx_deferral, rx_deferral,__res7[2];	/* 050 */
+	u32 tx_2part_deferral[2], __res8[2];	/* 060 */
+	u32 slot_time, __res9[3];		/* 070 */
+	u32 mdio_command[4];			/* 080 */
+	u32 mdio_status[4];			/* 090 */
+	u32 mcast_mask[6], __res10[2];		/* 0A0 */
+	u32 mcast_addr[6], __res11[2];		/* 0C0 */
+	u32 int_clock_threshold, __res12[3];	/* 0E0 */
+	u32 hw_addr[6], __res13[61];		/* 0F0 */
+	u32 core_control;			/* 1FC */
+};
+
+struct port {
+	struct resource *mem_res;
+	struct eth_regs __iomem *regs;
+	struct npe *npe;
+	struct net_device *netdev;
+	struct net_device_stats stat;
+	struct mii_if_info mii;
+	struct delayed_work mdio_thread;
+	struct mac_plat_info *plat;
+#ifdef __ARMEB__
+	struct sk_buff *rx_buff_tab[PKT_DESCS];
+#else
+	void *rx_buff_tab[PKT_DESCS];
+#endif
+	struct desc *rx_desc_tab; /* coherent */
+	int id;			/* logical port ID */
+	u32 rx_desc_tab_phys;
+};
+
+/* NPE message structure */
+struct msg {
+#ifdef __ARMEB__
+	u8 cmd, eth_id, byte2, byte3;
+	u8 byte4, byte5, byte6, byte7;
+#else
+	u8 byte3, byte2, eth_id, cmd;
+	u8 byte7, byte6, byte5, byte4;
+#endif
+};
+
+/* Ethernet packet descriptor */
+struct desc {
+	u32 next;		/* pointer to next buffer, unused */
+
+#ifdef __ARMEB__
+	u16 buf_len;		/* buffer length */
+	u16 pkt_len;		/* packet length */
+	u32 data;		/* pointer to data buffer in RAM */
+	u8 dest_id;
+	u8 src_id;
+	u16 flags;
+	u8 qos;
+	u8 padlen;
+	u16 vlan_tci;
+#else
+	u16 pkt_len;		/* packet length */
+	u16 buf_len;		/* buffer length */
+	u32 data;		/* pointer to data buffer in RAM */
+	u16 flags;
+	u8 src_id;
+	u8 dest_id;
+	u16 vlan_tci;
+	u8 padlen;
+	u8 qos;
+#endif
+
+#ifdef __ARMEB__
+	u8 dst_mac_0, dst_mac_1, dst_mac_2, dst_mac_3;
+	u8 dst_mac_4, dst_mac_5, src_mac_0, src_mac_1;
+	u8 src_mac_2, src_mac_3, src_mac_4, src_mac_5;
+#else
+	u8 dst_mac_3, dst_mac_2, dst_mac_1, dst_mac_0;
+	u8 src_mac_1, src_mac_0, dst_mac_5, dst_mac_4;
+	u8 src_mac_5, src_mac_4, src_mac_3, src_mac_2;
+#endif
+};
+
+
+#define rx_desc_phys(port, n)	((port)->rx_desc_tab_phys +		\
+				 (n) * sizeof(struct desc))
+#define tx_desc_phys(n)		(tx_desc_tab_phys + (n) * sizeof(struct desc))
+
+#ifndef __ARMEB__
+static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
+{
+	int i;
+	for (i = 0; i < cnt; i++)
+		dest[i] = swab32(src[i]);
+}
+#endif
+
+static spinlock_t mdio_lock;
+static struct eth_regs __iomem *mdio_regs; /* mdio command and status only */
+static int ports_open;
+static struct dma_pool *dma_pool;
+#ifdef __ARMEB__
+static struct sk_buff *tx_buff_tab[PKT_DESCS];
+#else
+static void *tx_buff_tab[PKT_DESCS];
+#endif
+static struct desc *tx_desc_tab; /* coherent */
+static struct device *tx_owner_tab[PKT_DESCS]; /* for dma_unmap_single() */
+static u32 tx_desc_tab_phys;
+
+
+static u16 mdio_cmd(struct net_device *dev, int phy_id, int location,
+		    int write, u16 cmd)
+{
+	int cycles = 0;
+
+	if (__raw_readl(&mdio_regs->mdio_command[3]) & 0x80) {
+		printk(KERN_ERR "%s: MII not ready to transmit\n", dev->name);
+		return 0;
+	}
+
+	if (write) {
+		__raw_writel(cmd & 0xFF, &mdio_regs->mdio_command[0]);
+		__raw_writel(cmd >> 8, &mdio_regs->mdio_command[1]);
+	}
+	__raw_writel(((phy_id << 5) | location) & 0xFF,
+		     &mdio_regs->mdio_command[2]);
+	__raw_writel((phy_id >> 3) | (write << 2) | 0x80 /* GO */,
+		     &mdio_regs->mdio_command[3]);
+
+	while ((cycles < MAX_MDIO_RETRIES) &&
+	       (__raw_readl(&mdio_regs->mdio_command[3]) & 0x80)) {
+		udelay(1);
+		cycles++;
+	}
+
+	if (cycles == MAX_MDIO_RETRIES) {
+		printk(KERN_ERR "%s: MII write failed\n", dev->name);
+		return 0;
+	}
+
+#if DEBUG_MDIO
+	printk(KERN_DEBUG "mdio_cmd() took %i cycles\n", cycles);
+#endif
+
+	if (write)
+		return 0;
+
+	if (__raw_readl(&mdio_regs->mdio_status[3]) & 0x80) {
+		printk(KERN_ERR "%s: MII read failed\n", dev->name);
+		return 0;
+	}
+
+	return (__raw_readl(&mdio_regs->mdio_status[0]) & 0xFF) |
+		(__raw_readl(&mdio_regs->mdio_status[1]) << 8);
+}
+
+static int mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	unsigned long flags;
+	u16 val;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+	val = mdio_cmd(dev, phy_id, location, 0, 0);
+	spin_unlock_irqrestore(&mdio_lock, flags);
+	return val;
+}
+
+static void mdio_write(struct net_device *dev, int phy_id, int location,
+		       int val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+	mdio_cmd(dev, phy_id, location, 1, val);
+	spin_unlock_irqrestore(&mdio_lock, flags);
+}
+
+static void eth_set_duplex(struct port *port)
+{
+	if (port->mii.full_duplex)
+		__raw_writel(DEFAULT_TX_CNTRL0 & ~TX_CNTRL0_HALFDUPLEX,
+			     &port->regs->tx_control[0]);
+	else
+		__raw_writel(DEFAULT_TX_CNTRL0 | TX_CNTRL0_HALFDUPLEX,
+			     &port->regs->tx_control[0]);
+}
+
+
+static void mdio_thread(struct work_struct *work)
+{
+	struct port *port = container_of(work, struct port, mdio_thread.work);
+
+	if (mii_check_media(&port->mii, 1, 0))
+		eth_set_duplex(port);
+	schedule_delayed_work(&port->mdio_thread, MDIO_INTERVAL);
+}
+
+
+static inline void debug_pkt(const char *func, u8 *data, int len)
+{
+#if DEBUG_PKT_BYTES
+	int i;
+
+	printk(KERN_DEBUG "%s(%i): ", func, len);
+	for (i = 0; i < len; i++) {
+		if (i >= DEBUG_PKT_BYTES)
+			break;
+		printk("%s%02X",
+		       ((i == 6) || (i == 12) || (i >= 14)) ? " " : "",
+		       data[i]);
+	}
+	printk("\n");
+#endif
+}
+
+
+static inline void debug_desc(unsigned int queue, u32 desc_phys,
+			      struct desc *desc, int is_get)
+{
+#if DEBUG_QUEUES
+	const char *op = is_get ? "->" : "<-";
+
+	if (!desc_phys) {
+		printk(KERN_DEBUG "queue %2i %s NULL\n", queue, op);
+		return;
+	}
+	printk(KERN_DEBUG "queue %2i %s %X: %X %3X %3X %08X %2X < %2X %4X %X"
+	       " %X %X %02X%02X%02X%02X%02X%02X < %02X%02X%02X%02X%02X%02X\n",
+	       queue, op, desc_phys, desc->next, desc->buf_len, desc->pkt_len,
+	       desc->data, desc->dest_id, desc->src_id, desc->flags,
+	       desc->qos, desc->padlen, desc->vlan_tci,
+	       desc->dst_mac_0, desc->dst_mac_1, desc->dst_mac_2,
+	       desc->dst_mac_3, desc->dst_mac_4, desc->dst_mac_5,
+	       desc->src_mac_0, desc->src_mac_1, desc->src_mac_2,
+	       desc->src_mac_3, desc->src_mac_4, desc->src_mac_5);
+#endif
+}
+
+static inline int queue_get_desc(unsigned int queue, struct port *port,
+				 int is_tx)
+{
+	u32 phys, tab_phys, n_desc;
+	struct desc *tab;
+
+	if (!(phys = qmgr_get_entry(queue))) {
+		debug_desc(queue, phys, NULL, 1);
+		return -1;
+	}
+
+	phys &= ~0x1F; /* mask out non-address bits */
+	tab_phys = is_tx ? tx_desc_phys(0) : rx_desc_phys(port, 0);
+	tab = is_tx ? tx_desc_tab : port->rx_desc_tab;
+	n_desc = (phys - tab_phys) / sizeof(struct desc);
+	BUG_ON(n_desc >= PKT_DESCS);
+
+	debug_desc(queue, phys, &tab[n_desc], 1);
+	BUG_ON(tab[n_desc].next);
+	return n_desc;
+}
+
+static inline void queue_put_desc(unsigned int queue, u32 desc_phys,
+				  struct desc *desc)
+{
+	debug_desc(queue, desc_phys, desc, 0);
+	BUG_ON(desc_phys & 0x1F);
+	qmgr_put_entry(queue, desc_phys);
+}
+
+
+static void eth_rx_irq(void *pdev)
+{
+	struct net_device *dev = pdev;
+	struct port *port = netdev_priv(dev);
+
+#if DEBUG_RX
+	printk(KERN_DEBUG "eth_rx_irq() start\n");
+#endif
+	qmgr_disable_irq(port->plat->rxq);
+	netif_rx_schedule(dev);
+}
+
+static int eth_poll(struct net_device *dev, int *budget)
+{
+	struct port *port = netdev_priv(dev);
+	unsigned int rxq = port->plat->rxq, rxfreeq = RXFREE_QUEUE(port->plat);
+	int quota = dev->quota, received = 0;
+
+#if DEBUG_RX
+	printk(KERN_DEBUG "eth_poll() start\n");
+#endif
+
+	while (quota) {
+		struct sk_buff *skb;
+		struct desc *desc;
+		int n;
+#ifdef __ARMEB__
+		struct sk_buff *temp;
+		u32 phys;
+#endif
+
+		if ((n = queue_get_desc(rxq, port, 0)) < 0) {
+			dev->quota -= received;	/* No packet received */
+			*budget -= received;
+			received = 0;
+			netif_rx_complete(dev);
+			qmgr_enable_irq(rxq);
+			if (!qmgr_stat_empty(rxq) &&
+			    netif_rx_reschedule(dev, 0)) {
+				qmgr_disable_irq(rxq);
+				continue;
+			}
+			return 0; /* all work done */
+		}
+
+		desc = &port->rx_desc_tab[n];
+
+#ifdef __ARMEB__
+		if ((skb = netdev_alloc_skb(dev, MAX_MRU)) != NULL) {
+			phys = dma_map_single(&dev->dev, skb->data,
+					      MAX_MRU, DMA_FROM_DEVICE);
+			if (dma_mapping_error(phys)) {
+				dev_kfree_skb(skb);
+				skb = NULL;
+			}
+		}
+#else
+		skb = netdev_alloc_skb(dev, desc->pkt_len);
+#endif
+
+		if (!skb) {
+			port->stat.rx_dropped++;
+			/* put the desc back on RX-ready queue */
+			desc->buf_len = MAX_MRU;
+			desc->pkt_len = 0;
+			queue_put_desc(rxfreeq, rx_desc_phys(port, n), desc);
+			BUG_ON(qmgr_stat_overflow(rxfreeq));
+			continue;
+		}
+
+		/* process received frame */
+#ifdef __ARMEB__
+		temp = skb;
+		skb = port->rx_buff_tab[n];
+		dma_unmap_single(&dev->dev, desc->data,
+				 MAX_MRU, DMA_FROM_DEVICE);
+#else
+		dma_sync_single(&dev->dev, desc->data,
+				MAX_MRU, DMA_FROM_DEVICE);
+		memcpy_swab32((u32 *)skb->data, (u32 *)port->rx_buff_tab[n],
+			      ALIGN(desc->pkt_len, 4) / 4);
+#endif
+		skb_put(skb, desc->pkt_len);
+
+		debug_pkt("eth_poll", skb->data, skb->len);
+
+		skb->protocol = eth_type_trans(skb, dev);
+		dev->last_rx = jiffies;
+		port->stat.rx_packets++;
+		port->stat.rx_bytes += skb->len;
+		netif_receive_skb(skb);
+
+		/* put the new buffer on RX-free queue */
+#ifdef __ARMEB__
+		port->rx_buff_tab[n] = temp;
+		desc->data = phys;
+#endif
+		desc->buf_len = MAX_MRU;
+		desc->pkt_len = 0;
+		queue_put_desc(rxfreeq, rx_desc_phys(port, n), desc);
+		BUG_ON(qmgr_stat_overflow(rxfreeq));
+		quota--;
+		received++;
+	}
+	dev->quota -= received;
+	*budget -= received;
+	return 1;		/* not all work done */
+}
+
+static void eth_xmit_ready_irq(void *pdev)
+{
+#if DEBUG_TX
+	printk(KERN_DEBUG "eth_xmit_ready_irq()\n");
+#endif
+	netif_start_queue((struct net_device *)pdev);
+}
+
+static int eth_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct desc *desc;
+	void *buff;
+	int n;
+
+#if DEBUG_TX
+	printk(KERN_DEBUG "eth_xmit() start\n");
+#endif
+	if (unlikely(skb->len > MAX_MRU)) {
+		dev_kfree_skb(skb);
+		port->stat.tx_errors++;
+		return NETDEV_TX_OK;
+	}
+
+	n = queue_get_desc(TXDONE_QUEUE, port, 1);
+	BUG_ON(n < 0);
+	desc = &tx_desc_tab[n];
+
+	if ((buff = tx_buff_tab[n]) != NULL) {
+		dma_unmap_single(tx_owner_tab[n], desc->data,
+				 desc->buf_len, DMA_TO_DEVICE);
+#ifdef __ARMEB__
+		dev_kfree_skb(buff);
+#else
+		kfree(buff);
+#endif
+	}
+
+	/* disable VLAN functions in NPE image for now */
+	memset(desc, 0, sizeof(*desc));
+	desc->buf_len = desc->pkt_len = skb->len;
+#ifdef __ARMEB__
+	buff = skb;
+	desc->data = dma_map_single(&dev->dev, skb->data,
+				    skb->len, DMA_TO_DEVICE);
+#else
+	if ((buff = kmalloc(ALIGN(skb->len, 4), GFP_ATOMIC)) != NULL) {
+		/* buff must be dword - aligned */
+		memcpy_swab32(buff, (u32 *)skb->data, ALIGN(skb->len, 4) / 4);
+		desc->data = dma_map_single(&dev->dev, buff,
+					    ALIGN(skb->len, 4), DMA_TO_DEVICE);
+	}
+	dev_kfree_skb(skb);
+#endif
+
+	if (!buff || dma_mapping_error(desc->data)) {
+#ifdef __ARMEB__
+		dev_kfree_skb(buff);
+#else
+		kfree(buff);
+#endif
+		desc->data = 0;
+		tx_buff_tab[n] = NULL;
+		port->stat.tx_dropped++;
+		/* put the desc back on TX-done queue */
+		queue_put_desc(TXDONE_QUEUE, tx_desc_phys(n), desc);
+		return NETDEV_TX_OK;
+	}
+
+	tx_buff_tab[n] = buff;
+	tx_owner_tab[n] = &dev->dev;
+
+#ifdef __ARMEB__
+	debug_pkt("eth_xmit", skb->data, desc->pkt_len);
+#else
+	debug_pkt("eth_xmit", buff, desc->pkt_len);
+#endif
+	/* NPE firmware pads short frames with zeros internally */
+	wmb();
+	queue_put_desc(TX_QUEUE(port->plat), tx_desc_phys(n), desc);
+	BUG_ON(qmgr_stat_overflow(TX_QUEUE(port->plat)));
+	dev->trans_start = jiffies;
+	port->stat.tx_packets++;
+	port->stat.tx_bytes += desc->pkt_len;
+
+	if (qmgr_stat_full(TX_QUEUE(port->plat))) {
+		netif_stop_queue(dev);
+		/* we could miss TX ready interrupt */
+		if (!qmgr_stat_full(TX_QUEUE(port->plat)))
+			netif_start_queue(dev);
+	}
+
+#if DEBUG_TX
+	printk(KERN_DEBUG "eth_xmit() end\n");
+#endif
+	return NETDEV_TX_OK;
+}
+
+
+static struct net_device_stats *eth_stats(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	return &port->stat;
+}
+
+static void eth_set_mcast_list(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct dev_mc_list *mclist = dev->mc_list;
+	u8 diffs[ETH_ALEN], *addr;
+	int cnt = dev->mc_count, i;
+
+	if ((dev->flags & IFF_PROMISC) || !mclist || !cnt) {
+		__raw_writel(DEFAULT_RX_CNTRL0 & ~RX_CNTRL0_ADDR_FLTR_EN,
+			     &port->regs->rx_control[0]);
+		return;
+	}
+
+	memset(diffs, 0, ETH_ALEN);
+	addr = mclist->dmi_addr; /* first MAC address */
+
+	while (--cnt && (mclist = mclist->next))
+		for (i = 0; i < ETH_ALEN; i++)
+			diffs[i] |= addr[i] ^ mclist->dmi_addr[i];
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		__raw_writel(addr[i], &port->regs->mcast_addr[i]);
+		__raw_writel(~diffs[i], &port->regs->mcast_mask[i]);
+	}
+
+	__raw_writel(DEFAULT_RX_CNTRL0 | RX_CNTRL0_ADDR_FLTR_EN,
+		     &port->regs->rx_control[0]);
+}
+
+
+static int eth_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+	struct port *port = netdev_priv(dev);
+	unsigned int duplex_chg;
+	int err;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+	err = generic_mii_ioctl(&port->mii, if_mii(req), cmd, &duplex_chg);
+	if (duplex_chg)
+		eth_set_duplex(port);
+	return err;
+}
+
+
+static int request_queues(struct port *port)
+{
+	int err;
+
+	err = qmgr_request_queue(RXFREE_QUEUE(port->plat), PKT_DESCS, 0, 0);
+	if (err)
+		return err;
+
+	err = qmgr_request_queue(port->plat->rxq, PKT_DESCS, 0, 0);
+	if (err)
+		goto rel_rxfree;
+
+	err = qmgr_request_queue(TX_QUEUE(port->plat), TX_QUEUE_LEN, 0, 0);
+	if (err)
+		goto rel_rx;
+
+	/* TX-done queue handles skbs sent out by the NPEs */
+	if (!ports_open) {
+		err = qmgr_request_queue(TXDONE_QUEUE, PKT_DESCS, 0, 0);
+		if (err)
+			goto rel_tx;
+	}
+	return 0;
+
+rel_tx:
+	qmgr_release_queue(TX_QUEUE(port->plat));
+rel_rx:
+	qmgr_release_queue(port->plat->rxq);
+rel_rxfree:
+	qmgr_release_queue(RXFREE_QUEUE(port->plat));
+	return err;
+}
+
+static void release_queues(struct port *port)
+{
+	qmgr_release_queue(RXFREE_QUEUE(port->plat));
+	qmgr_release_queue(port->plat->rxq);
+	qmgr_release_queue(TX_QUEUE(port->plat));
+
+	if (!ports_open)
+		qmgr_release_queue(TXDONE_QUEUE);
+}
+
+static int init_queues(struct port *port)
+{
+	int i;
+
+	if (!ports_open) {
+		/* Setup TX descriptors - common to all ports */
+		if (!(dma_pool = dma_pool_create(DRV_NAME, NULL,
+						 POOL_ALLOC_SIZE, 32, 0)))
+			return -ENOMEM;
+
+		if (!(tx_desc_tab = dma_pool_alloc(dma_pool, GFP_KERNEL,
+						   &tx_desc_tab_phys)))
+			return -ENOMEM;
+		memset(tx_desc_tab, 0, POOL_ALLOC_SIZE);
+		memset(tx_buff_tab, 0, sizeof(tx_buff_tab)); /* static table */
+	}
+
+	/* Setup RX buffers */
+	if (!(port->rx_desc_tab = dma_pool_alloc(dma_pool, GFP_KERNEL,
+						 &port->rx_desc_tab_phys)))
+		return -ENOMEM;
+	memset(port->rx_desc_tab, 0, POOL_ALLOC_SIZE);
+	memset(port->rx_buff_tab, 0, sizeof(port->rx_buff_tab)); /* table */
+
+	for (i = 0; i < PKT_DESCS; i++) {
+		struct desc *desc = &port->rx_desc_tab[i];
+		void *data;
+#ifdef __ARMEB__
+		struct sk_buff *skb;
+
+		if (!(skb = netdev_alloc_skb(port->netdev, MAX_MRU)))
+			return -ENOMEM;
+		port->rx_buff_tab[i] = skb;
+		data = skb->data;
+#else
+		if (!(data = kmalloc(MAX_MRU, GFP_KERNEL)))
+			return -ENOMEM;
+		port->rx_buff_tab[i] = data;
+#endif
+		desc->buf_len = MAX_MRU;
+		desc->data = dma_map_single(&port->netdev->dev, data,
+					    MAX_MRU, DMA_FROM_DEVICE);
+		if (dma_mapping_error(desc->data)) {
+			desc->data = 0;
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+static void destroy_queues(struct port *port)
+{
+	int i;
+
+	if (port->rx_desc_tab) {
+		for (i = 0; i < PKT_DESCS; i++) {
+			struct desc *desc = &port->rx_desc_tab[i];
+			void *buff = port->rx_buff_tab[i]; /* may be skb */
+			if (buff) {
+				if (desc->data)
+					dma_unmap_single(&port->netdev->dev,
+							 desc->data, MAX_MRU,
+							 DMA_FROM_DEVICE);
+#ifdef __ARMEB__
+				dev_kfree_skb(buff);
+#else
+				kfree(buff);
+#endif
+			}
+		}
+		dma_pool_free(dma_pool, port->rx_desc_tab,
+			      port->rx_desc_tab_phys);
+		port->rx_desc_tab = NULL;
+	}
+
+	if (!ports_open && tx_desc_tab) {
+		for (i = 0; i < PKT_DESCS; i++) {
+			struct desc *desc = &tx_desc_tab[i];
+			void *buff = tx_buff_tab[i]; /* may be skb */
+			if (buff) {
+				if (desc->data)
+					dma_unmap_single(&port->netdev->dev,
+							 desc->data,
+							 desc->buf_len,
+							 DMA_TO_DEVICE);
+#ifdef __ARMEB__
+				dev_kfree_skb(buff);
+#else
+				kfree(buff);
+#endif
+			}
+		}
+		dma_pool_free(dma_pool, tx_desc_tab, tx_desc_tab_phys);
+		tx_desc_tab = NULL;
+	}
+	if (!ports_open && dma_pool) {
+		dma_pool_destroy(dma_pool);
+		dma_pool = NULL;
+	}
+}
+
+static int eth_open(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct npe *npe = port->npe;
+	struct msg msg;
+	int i, err;
+
+	if (!npe_running(npe)) {
+		err = npe_load_firmware(npe, npe_name(npe), &dev->dev);
+		if (err)
+			return err;
+
+		if (npe_recv_message(npe, &msg, "ETH_GET_STATUS")) {
+			printk(KERN_ERR "%s: %s not responding\n", dev->name,
+			       npe_name(npe));
+			return -EIO;
+		}
+	}
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = NPE_VLAN_SETRXQOSENTRY;
+	msg.eth_id = port->id;
+	msg.byte5 = port->plat->rxq | 0x80;
+	msg.byte7 = port->plat->rxq << 4;
+	for (i = 0; i < 8; i++) {
+		msg.byte3 = i;
+		if (npe_send_recv_message(port->npe, &msg, "ETH_SET_RXQ"))
+			return -EIO;
+	}
+
+	msg.cmd = NPE_EDB_SETPORTADDRESS;
+	msg.eth_id = PHYSICAL_ID(port);
+	msg.byte2 = dev->dev_addr[0];
+	msg.byte3 = dev->dev_addr[1];
+	msg.byte4 = dev->dev_addr[2];
+	msg.byte5 = dev->dev_addr[3];
+	msg.byte6 = dev->dev_addr[4];
+	msg.byte7 = dev->dev_addr[5];
+	if (npe_send_recv_message(port->npe, &msg, "ETH_SET_MAC"))
+		return -EIO;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = NPE_FW_SETFIREWALLMODE;
+	msg.eth_id = port->id;
+	if (npe_send_recv_message(port->npe, &msg, "ETH_SET_FIREWALL_MODE"))
+		return -EIO;
+
+	if ((err = request_queues(port)) != 0)
+		return err;
+
+	if ((err = init_queues(port)) != 0) {
+		destroy_queues(port);
+		release_queues(port);
+		return err;
+	}
+
+	for (i = 0; i < ETH_ALEN; i++)
+		__raw_writel(dev->dev_addr[i], &port->regs->hw_addr[i]);
+	__raw_writel(0x08, &port->regs->random_seed);
+	__raw_writel(0x12, &port->regs->partial_empty_threshold);
+	__raw_writel(0x30, &port->regs->partial_full_threshold);
+	__raw_writel(0x08, &port->regs->tx_start_bytes);
+	__raw_writel(0x15, &port->regs->tx_deferral);
+	__raw_writel(0x08, &port->regs->tx_2part_deferral[0]);
+	__raw_writel(0x07, &port->regs->tx_2part_deferral[1]);
+	__raw_writel(0x80, &port->regs->slot_time);
+	__raw_writel(0x01, &port->regs->int_clock_threshold);
+
+	/* Populate queues with buffers, no failure after this point */
+	if (!ports_open)
+		for (i = 0; i < PKT_DESCS; i++) {
+			queue_put_desc(TXDONE_QUEUE, tx_desc_phys(i),
+				       &tx_desc_tab[i]);
+			BUG_ON(qmgr_stat_overflow(TXDONE_QUEUE));
+		}
+
+	for (i = 0; i < PKT_DESCS; i++) {
+		queue_put_desc(RXFREE_QUEUE(port->plat),
+			       rx_desc_phys(port, i), &port->rx_desc_tab[i]);
+		BUG_ON(qmgr_stat_overflow(RXFREE_QUEUE(port->plat)));
+	}
+
+	__raw_writel(TX_CNTRL1_RETRIES, &port->regs->tx_control[1]);
+	__raw_writel(DEFAULT_TX_CNTRL0, &port->regs->tx_control[0]);
+	__raw_writel(0, &port->regs->rx_control[1]);
+	__raw_writel(DEFAULT_RX_CNTRL0, &port->regs->rx_control[0]);
+
+	if (mii_check_media(&port->mii, 1, 1))
+		eth_set_duplex(port);
+	eth_set_mcast_list(dev);
+	netif_start_queue(dev);
+	schedule_delayed_work(&port->mdio_thread, MDIO_INTERVAL);
+
+	qmgr_set_irq(port->plat->rxq, QUEUE_IRQ_SRC_NOT_EMPTY,
+		     eth_rx_irq, dev);
+	qmgr_set_irq(TX_QUEUE(port->plat), QUEUE_IRQ_SRC_NOT_FULL,
+		     eth_xmit_ready_irq, dev);
+	qmgr_enable_irq(TX_QUEUE(port->plat));
+	ports_open++;
+	netif_rx_schedule(dev);
+	return 0;
+}
+
+static int eth_close(struct net_device *dev)
+{
+	struct port *port = netdev_priv(dev);
+	struct msg msg;
+	int buffs = PKT_DESCS; /* allocated RX buffers */
+	int i;
+
+	ports_open--;
+	qmgr_disable_irq(port->plat->rxq);
+	qmgr_disable_irq(TX_QUEUE(port->plat));
+	netif_stop_queue(dev);
+
+	while (queue_get_desc(RXFREE_QUEUE(port->plat), port, 0) >= 0)
+		buffs--;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = NPE_SETLOOPBACK_MODE;
+	msg.eth_id = port->id;
+	msg.byte3 = 1;
+	if (npe_send_recv_message(port->npe, &msg, "ETH_ENABLE_LOOPBACK"))
+		printk(KERN_CRIT "%s: unable to enable loopback\n", dev->name);
+
+	i = 0;
+	do {			/* drain RX buffers */
+		while (queue_get_desc(port->plat->rxq, port, 0) >= 0)
+			buffs--;
+		if (!buffs)
+			break;
+		if (qmgr_stat_empty(TX_QUEUE(port->plat))) {
+			/* we have to inject some packet */
+			int n = queue_get_desc(TXDONE_QUEUE, port, 1);
+			struct desc *desc;
+			u32 phys;
+
+			BUG_ON(n < 0);
+			desc = &tx_desc_tab[n];
+			phys = tx_desc_phys(n);
+			desc->buf_len = desc->pkt_len = 1;
+			wmb();
+			queue_put_desc(TX_QUEUE(port->plat), phys, desc);
+			BUG_ON(qmgr_stat_overflow(TX_QUEUE(port->plat)));
+		}
+		udelay(1);
+	} while (++i < MAX_CLOSE_WAIT);
+
+	if (buffs)
+		printk(KERN_CRIT "%s: unable to drain RX queue, %i buffer(s)"
+		       " left in NPE\n", dev->name, buffs);
+#if DEBUG_CLOSE
+	if (!buffs)
+		printk(KERN_DEBUG "Draining RX queue took %i cycles\n", i);
+#endif
+
+	msg.byte3 = 0;
+	if (npe_send_recv_message(port->npe, &msg, "ETH_DISABLE_LOOPBACK"))
+		printk(KERN_CRIT "%s: unable to disable loopback\n",
+		       dev->name);
+
+	if (ports_open) {
+		while ((i = queue_get_desc(TX_QUEUE(port->plat),
+					   port, 1)) >= 0) {
+			queue_put_desc(TXDONE_QUEUE, tx_desc_phys(i),
+				       &tx_desc_tab[i]);
+			BUG_ON(qmgr_stat_overflow(TXDONE_QUEUE));
+		}
+	} else {
+		buffs = PKT_DESCS;
+		i = 0;
+		while (queue_get_desc(TX_QUEUE(port->plat), port, 1) >= 0)
+			buffs--; /* cancel TX */
+		do {
+			while (queue_get_desc(TXDONE_QUEUE, port, 1) >= 0)
+				buffs--;
+			if (!buffs)
+				break;
+		} while (++i < MAX_CLOSE_WAIT);
+		
+		if (buffs)
+			printk(KERN_CRIT "%s: unable to drain TX queue, %i"
+			       " buffer(s) left in NPE\n", dev->name, buffs);
+#if DEBUG_CLOSE
+		if (!buffs)
+			printk(KERN_DEBUG "Draining TX queues took %i "
+			       "cycles\n", i);
+#endif
+	}
+
+	cancel_rearming_delayed_work(&port->mdio_thread);
+	destroy_queues(port);
+	release_queues(port);
+	return 0;
+}
+
+static int __devinit eth_init_one(struct platform_device *pdev)
+{
+	struct port *port;
+	struct net_device *dev;
+	struct mac_plat_info *plat = pdev->dev.platform_data;
+	u32 regs_phys;
+	int err;
+
+	if (!(dev = alloc_etherdev(sizeof(struct port))))
+		return -ENOMEM;
+
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	port = netdev_priv(dev);
+	port->netdev = dev;
+	port->id = pdev->id;
+
+	switch (port->id) {
+	case IXP4XX_ETH_NPEA:
+		port->regs = (struct eth_regs __iomem *)IXP4XX_EthA_BASE_VIRT;
+		regs_phys  = IXP4XX_EthA_BASE_PHYS;
+		break;
+	case IXP4XX_ETH_NPEB:
+		port->regs = (struct eth_regs __iomem *)IXP4XX_EthB_BASE_VIRT;
+		regs_phys  = IXP4XX_EthB_BASE_PHYS;
+		break;
+	case IXP4XX_ETH_NPEC:
+		port->regs = (struct eth_regs __iomem *)IXP4XX_EthC_BASE_VIRT;
+		regs_phys  = IXP4XX_EthC_BASE_PHYS;
+		break;
+	default:
+		err = -ENOSYS;
+		goto err_free;
+	}
+
+	dev->open = eth_open;
+	dev->hard_start_xmit = eth_xmit;
+	dev->poll = eth_poll;
+	dev->stop = eth_close;
+	dev->get_stats = eth_stats;
+	dev->do_ioctl = eth_ioctl;
+	dev->set_multicast_list = eth_set_mcast_list;
+	dev->weight = 16;
+	dev->tx_queue_len = 100;
+
+	if (!(port->npe = npe_request(NPE_ID(port)))) {
+		err = -EIO;
+		goto err_free;
+	}
+
+	if (register_netdev(dev)) {
+		err = -EIO;
+		goto err_npe_rel;
+	}
+
+	port->mem_res = request_mem_region(regs_phys, REGS_SIZE, dev->name);
+	if (!port->mem_res) {
+		err = -EBUSY;
+		goto err_unreg;
+	}
+
+	port->plat = plat;
+	memcpy(dev->dev_addr, plat->hwaddr, ETH_ALEN);
+
+	platform_set_drvdata(pdev, dev);
+
+	__raw_writel(DEFAULT_CORE_CNTRL | CORE_RESET,
+		     &port->regs->core_control);
+	udelay(50);
+	__raw_writel(DEFAULT_CORE_CNTRL, &port->regs->core_control);
+	udelay(50);
+
+	port->mii.dev = dev;
+	port->mii.mdio_read = mdio_read;
+	port->mii.mdio_write = mdio_write;
+	port->mii.phy_id = plat->phy;
+	port->mii.phy_id_mask = 0x1F;
+	port->mii.reg_num_mask = 0x1F;
+
+	INIT_DELAYED_WORK(&port->mdio_thread, mdio_thread);
+
+	printk(KERN_INFO "%s: MII PHY %i on %s\n", dev->name, plat->phy,
+	       npe_name(port->npe));
+	return 0;
+
+err_unreg:
+	unregister_netdev(dev);
+err_npe_rel:
+	npe_release(port->npe);
+err_free:
+	free_netdev(dev);
+	return err;
+}
+
+static int __devexit eth_remove_one(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct port *port = netdev_priv(dev);
+
+	unregister_netdev(dev);
+	platform_set_drvdata(pdev, NULL);
+	npe_release(port->npe);
+	release_resource(port->mem_res);
+	free_netdev(dev);
+	return 0;
+}
+
+static struct platform_driver drv = {
+	.driver.name	= DRV_NAME,
+	.probe		= eth_init_one,
+	.remove		= eth_remove_one,
+};
+
+static int __init eth_init_module(void)
+{
+	if (!(ixp4xx_read_fuses() & IXP4XX_FUSE_NPEB_ETH0))
+		return -ENOSYS;
+
+	/* All MII PHY accesses use NPE-B Ethernet registers */
+	spin_lock_init(&mdio_lock);
+	mdio_regs = (struct eth_regs __iomem *)IXP4XX_EthB_BASE_VIRT;
+	__raw_writel(DEFAULT_CORE_CNTRL, &mdio_regs->core_control);
+
+	return platform_driver_register(&drv);
+}
+
+static void __exit eth_cleanup_module(void)
+{
+	platform_driver_unregister(&drv);
+}
+
+MODULE_AUTHOR("Krzysztof Halasa");
+MODULE_DESCRIPTION("Intel IXP4xx Ethernet driver");
+MODULE_LICENSE("GPL v2");
+module_init(eth_init_module);
+module_exit(eth_cleanup_module);
--- linux-2.6.22.18/drivers/net/via-velocity.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/net/via-velocity.c	2008-07-09 15:14:37.000000000 +0200
@@ -96,11 +96,31 @@ MODULE_AUTHOR("VIA Networking Technologi
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VIA Networking Velocity Family Gigabit Ethernet Adapter Driver");
 
+/* Valid values for vdebug (additive, this is a bitmask):
+ *  0x00 => off
+ *  0x01 => always on
+ *  0x02 => additional detail on tx (rx, too, if anyone implements same)
+ *  0x04 => detail the initialization process
+ *  0x08 => spot debug detail; to be used as developers see fit
+ */
+static int vdebug = 0;
+
+/* HAIL - these macros are for the normal 0x01-type tracing... */
+#define HAIL(S) \
+	if (vdebug&1) printk(KERN_NOTICE "%s\n", (S));
+#define HAILS(S,T) \
+	if (vdebug&1) printk(KERN_NOTICE "%s -> status=0x%x\n", (S), (T));
+
 #define VELOCITY_PARAM(N,D) \
         static int N[MAX_UNITS]=OPTION_DEFAULT;\
 	module_param_array(N, int, NULL, 0); \
         MODULE_PARM_DESC(N, D);
 
+#define VELO_DEBUG_MIN   0
+#define VELO_DEBUG_MAX   255
+#define VELO_DEBUG_DEF   0
+VELOCITY_PARAM(velo_debug, "Debug level");
+
 #define RX_DESC_MIN     64
 #define RX_DESC_MAX     255
 #define RX_DESC_DEF     64
@@ -385,12 +405,12 @@ static void __devinit velocity_set_int_o
 	if (val == -1)
 		*opt = def;
 	else if (val < min || val > max) {
-		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (%d-%d)\n",
-					devname, name, min, max);
+		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_NOTICE "via-velocity: the value of parameter %s is invalid, the valid range is (%d-%d)\n",
+					name, min, max);
 		*opt = def;
 	} else {
-		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: set value of parameter %s to %d\n",
-					devname, name, val);
+		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_INFO "via-velocity: set value of parameter %s to %d\n",
+					name, val);
 		*opt = val;
 	}
 }
@@ -415,12 +435,12 @@ static void __devinit velocity_set_bool_
 	if (val == -1)
 		*opt |= (def ? flag : 0);
 	else if (val < 0 || val > 1) {
-		printk(KERN_NOTICE "%s: the value of parameter %s is invalid, the valid range is (0-1)\n",
-			devname, name);
+		printk(KERN_NOTICE "via-velocity: the value of parameter %s is invalid, the valid range is (0-1)\n",
+			name);
 		*opt |= (def ? flag : 0);
 	} else {
-		printk(KERN_INFO "%s: set parameter %s to %s\n",
-			devname, name, val ? "TRUE" : "FALSE");
+		printk(KERN_INFO "via-velocity: set parameter %s to %s\n",
+			name, val ? "TRUE" : "FALSE");
 		*opt |= (val ? flag : 0);
 	}
 }
@@ -438,6 +458,7 @@ static void __devinit velocity_set_bool_
 static void __devinit velocity_get_options(struct velocity_opt *opts, int index, char *devname)
 {
 
+	velocity_set_int_opt(&opts->velo_debug, velo_debug[index], VELO_DEBUG_MIN, VELO_DEBUG_MAX, VELO_DEBUG_DEF, "velo_debug", devname);
 	velocity_set_int_opt(&opts->rx_thresh, rx_thresh[index], RX_THRESH_MIN, RX_THRESH_MAX, RX_THRESH_DEF, "rx_thresh", devname);
 	velocity_set_int_opt(&opts->DMA_length, DMA_length[index], DMA_LENGTH_MIN, DMA_LENGTH_MAX, DMA_LENGTH_DEF, "DMA_length", devname);
 	velocity_set_int_opt(&opts->numrx, RxDescriptors[index], RX_DESC_MIN, RX_DESC_MAX, RX_DESC_DEF, "RxDescriptors", devname);
@@ -452,6 +473,7 @@ static void __devinit velocity_get_optio
 	velocity_set_int_opt((int *) &opts->wol_opts, wol_opts[index], WOL_OPT_MIN, WOL_OPT_MAX, WOL_OPT_DEF, "Wake On Lan options", devname);
 	velocity_set_int_opt((int *) &opts->int_works, int_works[index], INT_WORKS_MIN, INT_WORKS_MAX, INT_WORKS_DEF, "Interrupt service works", devname);
 	opts->numrx = (opts->numrx & ~3);
+	vdebug = opts->velo_debug;
 }
 
 /**
@@ -466,6 +488,8 @@ static void velocity_init_cam_filter(str
 {
 	struct mac_regs __iomem * regs = vptr->mac_regs;
 
+	HAIL("velocity_init_cam_filter");
+
 	/* Turn on MCFG_PQEN, turn off MCFG_RTGOPT */
 	WORD_REG_BITS_SET(MCFG_PQEN, MCFG_RTGOPT, &regs->MCFG);
 	WORD_REG_BITS_ON(MCFG_VIDFR, &regs->MCFG);
@@ -484,14 +508,12 @@ static void velocity_init_cam_filter(str
 			WORD_REG_BITS_ON(MCFG_RTGOPT, &regs->MCFG);
 
 		mac_set_cam(regs, 0, (u8 *) & (vptr->options.vid), VELOCITY_VLAN_ID_CAM);
-		vptr->vCAMmask[0] |= 1;
-		mac_set_cam_mask(regs, vptr->vCAMmask, VELOCITY_VLAN_ID_CAM);
 	} else {
 		u16 temp = 0;
 		mac_set_cam(regs, 0, (u8 *) &temp, VELOCITY_VLAN_ID_CAM);
-		temp = 1;
-		mac_set_cam_mask(regs, (u8 *) &temp, VELOCITY_VLAN_ID_CAM);
 	}
+	vptr->vCAMmask[0] |= 1;
+	mac_set_cam_mask(regs, vptr->vCAMmask, VELOCITY_VLAN_ID_CAM);
 }
 
 /**
@@ -508,13 +530,15 @@ static void velocity_rx_reset(struct vel
 	struct mac_regs __iomem * regs = vptr->mac_regs;
 	int i;
 
+	HAIL("velocity_rx_reset");
 	vptr->rd_dirty = vptr->rd_filled = vptr->rd_curr = 0;
 
 	/*
 	 *	Init state, all RD entries belong to the NIC
 	 */
 	for (i = 0; i < vptr->options.numrx; ++i)
-		vptr->rd_ring[i].rdesc0.owner = OWNED_BY_NIC;
+		/* vptr->rd_ring[i].rdesc0.owner = OWNED_BY_NIC; BE */
+		vptr->rd_ring[i].rdesc0 |= cpu_to_le32(BE_OWNED_BY_NIC); /* BE */
 
 	writew(vptr->options.numrx, &regs->RBRDU);
 	writel(vptr->rd_pool_dma, &regs->RDBaseLo);
@@ -537,12 +561,15 @@ static void velocity_init_registers(stru
 	struct mac_regs __iomem * regs = vptr->mac_regs;
 	int i, mii_status;
 
+	if (vdebug&5) printk(KERN_NOTICE "velocity_init_registers: entering\n");
+
 	mac_wol_reset(regs);
 
 	switch (type) {
 	case VELOCITY_INIT_RESET:
 	case VELOCITY_INIT_WOL:
 
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: RESET or WOL\n");
 		netif_stop_queue(vptr->dev);
 
 		/*
@@ -570,12 +597,13 @@ static void velocity_init_registers(stru
 
 	case VELOCITY_INIT_COLD:
 	default:
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: COLD or default\n");
 		/*
 		 *	Do reset
 		 */
 		velocity_soft_reset(vptr);
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: soft reset complete.\n");
 		mdelay(5);
-
 		mac_eeprom_reload(regs);
 		for (i = 0; i < 6; i++) {
 			writeb(vptr->dev->dev_addr[i], &(regs->PAR[i]));
@@ -593,11 +621,16 @@ static void velocity_init_registers(stru
 		 */
 		BYTE_REG_BITS_SET(CFGB_OFSET, (CFGB_CRANDOM | CFGB_CAP | CFGB_MBA | CFGB_BAKOPT), &regs->CFGB);
 
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: Initializing CAM filter\n");
 		/*
 		 *	Init CAM filter
 		 */
+		if (vdebug&8) printk(KERN_NOTICE "velocity: spot debug: about to init CAM filters\n");
+		mdelay(5);  /* MJW - ARM processors, kernel 2.6.19 - this fixes oopses and hangs */
 		velocity_init_cam_filter(vptr);
+		if (vdebug&8) printk(KERN_NOTICE "velocity: spot debug: init CAM filters complete\n");
 
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: Setting packet filter\n");
 		/*
 		 *	Set packet filter: Receive directed and broadcast address
 		 */
@@ -607,10 +640,12 @@ static void velocity_init_registers(stru
 		 *	Enable MII auto-polling
 		 */
 		enable_mii_autopoll(regs);
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: enable_mii_autopoll complete.\n");
 
 		vptr->int_mask = INT_MASK_DEF;
 
-		writel(cpu_to_le32(vptr->rd_pool_dma), &regs->RDBaseLo);
+		/* writel(cpu_to_le32(vptr->rd_pool_dma), &regs->RDBaseLo); BE */
+		writel((vptr->rd_pool_dma), &regs->RDBaseLo); /* BE */
 		writew(vptr->options.numrx - 1, &regs->RDCSize);
 		mac_rx_queue_run(regs);
 		mac_rx_queue_wake(regs);
@@ -618,10 +653,13 @@ static void velocity_init_registers(stru
 		writew(vptr->options.numtx - 1, &regs->TDCSize);
 
 		for (i = 0; i < vptr->num_txq; i++) {
-			writel(cpu_to_le32(vptr->td_pool_dma[i]), &(regs->TDBaseLo[i]));
+			/* writel(cpu_to_le32(vptr->td_pool_dma[i]), &(regs->TDBaseLo[i])); BE */
+			writel((vptr->td_pool_dma[i]), &(regs->TDBaseLo[i])); /* BE */
 			mac_tx_queue_run(regs, i);
 		}
 
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: DMA settings complete.\n");
+
 		init_flow_control_register(vptr);
 
 		writel(CR0_STOP, &regs->CR0Clr);
@@ -640,8 +678,10 @@ static void velocity_init_registers(stru
 
 		enable_flow_control_ability(vptr);
 		mac_hw_mibs_init(regs);
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: Set interrupt mask\n");
 		mac_write_int_mask(vptr->int_mask, regs);
 		mac_clear_isr(regs);
+		if (vdebug&4) printk(KERN_NOTICE "velocity_init_registers: complete.\n");
 
 	}
 }
@@ -659,6 +699,7 @@ static int velocity_soft_reset(struct ve
 	struct mac_regs __iomem * regs = vptr->mac_regs;
 	int i = 0;
 
+	HAIL("velocity_soft_reset");
 	writel(CR0_SFRST, &regs->CR0Set);
 
 	for (i = 0; i < W_MAX_TIMEOUT; i++) {
@@ -722,6 +763,7 @@ static int __devinit velocity_found1(str
 			VELOCITY_FULL_DRV_NAM, VELOCITY_VERSION);
 		printk(KERN_INFO "Copyright (c) 2002, 2003 VIA Networking Technologies, Inc.\n");
 		printk(KERN_INFO "Copyright (c) 2004 Red Hat Inc.\n");
+		printk(KERN_INFO "BE support, misc. fixes MJW 01Jan2007 - may be unstable\n");
 		first = 0;
 	}
 
@@ -935,6 +977,7 @@ static int velocity_init_rings(struct ve
 	dma_addr_t pool_dma;
 	u8 *pool;
 
+	HAIL("velocity_init_rings");
 	/*
 	 *	Allocate all RD/TD rings a single pool
 	 */
@@ -997,6 +1040,7 @@ static int velocity_init_rings(struct ve
 static void velocity_free_rings(struct velocity_info *vptr)
 {
 	int size;
+	HAIL("velocity_free_rings");
 
 	size = vptr->options.numrx * sizeof(struct rx_desc) +
 	       vptr->options.numtx * sizeof(struct tx_desc) * vptr->num_txq;
@@ -1013,6 +1057,7 @@ static inline void velocity_give_many_rx
 	struct mac_regs __iomem *regs = vptr->mac_regs;
 	int avail, dirty, unusable;
 
+	HAIL("velocity_give_many_rx_descs");
 	/*
 	 * RD number must be equal to 4X per hardware spec
 	 * (programming guide rev 1.20, p.13)
@@ -1026,7 +1071,8 @@ static inline void velocity_give_many_rx
 	dirty = vptr->rd_dirty - unusable;
 	for (avail = vptr->rd_filled & 0xfffc; avail; avail--) {
 		dirty = (dirty > 0) ? dirty - 1 : vptr->options.numrx - 1;
-		vptr->rd_ring[dirty].rdesc0.owner = OWNED_BY_NIC;
+		/* vptr->rd_ring[dirty].rdesc0.owner = OWNED_BY_NIC; BE */
+		vptr->rd_ring[dirty].rdesc0 |= cpu_to_le32(BE_OWNED_BY_NIC); /* BE */
 	}
 
 	writew(vptr->rd_filled & 0xfffc, &regs->RBRDU);
@@ -1036,12 +1082,14 @@ static inline void velocity_give_many_rx
 static int velocity_rx_refill(struct velocity_info *vptr)
 {
 	int dirty = vptr->rd_dirty, done = 0, ret = 0;
+	HAIL("velocity_rx_refill");
 
 	do {
 		struct rx_desc *rd = vptr->rd_ring + dirty;
 
 		/* Fine for an all zero Rx desc at init time as well */
-		if (rd->rdesc0.owner == OWNED_BY_NIC)
+		/* if (rd->rdesc0.owner == OWNED_BY_NIC) BE */
+		if (rd->rdesc0 & cpu_to_le32(BE_OWNED_BY_NIC)) /* BE */
 			break;
 
 		if (!vptr->rd_info[dirty].skb) {
@@ -1076,6 +1124,7 @@ static int velocity_init_rd_ring(struct 
 	unsigned int rsize = sizeof(struct velocity_rd_info) *
 					vptr->options.numrx;
 
+	HAIL("velocity_init_rd_ring");
 	vptr->rd_info = kmalloc(rsize, GFP_KERNEL);
 	if(vptr->rd_info == NULL)
 		goto out;
@@ -1105,6 +1154,7 @@ static void velocity_free_rd_ring(struct
 {
 	int i;
 
+	HAIL("velocity_free_rd_ring");
 	if (vptr->rd_info == NULL)
 		return;
 
@@ -1146,6 +1196,7 @@ static int velocity_init_td_ring(struct 
 	unsigned int tsize = sizeof(struct velocity_td_info) *
 					vptr->options.numtx;
 
+	HAIL("velocity_init_td_ring");
 	/* Init the TD ring entries */
 	for (j = 0; j < vptr->num_txq; j++) {
 		curr = vptr->td_pool_dma[j];
@@ -1182,6 +1233,7 @@ static void velocity_free_td_ring_entry(
 	struct velocity_td_info * td_info = &(vptr->td_infos[q][n]);
 	int i;
 
+	HAIL("velocity_free_td_ring_entry");
 	if (td_info == NULL)
 		return;
 
@@ -1211,6 +1263,7 @@ static void velocity_free_td_ring(struct
 {
 	int i, j;
 
+	HAIL("velocity_free_td_ring");
 	for (j = 0; j < vptr->num_txq; j++) {
 		if (vptr->td_infos[j] == NULL)
 			continue;
@@ -1238,34 +1291,42 @@ static int velocity_rx_srv(struct veloci
 	struct net_device_stats *stats = &vptr->stats;
 	int rd_curr = vptr->rd_curr;
 	int works = 0;
+	u16 wRSR; /* BE */
 
+	HAILS("velocity_rx_srv", status);
 	do {
 		struct rx_desc *rd = vptr->rd_ring + rd_curr;
 
 		if (!vptr->rd_info[rd_curr].skb)
 			break;
 
-		if (rd->rdesc0.owner == OWNED_BY_NIC)
+		/* if (rd->rdesc0.owner == OWNED_BY_NIC) BE */
+		if (rd->rdesc0 & cpu_to_le32(BE_OWNED_BY_NIC)) /* BE */
 			break;
 
 		rmb();
 
+		wRSR = (u16)(cpu_to_le32(rd->rdesc0)); /* BE */
 		/*
 		 *	Don't drop CE or RL error frame although RXOK is off
 		 */
-		if ((rd->rdesc0.RSR & RSR_RXOK) || (!(rd->rdesc0.RSR & RSR_RXOK) && (rd->rdesc0.RSR & (RSR_CE | RSR_RL)))) {
+		/* if ((rd->rdesc0.RSR & RSR_RXOK) || (!(rd->rdesc0.RSR & RSR_RXOK) && (rd->rdesc0.RSR & (RSR_CE | RSR_RL)))) { BE */
+		if ((wRSR & RSR_RXOK) || (!(wRSR & RSR_RXOK) && (wRSR & (RSR_CE | RSR_RL)))) { /* BE */
 			if (velocity_receive_frame(vptr, rd_curr) < 0)
 				stats->rx_dropped++;
 		} else {
-			if (rd->rdesc0.RSR & RSR_CRC)
+			/* if (rd->rdesc0.RSR & RSR_CRC) BE */
+			if (wRSR & RSR_CRC) /* BE */
 				stats->rx_crc_errors++;
-			if (rd->rdesc0.RSR & RSR_FAE)
+			/* if (rd->rdesc0.RSR & RSR_FAE) BE */
+			if (wRSR & RSR_FAE) /* BE */
 				stats->rx_frame_errors++;
 
 			stats->rx_dropped++;
 		}
 
-		rd->inten = 1;
+		/* rd->inten = 1; BE */
+		rd->ltwo |= cpu_to_le32(BE_INT_ENABLE); /* BE */
 
 		vptr->dev->last_rx = jiffies;
 
@@ -1296,13 +1357,21 @@ static int velocity_rx_srv(struct veloci
 
 static inline void velocity_rx_csum(struct rx_desc *rd, struct sk_buff *skb)
 {
+	u8 bCSM;
+	HAIL("velocity_rx_csum");
 	skb->ip_summed = CHECKSUM_NONE;
 
-	if (rd->rdesc1.CSM & CSM_IPKT) {
-		if (rd->rdesc1.CSM & CSM_IPOK) {
-			if ((rd->rdesc1.CSM & CSM_TCPKT) ||
-					(rd->rdesc1.CSM & CSM_UDPKT)) {
-				if (!(rd->rdesc1.CSM & CSM_TUPOK)) {
+//	if (rd->rdesc1.CSM & CSM_IPKT) {
+//		if (rd->rdesc1.CSM & CSM_IPOK) {
+//			if ((rd->rdesc1.CSM & CSM_TCPKT) ||
+//					(rd->rdesc1.CSM & CSM_UDPKT)) {
+//				if (!(rd->rdesc1.CSM & CSM_TUPOK)) {
+	bCSM = (u8)(cpu_to_le32(rd->rdesc1) >> 16); /* BE */
+	if (bCSM & CSM_IPKT) {
+		if (bCSM & CSM_IPOK) {
+			if ((bCSM & CSM_TCPKT) ||
+			    (bCSM & CSM_UDPKT)) {
+				if (!(bCSM & CSM_TUPOK)) {      /* BE */
 					return;
 				}
 			}
@@ -1328,9 +1397,11 @@ static inline int velocity_rx_copy(struc
 {
 	int ret = -1;
 
+	HAIL("velocity_rx_copy");
 	if (pkt_size < rx_copybreak) {
 		struct sk_buff *new_skb;
 
+		HAIL("velocity_rx_copy (working...)");
 		new_skb = dev_alloc_skb(pkt_size + 2);
 		if (new_skb) {
 			new_skb->dev = vptr->dev;
@@ -1361,10 +1432,12 @@ static inline int velocity_rx_copy(struc
 static inline void velocity_iph_realign(struct velocity_info *vptr,
 					struct sk_buff *skb, int pkt_size)
 {
+	HAIL("velocity_iph_realign");
 	/* FIXME - memmove ? */
 	if (vptr->flags & VELOCITY_FLAGS_IP_ALIGN) {
 		int i;
 
+		HAIL("velocity_iph_realign (working...)");
 		for (i = pkt_size; i >= 0; i--)
 			*(skb->data + i + 2) = *(skb->data + i);
 		skb_reserve(skb, 2);
@@ -1383,19 +1456,27 @@ static inline void velocity_iph_realign(
 static int velocity_receive_frame(struct velocity_info *vptr, int idx)
 {
 	void (*pci_action)(struct pci_dev *, dma_addr_t, size_t, int);
+	u16 pkt_len; /* BE */
+	u16 wRSR;    /* BE */
+	struct sk_buff *skb;
 	struct net_device_stats *stats = &vptr->stats;
 	struct velocity_rd_info *rd_info = &(vptr->rd_info[idx]);
 	struct rx_desc *rd = &(vptr->rd_ring[idx]);
-	int pkt_len = rd->rdesc0.len;
-	struct sk_buff *skb;
+	/* int pkt_len = rd->rdesc0.len BE */;
+
+	pkt_len = ((cpu_to_le32(rd->rdesc0) >> 16) & 0x00003FFFUL); /* BE */
+	wRSR = (u16)(cpu_to_le32(rd->rdesc0)); /* BE */
 
-	if (rd->rdesc0.RSR & (RSR_STP | RSR_EDP)) {
+	HAIL("velocity_receive_frame");
+	/* if (rd->rdesc0.RSR & (RSR_STP | RSR_EDP)) { BE */
+	if (wRSR & (RSR_STP | RSR_EDP)) { /* BE */
 		VELOCITY_PRT(MSG_LEVEL_VERBOSE, KERN_ERR " %s : the received frame span multple RDs.\n", vptr->dev->name);
 		stats->rx_length_errors++;
 		return -EINVAL;
 	}
 
-	if (rd->rdesc0.RSR & RSR_MAR)
+	/* if (rd->rdesc0.RSR & RSR_MAR) BE */
+	if (wRSR & RSR_MAR) /* BE */
 		vptr->stats.multicast++;
 
 	skb = rd_info->skb;
@@ -1408,7 +1489,8 @@ static int velocity_receive_frame(struct
 	 */
 
 	if (vptr->flags & VELOCITY_FLAGS_VAL_PKT_LEN) {
-		if (rd->rdesc0.RSR & RSR_RL) {
+		/* if (rd->rdesc0.RSR & RSR_RL) { BE */
+		if (wRSR & RSR_RL) { /* BE */
 			stats->rx_length_errors++;
 			return -EINVAL;
 		}
@@ -1452,6 +1534,7 @@ static int velocity_alloc_rx_buf(struct 
 	struct rx_desc *rd = &(vptr->rd_ring[idx]);
 	struct velocity_rd_info *rd_info = &(vptr->rd_info[idx]);
 
+	HAIL("velocity_alloc_rx_buf");
 	rd_info->skb = dev_alloc_skb(vptr->rx_buf_sz + 64);
 	if (rd_info->skb == NULL)
 		return -ENOMEM;
@@ -1469,10 +1552,14 @@ static int velocity_alloc_rx_buf(struct 
  	 */
 
 	*((u32 *) & (rd->rdesc0)) = 0;
-	rd->len = cpu_to_le32(vptr->rx_buf_sz);
-	rd->inten = 1;
+	/* rd->len = cpu_to_le32(vptr->rx_buf_sz);		BE */
+	/* rd->inten = 1;					BE */
 	rd->pa_low = cpu_to_le32(rd_info->skb_dma);
-	rd->pa_high = 0;
+	/* rd->pa_high = 0;					BE */
+	rd->ltwo &= cpu_to_le32(0xC000FFFFUL);			/* BE */
+	rd->ltwo |= cpu_to_le32((vptr->rx_buf_sz << 16));	/* BE */
+	rd->ltwo |= cpu_to_le32(BE_INT_ENABLE);			/* BE */
+	rd->ltwo &= cpu_to_le32(0xFFFF0000UL);			/* BE */
 	return 0;
 }
 
@@ -1493,9 +1580,11 @@ static int velocity_tx_srv(struct veloci
 	int full = 0;
 	int idx;
 	int works = 0;
+	u16 wTSR; /* BE */
 	struct velocity_td_info *tdinfo;
 	struct net_device_stats *stats = &vptr->stats;
 
+	HAILS("velocity_tx_srv", status);
 	for (qnum = 0; qnum < vptr->num_txq; qnum++) {
 		for (idx = vptr->td_tail[qnum]; vptr->td_used[qnum] > 0;
 			idx = (idx + 1) % vptr->options.numtx) {
@@ -1506,22 +1595,29 @@ static int velocity_tx_srv(struct veloci
 			td = &(vptr->td_rings[qnum][idx]);
 			tdinfo = &(vptr->td_infos[qnum][idx]);
 
-			if (td->tdesc0.owner == OWNED_BY_NIC)
+			/* if (td->tdesc0.owner == OWNED_BY_NIC) BE */
+			if (td->tdesc0 & cpu_to_le32(BE_OWNED_BY_NIC)) /* BE */
 				break;
 
 			if ((works++ > 15))
 				break;
 
-			if (td->tdesc0.TSR & TSR0_TERR) {
+			wTSR = (u16)cpu_to_le32(td->tdesc0);
+			/* if (td->tdesc0.TSR & TSR0_TERR) { BE */
+			if (wTSR & TSR0_TERR) { /* BE */
 				stats->tx_errors++;
 				stats->tx_dropped++;
-				if (td->tdesc0.TSR & TSR0_CDH)
+				/* if (td->tdesc0.TSR & TSR0_CDH) BE */
+				if (wTSR & TSR0_CDH) /* BE */
 					stats->tx_heartbeat_errors++;
-				if (td->tdesc0.TSR & TSR0_CRS)
+				/* if (td->tdesc0.TSR & TSR0_CRS) BE */
+				if (wTSR & TSR0_CRS) /* BE */
 					stats->tx_carrier_errors++;
-				if (td->tdesc0.TSR & TSR0_ABT)
+				/* if (td->tdesc0.TSR & TSR0_ABT) BE */
+				if (wTSR & TSR0_ABT) /* BE */
 					stats->tx_aborted_errors++;
-				if (td->tdesc0.TSR & TSR0_OWC)
+				/* if (td->tdesc0.TSR & TSR0_OWC) BE */
+				if (wTSR & TSR0_OWC) /* BE */
 					stats->tx_window_errors++;
 			} else {
 				stats->tx_packets++;
@@ -1610,6 +1706,7 @@ static void velocity_print_link_status(s
 
 static void velocity_error(struct velocity_info *vptr, int status)
 {
+	HAILS("velocity_error", status);
 
 	if (status & ISR_TXSTLI) {
 		struct mac_regs __iomem * regs = vptr->mac_regs;
@@ -1699,6 +1796,7 @@ static void velocity_free_tx_buf(struct 
 	struct sk_buff *skb = tdinfo->skb;
 	int i;
 
+	HAIL("velocity_free_tx_buf");
 	/*
 	 *	Don't unmap the pre-allocated tx_bufs
 	 */
@@ -1902,6 +2000,7 @@ static int velocity_xmit(struct sk_buff 
 	struct velocity_td_info *tdinfo;
 	unsigned long flags;
 	int index;
+	u32 lbufsz; /* BE */
 
 	int pktlen = skb->len;
 
@@ -1918,9 +2017,18 @@ static int velocity_xmit(struct sk_buff 
 	td_ptr = &(vptr->td_rings[qnum][index]);
 	tdinfo = &(vptr->td_infos[qnum][index]);
 
-	td_ptr->tdesc1.TCPLS = TCPLS_NORMAL;
-	td_ptr->tdesc1.TCR = TCR0_TIC;
-	td_ptr->td_buf[0].queue = 0;
+	td_ptr->tdesc0 = 0x00000000UL;				  /* BE */
+	td_ptr->tdesc1 = 0x00000000UL;				  /* BE */
+
+	/* td_ptr->tdesc1.TCPLS = TCPLS_NORMAL;		BE */
+	td_ptr->tdesc1 &= cpu_to_le32(0xfcffffffUL);		  /* BE */
+	td_ptr->tdesc1 |= cpu_to_le32(((u32)TCPLS_NORMAL) << 24); /* BE */
+
+	/* td_ptr->tdesc1.TCR = TCR0_TIC;		BE */
+	td_ptr->tdesc1 |= cpu_to_le32(BE_TCR_TIC);		  /* BE */
+
+	/*	td_ptr->td_buf[0].queue = 0;		BE */
+	td_ptr->td_buf[0].ltwo &= cpu_to_le32(~BE_QUEUE_ENABLE);  /* BE */
 
 	/*
 	 *	Pad short frames.
@@ -1932,20 +2040,36 @@ static int velocity_xmit(struct sk_buff 
 		memset(tdinfo->buf + skb->len, 0, ETH_ZLEN - skb->len);
 		tdinfo->skb = skb;
 		tdinfo->skb_dma[0] = tdinfo->buf_dma;
-		td_ptr->tdesc0.pktsize = pktlen;
+		/* td_ptr->tdesc0.pktsize = pktlen; */
+		td_ptr->tdesc0 &= cpu_to_le32(0xc000ffffUL); /* BE */
+		lbufsz = pktlen; /* Assign, and make sure it's unsigned 32 bits - BE */
+		lbufsz = lbufsz << 16; /* BE - shift over     */
+		td_ptr->tdesc0 |= cpu_to_le32(lbufsz); /* BE */
+
 		td_ptr->td_buf[0].pa_low = cpu_to_le32(tdinfo->skb_dma[0]);
-		td_ptr->td_buf[0].pa_high = 0;
-		td_ptr->td_buf[0].bufsize = td_ptr->tdesc0.pktsize;
+		/* td_ptr->td_buf[0].pa_high = 0; */
+		/* td_ptr->td_buf[0].bufsize = td_ptr->tdesc0.pktsize; */
+		td_ptr->td_buf[0].ltwo = cpu_to_le32(lbufsz);   /* BE */
 		tdinfo->nskb_dma = 1;
-		td_ptr->tdesc1.CMDZ = 2;
+		/* td_ptr->tdesc1.CMDZ = 2; */
+		td_ptr->tdesc1 &= cpu_to_le32(0x0fffffffUL); /* BE */
+		td_ptr->tdesc1 |= cpu_to_le32(((u32)0x2) << 28); /* BE */
 	} else
 #ifdef VELOCITY_ZERO_COPY_SUPPORT
+	/*
+	 * BE - NOTE on the VELOCITY_ZERO_COPY_SUPPORT:
+	 * This block of code has NOT been patched up for BE support, as
+	 * it is certainly broken -- if it compiles at all.  Since the BE
+	 * fixes depend on the broken code, attempts to convert to BE support
+	 * would almost certainly confuse more than help.
+	 */
 	if (skb_shinfo(skb)->nr_frags > 0) {
 		int nfrags = skb_shinfo(skb)->nr_frags;
 		tdinfo->skb = skb;
 		if (nfrags > 6) {
 			skb_copy_from_linear_data(skb, tdinfo->buf, skb->len);
 			tdinfo->skb_dma[0] = tdinfo->buf_dma;
+			/* BE: Er, exactly what value are we assigning in this next line? */
 			td_ptr->tdesc0.pktsize =
 			td_ptr->td_buf[0].pa_low = cpu_to_le32(tdinfo->skb_dma[0]);
 			td_ptr->td_buf[0].pa_high = 0;
@@ -1962,6 +2086,7 @@ static int velocity_xmit(struct sk_buff 
 			/* FIXME: support 48bit DMA later */
 			td_ptr->td_buf[i].pa_low = cpu_to_le32(tdinfo->skb_dma);
 			td_ptr->td_buf[i].pa_high = 0;
+			/* BE: This next line can't be right: */
 			td_ptr->td_buf[i].bufsize = skb->len->skb->data_len;
 
 			for (i = 0; i < nfrags; i++) {
@@ -1979,7 +2104,7 @@ static int velocity_xmit(struct sk_buff 
 		}
 
 	} else
-#endif
+#endif /* (broken) VELOCITY_ZERO_COPY_SUPPORT */
 	{
 		/*
 		 *	Map the linear network buffer into PCI space and
@@ -1987,19 +2112,30 @@ static int velocity_xmit(struct sk_buff 
 		 */
 		tdinfo->skb = skb;
 		tdinfo->skb_dma[0] = pci_map_single(vptr->pdev, skb->data, pktlen, PCI_DMA_TODEVICE);
-		td_ptr->tdesc0.pktsize = pktlen;
+		/* td_ptr->tdesc0.pktsize = pktlen;			BE */
+		td_ptr->tdesc0 &= cpu_to_le32(0xc000ffffUL);	/* BE */
+		lbufsz = pktlen; /* Assign, and make sure it's unsigned 32 bits - BE */
+		lbufsz = lbufsz << 16;				/* BE */
+		td_ptr->tdesc0 |= cpu_to_le32(lbufsz);		/* BE */
 		td_ptr->td_buf[0].pa_low = cpu_to_le32(tdinfo->skb_dma[0]);
-		td_ptr->td_buf[0].pa_high = 0;
-		td_ptr->td_buf[0].bufsize = td_ptr->tdesc0.pktsize;
+		/* td_ptr->td_buf[0].pa_high = 0;			BE */
+		/* td_ptr->td_buf[0].bufsize = td_ptr->tdesc0.pktsize;	BE */
+		td_ptr->td_buf[0].ltwo = cpu_to_le32(lbufsz);	/* BE */
+
 		tdinfo->nskb_dma = 1;
-		td_ptr->tdesc1.CMDZ = 2;
+		/* td_ptr->tdesc1.CMDZ = 2;				BE */
+		td_ptr->tdesc1 &= cpu_to_le32(0x0fffffffUL);	/* BE */
+		td_ptr->tdesc1 |= cpu_to_le32(((u32)0x2) << 28);/* BE */
 	}
 
 	if (vptr->flags & VELOCITY_FLAGS_TAGGING) {
-		td_ptr->tdesc1.pqinf.VID = (vptr->options.vid & 0xfff);
-		td_ptr->tdesc1.pqinf.priority = 0;
-		td_ptr->tdesc1.pqinf.CFI = 0;
-		td_ptr->tdesc1.TCR |= TCR0_VETAG;
+		/* td_ptr->tdesc1.pqinf.priority = 0;			BE */
+		/* td_ptr->tdesc1.pqinf.CFI = 0;			BE */
+		td_ptr->tdesc1 &= cpu_to_le32(0xFFFF0000UL);	/* BE */
+		/* td_ptr->tdesc1.pqinf.VID = (vptr->options.vid & 0xfff); BE */
+		td_ptr->tdesc1 |= cpu_to_le32((vptr->options.vid & 0xfff)); /* BE */
+		/* td_ptr->tdesc1.TCR |= TCR0_VETAG;			BE */
+		td_ptr->tdesc1 |= cpu_to_le32(BE_TCR_VETAG);	/* BE */
 	}
 
 	/*
@@ -2009,26 +2145,34 @@ static int velocity_xmit(struct sk_buff 
 				 && (skb->ip_summed == CHECKSUM_PARTIAL)) {
 		const struct iphdr *ip = ip_hdr(skb);
 		if (ip->protocol == IPPROTO_TCP)
-			td_ptr->tdesc1.TCR |= TCR0_TCPCK;
+			/* td_ptr->tdesc1.TCR |= TCR0_TCPCK;	BE */
+			td_ptr->tdesc1 |= cpu_to_le32(BE_TCR_TCPCK);	/* BE */
 		else if (ip->protocol == IPPROTO_UDP)
-			td_ptr->tdesc1.TCR |= (TCR0_UDPCK);
-		td_ptr->tdesc1.TCR |= TCR0_IPCK;
-	}
+			/* td_ptr->tdesc1.TCR |= (TCR0_UDPCK);	BE */
+			td_ptr->tdesc1 |= cpu_to_le32(BE_TCR_UDPCK);	/* BE */
+		/* td_ptr->tdesc1.TCR |= TCR0_IPCK;		BE */
+		td_ptr->tdesc1 |= cpu_to_le32(BE_TCR_IPCK);		/* BE */
+ 	}
 	{
 
 		int prev = index - 1;
 
 		if (prev < 0)
 			prev = vptr->options.numtx - 1;
-		td_ptr->tdesc0.owner = OWNED_BY_NIC;
+		/* td_ptr->tdesc0.owner = OWNED_BY_NIC; BE */
+		td_ptr->tdesc0 |= cpu_to_le32(BE_OWNED_BY_NIC); /* BE */
 		vptr->td_used[qnum]++;
 		vptr->td_curr[qnum] = (index + 1) % vptr->options.numtx;
 
 		if (AVAIL_TD(vptr, qnum) < 1)
 			netif_stop_queue(dev);
 
-		td_ptr = &(vptr->td_rings[qnum][prev]);
-		td_ptr->td_buf[0].queue = 1;
+ 		td_ptr = &(vptr->td_rings[qnum][prev]);
+ 		/* td_ptr->td_buf[0].queue = 1; BE */
+ 		td_ptr->td_buf[0].ltwo |= cpu_to_le32(BE_QUEUE_ENABLE); /* BE */
+		if (vdebug&2) printk(KERN_NOTICE "velocity_xmit: (%s) len=%d idx=%d tdesc0=0x%x tdesc1=0x%x ltwo=0x%x\n",
+			(pktlen<ETH_ZLEN) ? "short" : "normal", pktlen, index,
+			td_ptr->tdesc0, td_ptr->tdesc1, td_ptr->td_buf[0].ltwo);
 		mac_tx_queue_wake(vptr->mac_regs, qnum);
 	}
 	dev->trans_start = jiffies;
@@ -2054,7 +2198,7 @@ static int velocity_intr(int irq, void *
 	u32 isr_status;
 	int max_count = 0;
 
-
+	HAIL("velocity_intr");
 	spin_lock(&vptr->lock);
 	isr_status = mac_read_isr(vptr->mac_regs);
 
@@ -2073,7 +2217,10 @@ static int velocity_intr(int irq, void *
 
 	while (isr_status != 0) {
 		mac_write_isr(vptr->mac_regs, isr_status);
-		if (isr_status & (~(ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI)))
+		HAILS("velocity_intr",isr_status);
+		/* MJW - velocity_error is ALWAYS called; need to mask off some other flags */
+		/* if (isr_status & (~(ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI))) */
+		if (isr_status & (~(ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI | ISR_PTX0I | ISR_ISR0)))
 			velocity_error(vptr, isr_status);
 		if (isr_status & (ISR_PRXI | ISR_PPRXI))
 			max_count += velocity_rx_srv(vptr, isr_status);
@@ -2111,6 +2258,7 @@ static void velocity_set_multi(struct ne
 	int i;
 	struct dev_mc_list *mclist;
 
+	HAIL("velocity_set_multi");
 	if (dev->flags & IFF_PROMISC) {	/* Set promiscuous. */
 		writel(0xffffffff, &regs->MARCAM[0]);
 		writel(0xffffffff, &regs->MARCAM[4]);
@@ -2154,6 +2302,7 @@ static struct net_device_stats *velocity
 {
 	struct velocity_info *vptr = netdev_priv(dev);
 
+	HAIL("net_device_stats");
 	/* If the hardware is down, don't touch MII */
 	if(!netif_running(dev))
 		return &vptr->stats;
@@ -2198,6 +2347,7 @@ static int velocity_ioctl(struct net_dev
 	struct velocity_info *vptr = netdev_priv(dev);
 	int ret;
 
+	HAIL("velocity_ioctl");
 	/* If we are asked for information and the device is power
 	   saving then we need to bring the device back up to talk to it */
 
@@ -2416,6 +2566,7 @@ static int velocity_mii_read(struct mac_
 {
 	u16 ww;
 
+	HAIL("velocity_mii_read");
 	/*
 	 *	Disable MIICR_MAUTO, so that mii addr can be set normally
 	 */
@@ -2452,6 +2603,7 @@ static int velocity_mii_write(struct mac
 {
 	u16 ww;
 
+	HAIL("velocity_mii_write");
 	/*
 	 *	Disable MIICR_MAUTO, so that mii addr can be set normally
 	 */
--- linux-2.6.22.18/drivers/net/via-velocity.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/drivers/net/via-velocity.h	2008-07-09 15:14:37.000000000 +0200
@@ -196,64 +196,70 @@
  *	Receive descriptor
  */
 
-struct rdesc0 {
-	u16 RSR;		/* Receive status */
-	u16 len:14;		/* Received packet length */
-	u16 reserved:1;
-	u16 owner:1;		/* Who owns this buffer ? */
-};
-
-struct rdesc1 {
-	u16 PQTAG;
-	u8 CSM;
-	u8 IPKT;
-};
+//struct rdesc0 {
+//	u16 RSR;		/* Receive status */
+//	u16 len:14;		/* Received packet length */
+//	u16 reserved:1;
+//	u16 owner:1;		/* Who owns this buffer ? */
+//};
+
+//struct rdesc1 {
+//	u16 PQTAG;
+//	u8 CSM;
+//	u8 IPKT;
+//};
 
 struct rx_desc {
-	struct rdesc0 rdesc0;
-	struct rdesc1 rdesc1;
+//	struct rdesc0 rdesc0;
+//	struct rdesc1 rdesc1;
+	u32 rdesc0;
+	u32 rdesc1;
 	u32 pa_low;		/* Low 32 bit PCI address */
-	u16 pa_high;		/* Next 16 bit PCI address (48 total) */
-	u16 len:15;		/* Frame size */
-	u16 inten:1;		/* Enable interrupt */
+//	u16 pa_high;		/* Next 16 bit PCI address (48 total) */
+//	u16 len:15;		/* Frame size */
+//	u16 inten:1;		/* Enable interrupt */
+	u32 ltwo;
 } __attribute__ ((__packed__));
 
 /*
  *	Transmit descriptor
  */
 
-struct tdesc0 {
-	u16 TSR;		/* Transmit status register */
-	u16 pktsize:14;		/* Size of frame */
-	u16 reserved:1;
-	u16 owner:1;		/* Who owns the buffer */
-};
-
-struct pqinf {			/* Priority queue info */
-	u16 VID:12;
-	u16 CFI:1;
-	u16 priority:3;
-} __attribute__ ((__packed__));
-
-struct tdesc1 {
-	struct pqinf pqinf;
-	u8 TCR;
-	u8 TCPLS:2;
-	u8 reserved:2;
-	u8 CMDZ:4;
-} __attribute__ ((__packed__));
+//struct tdesc0 {
+//	u16 TSR;		/* Transmit status register */
+//	u16 pktsize:14;		/* Size of frame */
+//	u16 reserved:1;
+//	u16 owner:1;		/* Who owns the buffer */
+//};
+
+//struct pqinf {			/* Priority queue info */
+//	u16 VID:12;
+//	u16 CFI:1;
+//	u16 priority:3;
+//} __attribute__ ((__packed__));
+
+//struct tdesc1 {
+//	struct pqinf pqinf;
+//	u8 TCR;
+//	u8 TCPLS:2;
+//	u8 reserved:2;
+//	u8 CMDZ:4;
+//} __attribute__ ((__packed__));
 
 struct td_buf {
 	u32 pa_low;
-	u16 pa_high;
-	u16 bufsize:14;
-	u16 reserved:1;
-	u16 queue:1;
+//	u16 pa_high;
+//	u16 bufsize:14;
+//	u16 reserved:1;
+//	u16 queue:1;
+	u32 ltwo;
 } __attribute__ ((__packed__));
 
 struct tx_desc {
-	struct tdesc0 tdesc0;
-	struct tdesc1 tdesc1;
+//	struct tdesc0 tdesc0;
+//	struct tdesc1 tdesc1;
+	u32 tdesc0;
+	u32 tdesc1;
 	struct td_buf td_buf[7];
 };
 
@@ -279,6 +285,16 @@ enum  velocity_owner {
 	OWNED_BY_NIC = 1
 };
 
+/* Constants added for the BE fixes */
+#define BE_OWNED_BY_NIC    0x80000000UL
+#define BE_INT_ENABLE      0x80000000UL
+#define BE_QUEUE_ENABLE    0x80000000UL
+#define BE_TCR_TIC         0x00800000UL
+#define BE_TCR_VETAG       0x00200000UL
+#define BE_TCR_TCPCK       0x00040000UL
+#define BE_TCR_UDPCK       0x00080000UL
+#define BE_TCR_IPCK        0x00100000UL
+
 
 /*
  *	MAC registers and macros.
@@ -1698,6 +1714,7 @@ enum velocity_flow_cntl_type {
 };
 
 struct velocity_opt {
+	int velo_debug;                 /* debug flag */
 	int numrx;			/* Number of RX descriptors */
 	int numtx;			/* Number of TX descriptors */
 	enum speed_opt spd_dpx;		/* Media link mode */
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/ds101.hixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/ds101.h	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * DS101 platform specific definitions
+ *
+ * Author: Øyvind Repvik <nail@nslu2-linux.org>
+ *
+ * based on ixdp425.h:
+ *	Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define DS101_SCL_PIN			0
+#define DS101_SDA_PIN			1
+#define DS101_BUZZ_GPIO			2
+#define DS101_POWER_LED_GPIO		3
+#define DS101_USBCOPYB_GPIO		4 /* shared */
+#define DS101_USBCOPY_SOLID_LED_GPIO	4 /* shared */
+#define DS101_USBCOPY_BLINK_LED_GPIO	5
+/* GPIO6 is unknown */
+#define DS101_POWEROFF_GPIO		7
+#define DS101_POWERB_GPIO		8
+/*#define DS101_PCI_INTC_PIN		9
+#define DS101_PCI_INTB_PIN		10
+#define DS101_PCI_INTA_PIN		11
+*/
+#define DS101_RESETB_GPIO		12
+/* GPIO13? */
+#define DS101_STATUSOK_LED_GPIO		14
+#define DS101_STATUSBAD_LED_GPIO	15
+
+#define DS101_PCI_MAX_DEV	2
+#define DS101_PCI_IRQ_LINES	3
+
+#define DS101_POWERB_IRQ	IRQ_IXP4XX_GPIO8
+#define DS101_RESETB_IRQ	IRQ_IXP4XX_GPIO12
+#define DS101_USBCOPYB_IRQ	IRQ_IXP4XX_GPIO4
+
+/* DS101 Timer. */
+#define DS101_FREQ 66000000
+
+/* Stuff needed to setup the IXP expansion
+ * bus on the DS101
+ */
+#define DS101_EXP_RECOVERY_T(x)	(((x) & 15) << 16)
+#define DS101_EXP_HOLD_T(x)	(((x) & 3) << 20)
+#define DS101_EXP_STROBE_T(x)	(((x) & 15) << 22)
+#define DS101_EXP_SETUP_T(x)	(((x) & 3) << 26)
+#define DS101_EXP_ADDR_T(x)	(((x) & 3) << 28)
+
+#define DS101_EXP_SZ_16M	(15 << 10)
+#define DS101_EXP_WR_EN		(1 << 1)
+#define DS101_EXP_BYTE_RD16	(1 << 6)
+#define DS101_EXP_CS_EN		(1 << 31)
+
+/* XXX nope. use the _EXP_ macros in the -setup.c */
+#define DS101_EXP_CS0_INIT	(DS101_EXP_ADDR_T(1) | \
+	DS101_EXP_SETUP_T(1) | DS101_EXP_STROBE_T(1) | \
+	DS101_EXP_HOLD_T(1) | DS101_EXP_RECOVERY_T(1)| \
+	DS101_EXP_SZ_16M | DS101_EXP_WR_EN | \
+	DS101_EXP_BYTE_RD16 | DS101_EXP_CS_EN)
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/fsg.hixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/fsg.h	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ * include/asm-arm/arch-ixp4xx/fsg.h
+ *
+ * Freecom FSG-3 platform specific definitions
+ *
+ * Author: Rod Whitby <rod@whitby.id.au>
+ * Author: Tomasz Chmielewski <mangoo@wpkg.org>
+ * Maintainers: http://www.nslu2-linux.org
+ *
+ * Based on coyote.h by
+ * Copyright 2004 (c) MontaVista, Software, Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H__
+#error "Do not include this directly, instead #include <asm/hardware.h>"
+#endif
+
+#define FSG_SDA_PIN		12
+#define FSG_SCL_PIN		13
+
+/*
+ * FSG PCI IRQs
+ */
+#define FSG_PCI_MAX_DEV		3
+#define FSG_PCI_IRQ_LINES	3
+
+
+/* PCI controller GPIO to IRQ pin mappings */
+#define FSG_PCI_INTA_PIN	6
+#define FSG_PCI_INTB_PIN	7
+#define FSG_PCI_INTC_PIN	5
+
+/* Buttons */
+
+#define FSG_SB_GPIO		4
+#define FSG_RB_GPIO		9
+#define FSG_UB_GPIO		10
+
+#define FSG_SB_IRQ		IRQ_IXP4XX_GPIO4
+#define FSG_RB_IRQ		IRQ_IXP4XX_GPIO9
+#define FSG_UB_IRQ		IRQ_IXP4XX_GPIO10
+
+#define FSG_SB_BM		(1L << FSG_SB_GPIO)
+#define FSG_RB_BM		(1L << FSG_RB_GPIO)
+#define FSG_UB_BM		(1L << FSG_UB_GPIO)
+
+/* LEDs */
+
+#define FSG_LED_RING_GPIO	0
+#define FSG_LED_SYNC_GPIO	1
+#define FSG_LED_USB_GPIO	2
+#define FSG_LED_SATA_GPIO	3
+#define FSG_LED_WAN_GPIO	4
+#define FSG_LED_WLAN_GPIO	5
+
+/* %%% REMOVE %%%
+#define FSG_PCI_SLOT0_PIN	6
+#define FSG_PCI_SLOT1_PIN	7
+
+#define	FSG_PCI_SLOT0_DEVID	14
+#define	FSG_PCI_SLOT1_DEVID	15
+
+#define	FSG_IDE_BASE_PHYS	IXP4XX_EXP_BUS_BASE(3)
+#define	FSG_IDE_BASE_VIRT	0xFFFE1000
+#define	FSG_IDE_REGION_SIZE	0x1000
+
+#define	FSG_IDE_DATA_PORT	0xFFFE10E0
+#define	FSG_IDE_CTRL_PORT	0xFFFE10FC
+#define	FSG_IDE_ERROR_PORT	0xFFFE10E2
+*/
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/hardware.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/hardware.h	2008-07-09 15:14:37.000000000 +0200
@@ -45,5 +45,7 @@
 #include "nslu2.h"
 #include "nas100d.h"
 #include "dsmg600.h"
+#include "fsg.h"
+#include "ds101.h"
 
 #endif  /* _ASM_ARCH_HARDWARE_H */
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/irqs.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/irqs.h	2008-07-09 15:14:37.000000000 +0200
@@ -119,6 +119,14 @@
 #define        IRQ_NAS100D_PCI_INTE    IRQ_IXP4XX_GPIO7
 
 /*
+ * Synology DS101 board IRQs
+ */
+
+#define IRQ_DS101_PCI_INTA	IRQ_IXP4XX_GPIO11
+#define IRQ_DS101_PCI_INTB	IRQ_IXP4XX_GPIO10
+#define IRQ_DS101_PCI_INTC	IRQ_IXP4XX_GPIO9
+
+/*
  * D-Link DSM-G600 RevA board IRQs
  */
 #define        IRQ_DSMG600_PCI_INTA    IRQ_IXP4XX_GPIO11
@@ -128,4 +136,17 @@
 #define        IRQ_DSMG600_PCI_INTE    IRQ_IXP4XX_GPIO7
 #define        IRQ_DSMG600_PCI_INTF    IRQ_IXP4XX_GPIO6
 
+/*
+ * Freecom FSG-3 Board IRQs
+ */
+#define        IRQ_FSG_PCI_INTA        IRQ_IXP4XX_GPIO6
+#define        IRQ_FSG_PCI_INTB        IRQ_IXP4XX_GPIO7
+#define        IRQ_FSG_PCI_INTC        IRQ_IXP4XX_GPIO5
+
+/* %%% REMOVE %%%
+#define	IRQ_FSG_PCI_SLOT0	IRQ_IXP4XX_GPIO6
+#define	IRQ_FSG_PCI_SLOT1	IRQ_IXP4XX_GPIO7
+#define	IRQ_FSG_IDE		IRQ_IXP4XX_GPIO5
+*/
+
 #endif
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/nas100d.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/nas100d.h	2008-07-09 15:14:37.000000000 +0200
@@ -39,14 +39,18 @@
 /* Buttons */
 
 #define NAS100D_PB_GPIO         14
+#define NAS100D_PB_BM           (1L << NAS100D_PB_GPIO)
+
 #define NAS100D_RB_GPIO         4
-#define NAS100D_PO_GPIO         12   /* power off */
 
-#define NAS100D_PB_IRQ          IRQ_IXP4XX_GPIO14
 #define NAS100D_RB_IRQ          IRQ_IXP4XX_GPIO4
 
-/*
-#define NAS100D_PB_BM           (1L << NAS100D_PB_GPIO)
-#define NAS100D_PO_BM           (1L << NAS100D_PO_GPIO)
-#define NAS100D_RB_BM           (1L << NAS100D_RB_GPIO)
-*/
+#define NAS100D_PO_GPIO         12   /* power off */
+
+/* LEDs */
+
+#define NAS100D_LED_PWR_GPIO	15
+#define NAS100D_LED_PWR_BM	(1L << NAS100D_LED_PWR_GPIO)
+
+#define NAS100D_LED_WLAN_GPIO	0
+#define NAS100D_LED_WLAN_BM	(1L << NAS100D_LED_WLAN_GPIO)
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/npe.hixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/npe.h	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,41 @@
+#ifndef __IXP4XX_NPE_H
+#define __IXP4XX_NPE_H
+
+#include <linux/etherdevice.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+
+extern const char *npe_names[];
+
+struct npe_regs {
+	u32 exec_addr, exec_data, exec_status_cmd, exec_count;
+	u32 action_points[4];
+	u32 watchpoint_fifo, watch_count;
+	u32 profile_count;
+	u32 messaging_status, messaging_control;
+	u32 mailbox_status, /*messaging_*/ in_out_fifo;
+};
+
+struct npe {
+	struct resource *mem_res;
+	struct npe_regs __iomem *regs;
+	u32 regs_phys;
+	int id;
+	int valid;
+};
+
+
+static inline const char *npe_name(struct npe *npe)
+{
+	return npe_names[npe->id];
+}
+
+int npe_running(struct npe *npe);
+int npe_send_message(struct npe *npe, const void *msg, const char *what);
+int npe_recv_message(struct npe *npe, void *msg, const char *what);
+int npe_send_recv_message(struct npe *npe, void *msg, const char *what);
+int npe_load_firmware(struct npe *npe, const char *name, struct device *dev);
+struct npe *npe_request(int id);
+void npe_release(struct npe *npe);
+
+#endif /* __IXP4XX_NPE_H */
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/platform.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/platform.h	2008-07-09 15:14:37.000000000 +0200
@@ -86,6 +86,17 @@ struct ixp4xx_i2c_pins {
 	unsigned long scl_pin;
 };
 
+#define IXP4XX_ETH_NPEA		0x00
+#define IXP4XX_ETH_NPEB		0x10
+#define IXP4XX_ETH_NPEC		0x20
+
+/* Information about built-in Ethernet MAC interfaces */
+struct mac_plat_info {
+	u8 phy;		/* MII PHY ID, 0 - 31 */
+	u8 rxq;		/* configurable, currently 0 - 31 only */
+	u8 hwaddr[6];
+};
+
 /*
  * This structure provide a means for the board setup code
  * to give information to th pata_ixp4xx driver. It is
@@ -120,6 +131,47 @@ struct pci_sys_data;
 extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
 extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
 
+/* Fuse definitions and functions */
+
+/* Fuse Bits of IXP_EXP_CFG2 */
+#define IXP4XX_FUSE_RCOMP               (1 << 0)
+#define IXP4XX_FUSE_USB_DEVICE          (1 << 1)
+#define IXP4XX_FUSE_HASH                (1 << 2)
+#define IXP4XX_FUSE_AES                 (1 << 3)
+#define IXP4XX_FUSE_DES                 (1 << 4)
+#define IXP4XX_FUSE_HDLC                (1 << 5)
+#define IXP4XX_FUSE_AAL                 (1 << 6)
+#define IXP4XX_FUSE_HSS                 (1 << 7)
+#define IXP4XX_FUSE_UTOPIA              (1 << 8)
+#define IXP4XX_FUSE_NPEB_ETH0           (1 << 9)
+#define IXP4XX_FUSE_NPEC_ETH            (1 << 10)
+#define IXP4XX_FUSE_RESET_NPEA          (1 << 11)
+#define IXP4XX_FUSE_RESET_NPEB          (1 << 12)
+#define IXP4XX_FUSE_RESET_NPEC          (1 << 13)
+#define IXP4XX_FUSE_PCI                 (1 << 14)
+#define IXP4XX_FUSE_ECC_TIMESYNC        (1 << 15)
+#define IXP4XX_FUSE_UTOPIA_PHY_LIMIT    (3 << 16)
+#define IXP4XX_FUSE_USB_HOST            (1 << 18)
+#define IXP4XX_FUSE_NPEA_ETH            (1 << 19)
+#define IXP4XX_FUSE_NPEB_ETH_1_TO_3     (1 << 20)
+#define IXP4XX_FUSE_RSA                 (1 << 21)
+#define IXP4XX_FUSE_XSCALE_MAX_FREQ     (3 << 22)
+#define IXP4XX_FUSE_RESERVED            (0xFF << 24)
+
+#define IXP4XX_FUSE_IXP46X_ONLY (IXP4XX_FUSE_ECC_TIMESYNC |             \
+                                 IXP4XX_FUSE_USB_HOST |                 \
+                                 IXP4XX_FUSE_NPEA_ETH |                 \
+                                 IXP4XX_FUSE_NPEB_ETH_1_TO_3 |          \
+                                 IXP4XX_FUSE_RSA |                      \
+                                 IXP4XX_FUSE_XSCALE_MAX_FREQ)
+
+extern u32 ixp4xx_read_fuses(void);
+
+static inline void ixp4xx_write_fuses(u32 value)
+{
+        *IXP4XX_EXP_CFG2 = ~value;
+}
+
 /*
  * GPIO-functions
  */
--- linux-2.6.22.18/include/asm-arm/arch-ixp4xx/qmgr.hixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/include/asm-arm/arch-ixp4xx/qmgr.h	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2007 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#ifndef IXP4XX_QMGR_H
+#define IXP4XX_QMGR_H
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+
+#define HALF_QUEUES	32
+#define QUEUES		64	/* only 32 lower queues currently supported */
+#define MAX_QUEUE_LENGTH 4	/* in dwords */
+
+#define QUEUE_STAT1_EMPTY		1 /* queue status bits */
+#define QUEUE_STAT1_NEARLY_EMPTY	2
+#define QUEUE_STAT1_NEARLY_FULL		4
+#define QUEUE_STAT1_FULL		8
+#define QUEUE_STAT2_UNDERFLOW		1
+#define QUEUE_STAT2_OVERFLOW		2
+
+#define QUEUE_WATERMARK_0_ENTRIES	0
+#define QUEUE_WATERMARK_1_ENTRY		1
+#define QUEUE_WATERMARK_2_ENTRIES	2
+#define QUEUE_WATERMARK_4_ENTRIES	3
+#define QUEUE_WATERMARK_8_ENTRIES	4
+#define QUEUE_WATERMARK_16_ENTRIES	5
+#define QUEUE_WATERMARK_32_ENTRIES	6
+#define QUEUE_WATERMARK_64_ENTRIES	7
+
+/* queue interrupt request conditions */
+#define QUEUE_IRQ_SRC_EMPTY		0
+#define QUEUE_IRQ_SRC_NEARLY_EMPTY	1
+#define QUEUE_IRQ_SRC_NEARLY_FULL	2
+#define QUEUE_IRQ_SRC_FULL		3
+#define QUEUE_IRQ_SRC_NOT_EMPTY		4
+#define QUEUE_IRQ_SRC_NOT_NEARLY_EMPTY	5
+#define QUEUE_IRQ_SRC_NOT_NEARLY_FULL	6
+#define QUEUE_IRQ_SRC_NOT_FULL		7
+
+struct qmgr_regs {
+	u32 acc[QUEUES][MAX_QUEUE_LENGTH]; /* 0x000 - 0x3FF */
+	u32 stat1[4];		/* 0x400 - 0x40F */
+	u32 stat2[2];		/* 0x410 - 0x417 */
+	u32 statne_h;		/* 0x418 - queue nearly empty */
+	u32 statf_h;		/* 0x41C - queue full */
+	u32 irqsrc[4];		/* 0x420 - 0x42F IRC source */
+	u32 irqen[2];		/* 0x430 - 0x437 IRQ enabled */
+	u32 irqstat[2];		/* 0x438 - 0x43F - IRQ access only */
+	u32 reserved[1776];
+	u32 sram[2048];		/* 0x2000 - 0x3FFF - config and buffer */
+};
+
+extern struct qmgr_regs __iomem *qmgr_regs;
+
+void qmgr_set_irq(unsigned int queue, int src,
+		  void (*handler)(void *pdev), void *pdev);
+void qmgr_enable_irq(unsigned int queue);
+void qmgr_disable_irq(unsigned int queue);
+
+/* request_ and release_queue() must be called from non-IRQ context */
+int qmgr_request_queue(unsigned int queue, unsigned int len /* dwords */,
+		       unsigned int nearly_empty_watermark,
+		       unsigned int nearly_full_watermark);
+void qmgr_release_queue(unsigned int queue);
+
+
+static inline void qmgr_put_entry(unsigned int queue, u32 val)
+{
+	__raw_writel(val, &qmgr_regs->acc[queue][0]);
+}
+
+static inline u32 qmgr_get_entry(unsigned int queue)
+{
+	return __raw_readl(&qmgr_regs->acc[queue][0]);
+}
+
+static inline int qmgr_get_stat1(unsigned int queue)
+{
+	return (__raw_readl(&qmgr_regs->stat1[queue >> 3])
+		>> ((queue & 7) << 2)) & 0xF;
+}
+
+static inline int qmgr_get_stat2(unsigned int queue)
+{
+	return (__raw_readl(&qmgr_regs->stat2[queue >> 4])
+		>> ((queue & 0xF) << 1)) & 0x3;
+}
+
+static inline int qmgr_stat_empty(unsigned int queue)
+{
+	return !!(qmgr_get_stat1(queue) & QUEUE_STAT1_EMPTY);
+}
+
+static inline int qmgr_stat_nearly_empty(unsigned int queue)
+{
+	return !!(qmgr_get_stat1(queue) & QUEUE_STAT1_NEARLY_EMPTY);
+}
+
+static inline int qmgr_stat_nearly_full(unsigned int queue)
+{
+	return !!(qmgr_get_stat1(queue) & QUEUE_STAT1_NEARLY_FULL);
+}
+
+static inline int qmgr_stat_full(unsigned int queue)
+{
+	return !!(qmgr_get_stat1(queue) & QUEUE_STAT1_FULL);
+}
+
+static inline int qmgr_stat_underflow(unsigned int queue)
+{
+	return !!(qmgr_get_stat2(queue) & QUEUE_STAT2_UNDERFLOW);
+}
+
+static inline int qmgr_stat_overflow(unsigned int queue)
+{
+	return !!(qmgr_get_stat2(queue) & QUEUE_STAT2_OVERFLOW);
+}
+
+#endif
--- linux-2.6.22.18/include/asm-arm/kexec.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-arm/kexec.h	2008-07-09 15:14:37.000000000 +0200
@@ -14,6 +14,8 @@
 
 #define KEXEC_ARCH KEXEC_ARCH_ARM
 
+#define KEXEC_BOOT_PARAMS_SIZE 1536
+
 #ifndef __ASSEMBLY__
 
 struct kimage;
--- linux-2.6.22.18/include/asm-generic/futex.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/asm-generic/futex.h	2008-07-09 15:14:37.000000000 +0200
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <linux/futex.h>
+#include <linux/preempt.h>
 #include <asm/errno.h>
 #include <asm/uaccess.h>
 
@@ -52,7 +53,34 @@ futex_atomic_op_inuser (int encoded_op, 
 static inline int
 futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
 {
+#ifdef CONFIG_SMP
 	return -ENOSYS;
+#else
+	int curval, ret;
+
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	preempt_disable();
+
+	ret = -EFAULT;
+	if (__copy_from_user_inatomic(&curval, uaddr, sizeof(int)))
+		goto out;
+
+	ret = curval;
+	if (curval != oldval)
+		goto out;
+
+	ret = -EFAULT;
+	if (__copy_to_user_inatomic(uaddr, &newval, sizeof(int)))
+		goto out;
+
+	ret = newval;
+
+ out:
+	preempt_enable();
+	return ret;
+#endif
 }
 
 #endif
--- linux-2.6.22.18/include/linux/mtd/doc2000.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/linux/mtd/doc2000.h	2008-07-09 15:14:37.000000000 +0200
@@ -73,14 +73,29 @@
 #define DoC_Mplus_Toggle		0x1046
 #define DoC_Mplus_DownloadStatus	0x1074
 #define DoC_Mplus_CtrlConfirm		0x1076
+#ifdef CONFIG_MACH_DS101
+#define DoC_Mplus_Power			0x1ffe
+#else
 #define DoC_Mplus_Power			0x1fff
+#endif
 
 /* How to access the device?
  * On ARM, it'll be mmap'd directly with 32-bit wide accesses.
  * On PPC, it's mmap'd and 16-bit wide.
+ * On DS101 (an ARM device), some tricks are needed
  * Others use readb/writeb
  */
-#if defined(__arm__)
+#ifdef CONFIG_MACH_DS101
+#ifndef __ARMEB__
+#define ReadDOC_(adr, reg)      readw((unsigned long)(adr + reg) ^ 0x02)
+#define WriteDOC_(d, adr, reg)  writew(d, (unsigned long)(adr + reg) ^ 0x02)
+#define DOC_IOREMAP_LEN 0x4000
+#else
+#define ReadDOC_(adr, reg)      swab16(readw((void __iomem *)(adr) + (reg)))
+#define WriteDOC_(d, adr, reg)  writew(swab16(d), (void __iomem *)(adr) + (reg))
+#define DOC_IOREMAP_LEN 0x4000
+#endif
+#elif defined(__arm__)
 #define ReadDOC_(adr, reg)      ((unsigned char)(*(volatile __u32 *)(((unsigned long)adr)+((reg)<<2))))
 #define WriteDOC_(d, adr, reg)  do{ *(volatile __u32 *)(((unsigned long)adr)+((reg)<<2)) = (__u32)d; wmb();} while(0)
 #define DOC_IOREMAP_LEN 0x8000
@@ -92,7 +107,6 @@
 #define ReadDOC_(adr, reg)      readb((void __iomem *)(adr) + (reg))
 #define WriteDOC_(d, adr, reg)  writeb(d, (void __iomem *)(adr) + (reg))
 #define DOC_IOREMAP_LEN 0x2000
-
 #endif
 
 #if defined(__i386__) || defined(__x86_64__)
--- linux-2.6.22.18/include/linux/eeprom.hixp42x.2	2008-07-09 15:14:37.000000000 +0200
+++ linux-2.6.22.18/include/linux/eeprom.h	2008-07-09 15:14:37.000000000 +0200
@@ -0,0 +1,71 @@
+#ifndef _LINUX_EEPROM_H
+#define _LINUX_EEPROM_H
+/*
+ *  EEPROM notifier header
+ *
+ *  Copyright (C) 2006 John Bowler
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __KERNEL__
+#error This is a kernel header
+#endif
+
+#include <linux/list.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+
+/* Size of EEPROM in bytes */
+#define EEPROM_SIZE             256
+
+/* possible types of eeprom devices */
+enum eeprom_nature {
+	UNKNOWN,
+	VAIO,
+};
+
+/* Each client has this additional data */
+struct eeprom_data {
+	struct i2c_client client;
+	struct mutex update_lock;
+	u8 valid;			/* bitfield, bit!=0 if slice is valid */
+	unsigned long last_updated[8];	/* In jiffies, 8 slices */
+	u8 data[EEPROM_SIZE];		/* Register values */
+	enum eeprom_nature nature;
+	struct bin_attribute *attr;
+};
+
+/*
+ * This is very basic.
+ *
+ * If an EEPROM is detected on the I2C bus (this only works for
+ * I2C EEPROMs) the notifier chain  is called with
+ * both the I2C information and the kobject for the sysfs
+ * device which has been registers.  It is then possible to
+ * read from the device via the bin_attribute::read method
+ * to extract configuration information.
+ *
+ * Register the notifier in the board level code, there is no
+ * need to unregister it but you can if you want (it will save
+ * a little bit or kernel memory to do so).
+ */
+
+extern int register_eeprom_notifier(struct notifier_block *nb);
+extern int unregister_eeprom_notifier(struct notifier_block *nb);
+
+#endif /* _LINUX_EEPROM_H */
--- linux-2.6.22.18/include/linux/leds.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/linux/leds.h	2008-07-09 15:14:37.000000000 +0200
@@ -110,4 +110,13 @@ extern void ledtrig_ide_activity(void);
 #define ledtrig_ide_activity() do {} while(0)
 #endif
 
+/*
+ * CPU activity indication.
+ */
+/* Idle callback - call with is_idle==1 at the start of the idle loop
+ * and with is_idle==0 at the end.  This symbol must be defined by
+ * the arch core to be able to use LEDS_TRIGGER_CPU_ACTIVITY
+ */
+extern void (*leds_idle)(int is_idle);
+
 #endif		/* __LINUX_LEDS_H_INCLUDED */
--- linux-2.6.22.18/include/linux/notifier.hixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/include/linux/notifier.h	2008-07-09 15:14:37.000000000 +0200
@@ -209,5 +209,8 @@ extern int __srcu_notifier_call_chain(st
 #define CPU_DOWN_FAILED_FROZEN	(CPU_DOWN_FAILED | CPU_TASKS_FROZEN)
 #define CPU_DEAD_FROZEN		(CPU_DEAD | CPU_TASKS_FROZEN)
 
+/* eeprom notifier chain */
+#define EEPROM_REGISTER		0x0001
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_NOTIFIER_H */
--- linux-2.6.22.18/kernel/ksysfs.cixp42x.2	2008-02-11 08:31:19.000000000 +0100
+++ linux-2.6.22.18/kernel/ksysfs.c	2008-07-09 15:14:37.000000000 +0200
@@ -49,6 +49,165 @@ KERNEL_ATTR_RW(uevent_helper);
 #endif
 
 #ifdef CONFIG_KEXEC
+
+#include <asm/setup.h>
+
+extern unsigned long kexec_boot_params;
+
+char kexec_cmdline[COMMAND_LINE_SIZE] = "";
+
+static void
+replace_cmdline_tag(void)
+{
+	char *t;
+	struct tag *real;
+	struct tag *copy;
+	struct tag *rend;
+	int i;
+
+/* TODO: check the return params */
+	t = kmalloc(KEXEC_BOOT_PARAMS_SIZE + COMMAND_LINE_SIZE, GFP_KERNEL);
+	memset((void *)t, 0, KEXEC_BOOT_PARAMS_SIZE + COMMAND_LINE_SIZE);
+
+/* TODO: validate that the boot params are ATAGS, in fact */
+
+	copy = (struct tag *)t;
+	real = (struct tag *)kexec_boot_params;
+	rend = (struct tag *)(kexec_boot_params + KEXEC_BOOT_PARAMS_SIZE);
+	while ((real->hdr.size) && (real < rend)) {
+		if (real->hdr.tag != ATAG_CMDLINE) {
+			memcpy((void *)copy, (void *)real, real->hdr.size * 4);
+			copy = tag_next(copy);
+		}
+		real = tag_next(real);
+	}
+
+/* TODO: validate that we have enough space in the buffer */
+	
+	i = strlen(kexec_cmdline);
+	if (i) {
+		copy->hdr.tag = ATAG_CMDLINE;
+		copy->hdr.size = (sizeof(struct tag_header) + i + 1 + 4) >> 2;
+		strcpy(copy->u.cmdline.cmdline, kexec_cmdline);
+		copy = tag_next(copy);
+	}
+
+	copy->hdr.tag = ATAG_NONE;            /* Empty tag ends list */
+	copy->hdr.size = 0;                   /* zero length */
+
+/* TODO: validate that the temporary buffer isn't too full */
+
+	memcpy((void *)kexec_boot_params, (void *)t, KEXEC_BOOT_PARAMS_SIZE);
+
+	kfree(t);  /* Don't forget to free the big buffer we used */
+}
+
+static ssize_t kexec_cmdline_show(struct kset *kset, char *page)
+{
+	return sprintf(page, "%s\n", kexec_cmdline);
+}
+
+static ssize_t kexec_cmdline_store(struct kset *kset, const char *page,
+				   size_t count)
+{
+	if ((count + 1) > COMMAND_LINE_SIZE)
+		count = COMMAND_LINE_SIZE;
+	memcpy(kexec_cmdline, page, count);
+	kexec_cmdline[count] = '\0';
+	if (count && (kexec_cmdline[count - 1] == '\n'))
+		kexec_cmdline[count - 1] = '\0';
+	replace_cmdline_tag();
+	return count;
+}
+KERNEL_ATTR_RW(kexec_cmdline);
+
+static ssize_t kexec_boot_params_show(struct kset *kset, char *page)
+{
+	unsigned long *p;
+	char buf[PAGE_SIZE];
+	int keep_doing;
+
+	p = (unsigned long *)kexec_boot_params;
+
+	/* if this doesn't look like atags, just print first few words */
+	if (p[1] != ATAG_CORE)
+		return sprintf(page, "0x%lx 0x%lx 0x%lx 0x%lx\n",
+			       p[0], p[1], p[2], p[3]);
+
+	/* carefully walk the atag list, and print out the structure */
+	keep_doing = 1;
+	do {
+		switch (p[1]) {
+		case ATAG_CORE:
+			/* watch out, core tag is permitted to be empty */
+			if (p[0] == 5)
+				sprintf(buf,
+					"CORE flg=%ld pgsz=%ld rdev=0x%lx\n",
+					p[2], p[3], p[4]);
+			else
+				sprintf(buf,"CORE\n");
+			break;
+		case ATAG_MEM:
+			sprintf(buf,"MEM  %ldM@0x%lx\n", p[2] / (1024 * 1024),
+				p[3]);
+			break;
+		case ATAG_VIDEOTEXT:
+			sprintf(buf,"VIDEOTEXT sz=%ld\n", p[0]);
+			break;
+		case ATAG_RAMDISK:
+			sprintf(buf,"RAMDISK prmpt=%ld %ldK@0x%lx\n",
+				p[2], p[3], p[4]);
+			break;
+		case ATAG_INITRD2:
+			sprintf(buf,"INITRD2 %ldK@0x%lx\n", p[3] / 1024, p[2]);
+			break;
+		case ATAG_SERIAL:
+			sprintf(buf,"SERIAL high=0x%08lx low=0x%08lx\n",
+				p[3], p[2]);
+			break;
+		case ATAG_REVISION:
+			sprintf(buf,"REVISION rev=%ld\n", p[2]);
+			break;
+		case ATAG_VIDEOLFB:
+			sprintf(buf,"VIDEOLFB sz=%ld\n", p[0]);
+			break;
+		case ATAG_CMDLINE:
+			sprintf(buf,"CMD  \"%s\"\n", (char *)&p[2]);
+			break;
+		case ATAG_NONE:
+			sprintf(buf,"NONE\n");
+			keep_doing = 0;
+			break;
+		default:
+			sprintf(buf,"-unknown- sz=%ld\n", p[0]);
+			break;
+		}
+
+		/* carefully add to page */
+		if ((strlen(buf) + strlen(page)) < PAGE_SIZE) {
+			strcat(page, buf);
+		} else {
+			keep_doing = 0;
+		}
+
+		/* stop when we encounter a header length of 0 */
+		if (p[0] == 0)
+			keep_doing = 0;
+
+		/* go to the next tag */
+		p += p[0];
+
+		/* stop if we walked off the end of the buffer */
+		if (p > (unsigned long *)(kexec_boot_params +
+					  KEXEC_BOOT_PARAMS_SIZE))
+			keep_doing = 0;
+
+	} while (keep_doing);
+
+	return (strlen(page));
+}
+KERNEL_ATTR_RO(kexec_boot_params);
+
 static ssize_t kexec_loaded_show(struct kset *kset, char *page)
 {
 	return sprintf(page, "%d\n", !!kexec_image);
@@ -73,6 +232,8 @@ static struct attribute * kernel_attrs[]
 #ifdef CONFIG_KEXEC
 	&kexec_loaded_attr.attr,
 	&kexec_crash_loaded_attr.attr,
+	&kexec_cmdline_attr.attr,
+	&kexec_boot_params_attr.attr,
 #endif
 	NULL
 };
