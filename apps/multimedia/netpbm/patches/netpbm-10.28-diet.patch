--- netpbm-10.28/pm_config.h.diet	2005-07-04 22:04:21.000000000 +0200
+++ netpbm-10.28/pm_config.h	2005-07-04 22:04:21.000000000 +0200
@@ -0,0 +1,353 @@
+/* pm_config.h GENERATED BY A MAKE RULE */
+#ifndef PM_CONFIG_H
+#define PM_CONFIG_H
+/* This was generated by the program 'typegen' */
+#ifndef INTTYPES_H_NETPBM
+#define INTTYPES_H_NETPBM
+typedef unsigned int uint32_t;
+typedef signed int int32_t;
+typedef signed int int_fast32_t;
+typedef unsigned int uint_fast32_t;
+#endif
+#define HAVE_INT64 0
+/* pm_config.h.in FOLLOWS ... */
+/**************************************************************************
+                               NETPBM
+                           pm_config.in.h
+***************************************************************************
+  This file provides platform-dependent definitions for all Netpbm
+  libraries and the programs that use them.
+
+  The make files generate pm_config.h by copying this file and adding
+  other stuff.  The Netpbm programs #include pm_config.h.
+
+  Wherever possible, Netpbm handles customization via the make files
+  instead of via this file.  However, Netpbm's make file philosophy
+  discourages lining up a bunch of -D options on every compile, so a 
+  #define here would be preferable to a -D compile option.
+
+**************************************************************************/
+
+#if defined(USG) || defined(SVR4) || defined(VMS) || defined(__SVR4)
+#define SYSV
+#endif
+#if !( defined(BSD) || defined(SYSV) || defined(MSDOS) || defined(__amigaos__))
+/* CONFIGURE: If your system is >= 4.2BSD, set the BSD option; if you're a
+** System V site, set the SYSV option; if you're IBM-compatible, set MSDOS;
+** and if you run on an Amiga, set AMIGA. If your compiler is ANSI C, you're
+** probably better off setting SYSV - all it affects is string handling.
+*/
+#define BSD
+/* #define SYSV */
+/* #define MSDOS */
+#endif
+
+/* Switch macros like _POSIX_SOURCE are supposed to add features from
+   the indicated standard to the C library.  A source file defines one
+   of these macros to declare that it uses features of that standard
+   as opposed to conflicting features of other standards (e.g. the
+   POSIX foo() subroutine might do something different from the X/Open
+   foo() subroutine).  Plus, this forces the coder to understand upon
+   what feature sets his program relies.
+
+   But some C library developers have misunderstood this and think of these
+   macros like the old __ansi__ macro, which tells the C library, "Don't 
+   have any features that aren't in the ANSI standard."  I.e. it's just
+   the opposite -- the macro subtracts features instead of adding them.
+
+   This means that on some platforms, Netpbm programs must define
+   _POSIX_SOURCE, and on others, it must not.  Netpbm's POSIX_IS_IMPLIED 
+   macro indicates that we're on a platform where we need not define
+   _POSIX_SOURCE (and probably must not).
+
+   The problematic C libraries treat _XOPEN_SOURCE the same way.
+*/
+#if defined(__OpenBSD__) || defined (__NetBSD__) || defined(__bsdi__) || defined(__APPLE__)
+#define POSIX_IS_IMPLIED
+#endif
+
+
+/* NOTE: do not use "bool" as a type in an external interface.  It could
+   have different definitions on either side of the interface.  Even if both
+   sides include this interface header file, the conditional compilation
+   here means one side may use the typedef below and the other side may
+   use some other definition.  For an external interface, be safe and just
+   use "int".
+*/
+
+/* We used to assume that if TRUE was defined, then bool was too.
+   However, we had a report on 2001.09.21 of a Tru64 system that had
+   TRUE but not bool and on 2002.03.21 of an AIX 4.3 system that was
+   likewise.  So now we define bool all the time, unless the macro
+   HAVE_BOOL is defined.  If someone is using the Netpbm libraries and
+   also another library that defines bool, he can either make the
+   other library define/respect HAVE_BOOL or just define HAVE_BOOL in
+   the file that includes pm_config.h or with a compiler option.  Note
+   that C++ always has bool.  
+
+   A preferred way of getting booleans is <stdbool.h>.  But it's not
+   available on all platforms, and it's easy to reproduce what it does
+   here.
+*/
+#ifndef TRUE
+  #define TRUE 1
+  #endif
+#ifndef FALSE
+  #define FALSE 0
+  #endif
+/* C++ has a bool type and false and true constants built in. */
+#ifndef __cplusplus
+  #ifndef HAVE_BOOL
+    #define HAVE_BOOL 1
+    typedef int bool;
+    #endif
+  #ifndef true
+    enum boolvalue {false=0, true=1};
+    #endif
+  #endif
+
+/* CONFIGURE: If you have an X11-style rgb color names file, define its
+** path here.  This is used by PPM to parse color names into rgb values.
+** If you don't have such a file, comment this out and use the alternative
+** hex and decimal forms to specify colors (see ppm/pgmtoppm.1 for details).  */
+/* There was some evidence before Netpbm 9.1 that the rgb database macros
+   might be already set right now.  I couldn't figure out how, so I changed
+   their meanings and they are now set unconditionally.  -Bryan 00.05.03.
+*/
+#ifdef VMS
+#define RGB_DB1 "PBMplus_Dir:RGB.TXT"
+#define RGB_DB2 "PBMplus_Dir:RGB.TXT"
+#define RGB_DB3 "PBMplus_Dir:RGB.TXT"
+#else
+#define RGB_DB1 "/usr/lib/X11/rgb.txt"
+#define RGB_DB2 "/usr/openwin/lib/rgb.txt"
+#define RGB_DB3 "/usr/X11R6/lib/X11/rgb.txt"
+#endif
+
+/* CONFIGURE: This is the name of an environment variable that tells
+** where the color names database is.  If the environment variable isn't
+** set, Netpbm tries the hardcoded defaults set above.
+*/
+#define RGBENV "RGBDEF"    /* name of env-var */
+
+/* CONFIGURE: Normally, PPM handles a pixel as a struct of three grays.
+** If grays are represented as chars, that's 24 bits per color pixel; if
+** grays are represented as ints, that's usually 96 bits per color pixel.  PPM
+** can be modified to pack the three samples into a single longword,
+** 10 bits each, for 32 bits per pixel.
+**
+** If you don't need more than 10 bits for each color component, AND
+** you care more about memory use than speed, then this option might
+** be a win.  Under these circumstances it will make some of the
+** programs use 3 times less space, but all of the programs will run
+** slower.  In one test, it was 1.4 times slower.
+** 
+*/
+/* #define PPM_PACKCOLORS */
+
+/* CONFIGURE: uncomment this to enable debugging checks. */
+/* #define DEBUG */
+
+#if (defined(SYSV) || defined(__amigaos__))
+
+#include <string.h>
+/* Before Netpbm 9.1, rand and srand were macros for random and
+   srandom here.  This caused a failure on a SunOS 5.6 system, which
+   is SYSV, but has both rand and random declared (with different
+   return types).  The macro caused the prototype for random to be a
+   second prototype for rand.  Before 9.1, Netpbm programs called
+   random() and on a SVID system, that was really a call to rand().
+   We assume all modern systems have rand() itself, so now Netpbm
+   always calls rand() and if we find a platform that doesn't have
+   rand(), we will add something here for that platform.  -Bryan 00.04.26
+#define random rand
+#define srandom(s) srand(s)
+extern void srand();
+extern int rand();
+*/
+/* Before Netpbm 9.15, there were macro definitions of index() and 
+   rindex() here, but there are no longer any invocations of those 
+   functions in Netpbm, except in the VMS-only code, so there's no
+   reason for them.
+*/
+
+#ifndef __SASC
+#ifndef _DCC    /* Amiga DICE Compiler */
+#define bzero(dst,len) memset(dst,0,len)
+#define bcopy(src,dst,len) memcpy(dst,src,len)
+#define bcmp memcmp
+#endif /* _DCC */
+#endif /* __SASC */
+
+#endif /*SYSV or Amiga*/
+
+/* We should change all of Netpbm to use uint32_t instead of uint32n,
+   because we now have a strategy for ensuring that uint32_t is defined.
+   But we're going to wait a while in case our uint32_t strategy doesn't
+   work.  04.08.24.
+*/
+typedef uint32_t uint32n;
+typedef int32_t int32n;
+
+#include <fcntl.h>
+#include <time.h>
+#include <stdlib.h>
+#include <unistd.h>
+/* 
+   Before Netpbm 9.0, atoi() and exit() were declared for everybody
+   except MSDOS and Amiga, and time() and write() were declared for
+   everybody except MSDOS, Amiga, and __osf__.  fcntl.h, time.h, and
+   stlib.h were included for MSDOS and Amiga, and unistd.h was included
+   for everyone except VMS, MSDOS, and Amiga.  With the netbsd patches,
+   atoi(), exit(), time(), and write() were not declared for __NetBSD__.
+
+   We're hoping that all current systems have the standard header
+   files, and will reinstate some of these explicit declarations if we
+   hear otherwise.  
+
+   If it turns out to be this easy, we should just move these inclusions
+   to the source files that actually need them.
+   
+   -Bryan 2000.04.13
+
+extern int atoi();
+extern void exit();
+extern long time();
+extern int write(); 
+*/
+
+/* CONFIGURE: On most BSD systems, malloc() gets declared in stdlib.h, on
+** system V, it gets declared in malloc.h. On some systems, malloc.h
+** doesn't declare these, so we have to do it here. On other systems,
+** for example HP/UX, it declares them incompatibly.  And some systems,
+** for example Dynix, don't have a malloc.h at all.  A sad situation.
+** If you have compilation problems that point here, feel free to tweak
+** or remove these declarations.
+*/
+#ifdef BSD
+#include <stdlib.h>
+#endif
+#if (defined(SYSV) && !defined(VMS))
+#include <malloc.h>
+#endif
+/* extern char* malloc(); */
+/* extern char* realloc(); */
+/* extern char* calloc(); */
+
+/* CONFIGURE: Some systems don't have vfprintf(), which we need for the
+** error-reporting routines.  If you compile and get a link error about
+** this routine, uncomment the first define, which gives you a vfprintf
+** that uses the theoretically non-portable but fairly common routine
+** _doprnt().  If you then get a link error about _doprnt, or
+** message-printing doesn't look like it's working, try the second
+** define instead.
+*/
+/* #define NEED_VFPRINTF1 */
+/* #define NEED_VFPRINTF2 */
+
+/* CONFIGURE: Some systems don't have strstr(), which some routines need.
+** If you compile and get a link error about this routine, uncomment the
+** define, which gives you a strstr.
+*/
+/* #define NEED_STRSTR */
+
+/* CONFIGURE: Set this option if your compiler uses strerror(errno)
+** instead of sys_errlist[errno] for error messages.
+*/
+#define A_STRERROR
+
+/* CONFIGURE: If your system has the setmode() function, set HAVE_SETMODE.
+** If you do, and also the O_BINARY file mode, pm_init() will set the mode
+** of stdin and stdout to binary for all Netpbm programs.
+** You need this with Cygwin (Windows).
+*/
+#ifdef __CYGWIN__
+#define HAVE_SETMODE
+#endif
+
+/* #define HAVE_SETMODE */
+
+#ifdef __amigaos__
+#include <clib/exec_protos.h>
+#define getpid() ((pid_t)FindTask(NULL))
+#endif
+
+#ifdef DJGPP
+#define HAVE_SETMODE
+#define lstat stat
+#endif /* DJGPP */
+
+/*  CONFIGURE: Netpbm uses __inline__ to declare functions that should
+    be compiled as inline code.  GNU C recognizes the __inline__ keyword.
+    If your compiler recognizes any other keyword for this, you can set
+    it here.
+*/
+#if !defined(__GNUC__)
+  #if (!defined(__inline__))
+    #if (defined(__sgi) || defined(_AIX))
+      #define __inline__ __inline
+    #else   
+      #define __inline__
+    #endif
+  #endif
+#endif
+
+/* CONFIGURE: Some systems seem to need more than standard program linkage
+   to get a data (as opposed to function) item out of a library.
+
+   On Windows mingw systems, it seems you have to #include <import_mingw.h>
+   and #define EXTERNDATA DLL_IMPORT  .  2001.05.19
+*/
+#define EXTERNDATA extern
+
+/* only Pnmstitch uses UNREFERENCED_PARAMETER today (and I'm not sure why),
+   but it might come in handy some day.
+*/
+#if (!defined(UNREFERENCED_PARAMETER))
+# if (defined(__GNUC__))
+#  define UNREFERENCED_PARAMETER(x)
+# elif (defined(__USLC__) || defined(_M_XENIX))
+#  define UNREFERENCED_PARAMETER(x) ((x)=(x))
+# else
+#  define UNREFERENCED_PARAMETER(x) (x)
+# endif
+#endif
+
+/* In GNU, _LFS_LARGEFILE means the "off_t" functions (ftello, etc.) are
+   available.  In AIX, _AIXVERSION_430 means it's AIX Version 4.3.0 or
+   better, which seems to mean the "off_t" functions are available.
+*/
+#if defined(_LFS_LARGEFILE) || defined(_AIXVERSION_430)
+typedef off_t pm_filepos;
+#define FTELLO ftello
+#define FSEEKO fseeko
+#else
+typedef long int pm_filepos;
+#define FTELLO ftell
+#define FSEEKO fseek
+#endif
+
+#if defined(_PLAN9)
+#define TMPDIR "/tmp"
+#else
+/* Use POSIX value P_tmpdir from libc */
+#define TMPDIR P_tmpdir
+#endif
+/* This was generated by the program 'endiangen' */
+
+/* LITTLE_ENDIAN, BIG_ENDIAN, and BYTE_ORDER may come from the C library
+via ctype.h. */
+#include <ctype.h>
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+
+#define BITS_PER_WORD 32
+#endif
--- netpbm-10.28/editor/Makefile.diet	2005-04-25 03:55:39.000000000 +0200
+++ netpbm-10.28/editor/Makefile	2005-07-04 22:32:41.000000000 +0200
@@ -17,7 +17,7 @@
 PORTBINARIES = pamcomp pamcut pamdeinterlace pamdice pamditherbw pamedge \
 	       pamenlarge \
 	       pamflip pamfunc pammasksharpen pamoil pamperspective pampop9 \
-	       pamscale pamstretch \
+	       pamstretch \
 	       pbmclean pbmlife pbmmask pbmpscale pbmreduce \
 	       pgmabel pgmbentley pgmenhance pgmmorphconv \
 	       pnmalias pnmcat pnmcomp pnmconvol pnmcrop pnmcut \
@@ -25,7 +25,7 @@
 	       pnmhisteq pnmindex pnminvert pnmmontage \
 	       pnmnlfilt pnmnorm pnmpad pnmpaste \
 	       pnmremap pnmrotate \
-	       pnmscale pnmscalefixed pnmshear pnmsmooth pnmstitch pnmtile \
+	       pnmscale pnmshear pnmsmooth pnmstitch pnmtile \
 	       ppm3d ppmbrighten ppmchange ppmcolormask \
 	       ppmdim ppmdist ppmdither ppmflash ppmglobe ppmlabel ppmmix \
 	       ppmntsc ppmrelief ppmshift ppmspread ppmtv
--- netpbm-10.28/analyzer/Makefile.diet	2004-02-08 03:04:18.000000000 +0100
+++ netpbm-10.28/analyzer/Makefile	2005-07-04 22:04:21.000000000 +0200
@@ -15,8 +15,8 @@
 # build.
 
 PORTBINARIES = pamfile pamslice pamsumm \
-               pgmhist pnmhistmap ppmhist pgmminkowski
-MATHBINARIES = pamsharpmap pamsharpness pgmtexture pnmpsnr 
+               pgmhist pnmhistmap ppmhist
+MATHBINARIES = pgmtexture pnmpsnr 
 
 BINARIES = $(PORTBINARIES) $(MATHBINARIES)
 SCRIPT =
--- netpbm-10.28/Makefile.config.diet	2005-07-04 22:04:21.000000000 +0200
+++ netpbm-10.28/Makefile.config	2005-07-04 22:04:21.000000000 +0200
@@ -0,0 +1,603 @@
+####This file was automatically created by 'configure.'
+####Many variables are set twice -- a generic setting, then 
+####a system-specific override at the bottom of the file.
+####
+# This is a make file inclusion, to be included in all the Netpbm make
+# files.
+
+# This file is meant to contain variable settings that customize the
+# build for a particular target system configuration.
+
+# The distribution contains the file Makefile.config.in.  You edit
+# Makefile.config.in in ways relevant to your particular environment 
+# to create Makefile.config.  The "configure" program will do this
+# for you in simple cases.
+
+# Some of the variables that the including make file must set for this
+# file to work:
+#
+#  SRCDIR: The directory at the top of the Netpbm source tree.  Note that
+#  this is typically a relative directory, and it must be relative to the
+#  make file that includes this file.
+
+DEFAULT_TARGET = nonmerge
+#DEFAULT_TARGET = merge
+
+# Fiasco has some special requirements that make it fail to compile on
+# some systems, and since it isn't very important, just set this to "N"
+# and skip it on those systems unless you want to debug it and fix it.
+# OpenBSD:
+#BUILD_FIASCO = N
+BUILD_FIASCO = N
+
+# The following are commands for the build process to use.  These values
+# do not get built into anything.
+
+# The C compiler (including macro preprocessor)
+#CC = gcc
+# Note that 'cc' is usually an alias for whatever is the main compiler
+# on a system, e.g. the GNU Compiler on Linux.
+CC = i386-dietlibc-linux-gcc
+
+# The linker.
+LD = $(CC) -static
+#LD = ld
+#Tru64:
+#LD = cc
+#LD = gcc 
+
+#If the linker identified above is a compiler that invokes a linker
+#(as in 'cc foo.o -o foo'), set LINKERISCOMPILER.  The main difference is
+#that we expect a compiler to take linker options in the '-Wl,-opt1,val1'
+#syntax whereas the actual linker would take '-opt1 val1'.
+LINKERISCOMPILER=Y
+#If $(LD) is 'ld':
+#LINKERISCOMPILER=N
+
+#LINKER_CAN_DO_EXPLICIT_LIBRARY means the linker specified above can
+#take a library as just another link object argument, as in 'ld
+#pnmtojpeg.o /usr/local/lib/libjpeg.so ...'  as opposed to requiring a
+#-l option as in 'ld pnmtojpeg.o -L/usr/local/lib -l jpeg'.
+#This variable controls how 'libopt' gets built.  Note that with some
+#linkers, you can specify a shared library explicitly, but then it has
+#to live in that exact place at run time.  That's not good enough for us.
+
+LINKER_CAN_DO_EXPLICIT_LIBRARY=N
+#GNU:
+#LINKER_CAN_DO_EXPLICIT_LIBRARY=Y
+
+# This is the name of the header file that declares the types
+# uint32_t, etc.  This name is used as #include $(INTTYPES_H)  .
+# Set to null if the types come automatically without including anything.
+INTTYPES_H = "inttypes_netpbm.h"
+#INTTYPES_H = <inttypes.h>
+# Linux libc5:
+#INTTYPES_H = <types.h>
+# Solaris:
+#INTTYPES_H = <sys/inttypes.h>
+# Others:
+#INTTYPES_H = <sys/stdint.h>
+#INTTYPES_H = <sys/types.h>
+# The automatically generated Netpbm version:
+
+# HAVE_INT64 tells whether, assuming you include the header indicated by
+# INTTYPES_H, you have the int64_t type and related stuff.  (If you don't
+# the build will omit certain code that does 64 bit computations).
+HAVE_INT64 = Y
+#HAVE_INT64 = N
+
+# CC and LD are for building the Netpbm programs, which are not necessarily
+# intended to run on the same system on which Make is running.  But when we 
+# build a build tool such as Libopt, it is meant to run only on the same 
+# system on which the Make is running.  The variables below define programs
+# to use to compile and link build tools.
+CC_FOR_BUILD = $(CC)
+LD_FOR_BUILD = $(LD) 
+
+# MAKE is set automatically by Make to what was used to invoke Make.
+
+INSTALL = $(SRCDIR)/buildtools/install.sh
+#Solaris:
+#INSTALL = /usr/ucb/install
+#Tru64:
+#INSTALL = installbsd
+#OSF1:
+#INSTALL = $(SRCDIR)/buildtools/installosf
+#Red Hat Linux:
+#INSTALL = install
+
+# STRIPFLAG is the option you pass to the above install program to make it
+# strip unnecessary information out of binaries.
+STRIPFLAG = -s
+# If you don't want to strip the binaries, just leave it null:
+#STRIPFLAG = 
+
+SYMLINK = ln -s
+# At least some Windows environments don't have any concept of symbolic
+# links, but direct copies are usually a passable alternative.
+#SYMLINK = cp
+
+#MANPAGE_FORMAT is "nroff" or "cat".  It determines in what format the
+#pointer man pages are installed (ready to nroff, or ready to cat).  
+#A pointer man pages is just a single-paragraph pages that tells you there is
+#no man page for the program, to look at the HTML documentation instead.
+MANPAGE_FORMAT = nroff
+#MANPAGE_FORMAT = cat
+
+AR = ar
+RANLIB = ranlib
+# IRIX, SCO don't have Ranlib:
+#RANLIB = true
+LEX = flex
+# Solaris:
+# LEX = flex -e
+# Or just skip parts that need Lex:
+# LEX =
+
+# C compiler options 
+CFLAGS=-D_BSD_SOURCE -D_GNU_SOURCE
+# gcc:
+# -ansi and -Werror should work too, but are not included
+# by default because there's no point in daring the build to fail.
+# -pedantic isn't a problem because it causes at worst a warning.
+#CFLAGS = -O3 -fast-math -pedantic \
+#          -Wall -Wno-uninitialized -Wmissing-declarations
+# The merged programs have a main_XXX subroutine instead of main(),
+# which would cause a warning with -Wmissing-declarations or 
+# -Wmissing-prototypes.
+#CFLAGS_MERGE = -Wno-missing-declarations -Wno-missing-prototypes
+# A user of DEC Tru64 4.0F in May 2000 needed -DLONG_32 for ppmtompeg,
+# but word size-sensitive code was removed from parallel.c in September 2004.
+# A user of Tru64 5.1A in July 2003 needed NOT to have -DLONG_32.  In
+# theory, you need this if on your system, long is 32 bits and int is not.
+# But it may be completely irrelevant today.
+#Tru64:
+#CFLAGS = -O2 -std1 -DLONG_32
+#CFLAGS = -O2 -std1
+#AIX:
+#CFLAGS= -O3
+#HP-UX:
+#CFLAGS= -O3 -fPIC
+#IRIX:
+#CFLAGS= -n32 -O3
+#Amiga with GNU compiler:
+#CFLAGS= -m68020-60 -ffast-math -mstackextend 
+# You can add -noixemul for Amiga and successfully compile most of the 
+# programs.  (Of the remaining ones, if you can supply your own strtod() 
+# function, most of them will build with -noixemul).  So try building 
+# with 'make --keep-going CADD=-noixemul' first, then just 'make' to build
+# everything that failed for lack of the ixemul library in the first step.
+# That way, the parts that don't required the ixemul library won't indicate
+# a dependency on it.
+#OpenBSD:
+#CFLAGS = -I/usr/local/include
+
+# EXE is a suffix that the linker puts on any executable it generates.
+# In cygwin, this is .exe and most programs deal with its existence without
+# us having to know about it.  Some don't though, so set this:
+
+EXE =
+#Cygwin, DJGPP/Windows:
+#EXE = .exe
+  
+# linker options.  
+
+# LDFLAGS is often set as an environment variable;  A setting here overrides
+# it.  So either make sure you want to override it, or do a "LDFLAGS +=" here.
+
+# Eunice users may want to use -noshare so that the executables can
+# run standalone:
+#LDFLAGS += -noshare
+#Tru64:
+# Russ Allberry says on 2001.06.09 that -oldstyle_liblookup may be necessary
+# to keep from finding an ancient system libjpeg.so that isn't compatible with
+# NetPBM.  Michael Long found that /usr/local/lib is not in the default
+# search path, or not soon enough, and he was getting an old libjpeg that
+# caused all the jpeg symbol references to be unresolved.  He had installed
+# a new libjpeg in /usr/local/lib.
+#LDFLAGS += -call_shared -oldstyle_liblookup -L/usr/local/lib
+#AIX:
+#LDFLAGS += -L /usr/pubsw/lib
+#HP-UX:
+#LDFLAGS += -Wl,+b,/usr/pubsw/lib
+#IRIX:
+#LDFLAGS += -n32
+#FreeBSD, OpenBSD:
+# (04.03.15 This may be a mistake.  LDFLAGS may already be set to this as
+#  an environment variable.  We used to override the environment variable
+#  here with LDFLAGS =, which would mean we had to override with the same 
+#  value it already had.  I suspect it will work fine with no LDFLAGS
+#  setting at all; need to confirm this on real FreeBSD and OpenBSD systems)
+#LDFLAGS += -L/usr/local/lib
+
+# Linker options for created Netpbm shared libraries.
+
+# Here, $(SONAME) resolves to the soname for the shared library being created.
+# The following are gcc options.  This works on GNU libc systems.
+LDSHLIB = -shared -Wl,-soname,$(SONAME)
+# You need -nostart instead of -shared on BeOS.  Though the BeOS compiler is
+# ostensibly gcc, it has the -nostart option, which is not mentioned in gcc
+# documentation and doesn't exist in at least one non-BeOS installation.
+# BeOS doesn't have sonames built in.
+#LDSHLIB = -nostart
+#LDSHLIB = -G
+# Solaris, SunOS with GNU Ld, SCO:
+# These systems have no soname option.
+#LDSHLIB = -shared
+# Solaris with Sun Ld:
+#LDSHLIB = -Wl,-Bdynamic,-G,-h,$(SONAME) 
+#Tru64:
+#LDSHLIB = -shared -expect_unresolved "*"
+#IRIX:
+#LDSHLIB = -shared -n32
+#AIX GNU compiler/linker:
+#LDSHLIB = -shared
+#AIX Visual Age C:
+#LDSHLIB = -qmkshrobj
+
+# LDRELOC is the command to combine two .o files (relocateable object files)
+# into a single .o file that can later be linked into something else.  NONE
+# means no such command is available.
+
+LDRELOC = NONE
+# GNU Ld:
+# Older GNU Ld misspells the option as --relocateable.  Newer GNU Ld
+# correctly spells it --relocatable.  The abbreviation --reloc works on
+# both.
+#LDRELOC = ld --reloc
+#LDRELOC = ld -r
+
+
+# On older systems, you have to make shared libraries out of position
+# independent code, so you need -fpic or fPIC here.  (The rule is: if
+# -fpic works, use it.  If it bombs, go to fPIC).  On newer systems,
+# it isn't necessary, but can save real memory at the expense of
+# execution speed.  Without position independent code, the library
+# loader may have to patch addresses into the executable text.  On an
+# older system, this would cause a program crash because the loader
+# would be writing into read-only shared memory.  But on newer
+# systems, the system silently creates a private mapping of the page
+# or segment being modified (the "copy on write" phenomenon).  So it
+# needs its own private real page frame.  In one experiment, A second
+# copy of Pbmtext used 16K less real memory when built with -fpic than
+# when built without.  2001.06.02.
+
+# We have seen -fPIC required on IA64 and AMD64 machines (GNU
+# compiler/linker).  Build-time linking fails without it.  I don't
+# know why -- history seems to be repeating itself.  2005.02.23.
+
+CFLAGS_SHLIB = 
+# Solaris or SunOS with gcc, and NetBSD:
+#CFLAGS_SHLIB = -fpic
+#CFLAGS_SHLIB = -fPIC
+# Sun compiler:
+#CFLAGS_SHLIB = -Kpic
+#CFLAGS_SHLIB = -KPIC
+
+# SHLIB_CLIB is the link option to include the C library in a shared library,
+# normally "-lc".  On typical systems, this serves no purpose.  On some,
+# though, it causes information about which C library to use to be recorded
+# in the shared library and thus choose the correct library among several or
+# avoid using an incompatible one.  But on some systems, the link fails.
+# On 2002.09.30, "John H. DuBois III" <spcecdt@armory.com> reports that on 
+# SCO OpenServer, he gets the following error message with -lc:
+#
+#  -lc; relocations referenced  ;  from file(s) /usr/ccs/lib/libc.so(random.o);
+#   fatal error: relocations remain against allocatable but non-writable 
+#   section: ; .text
+
+SHLIB_CLIB = -lc
+# SCO:
+SHLIB_CLIB =
+
+# On some systems you have to build into an executable the list of
+# directories where its dynamically linked libraries can be found at
+# run time.  This is typically done with a -R or -rpath linker
+# option.  Even on systems that don't require it, you might prefer to do
+# that rather than set up environment variables or configuration files
+# to tell the system where the libraries are.  A "Y" here means to put
+# the directory information in the executable at link time.
+
+NEED_RUNTIME_PATH = N
+# Solaris, SunOS, NetBSD, AIX:
+#NEED_RUNTIME_PATH = Y
+
+# RPATHOPTNAME is the option you use on the link command to specify
+# a runtime search path for a shared library.  It is meaningless unless
+# NEED_RUNTIME_PATH is Y.
+RPATHOPTNAME = -rpath
+
+# The following variables tell where your various libraries on which
+# Netpbm depends live.  The LIBxxx variable is a full file
+# specification of the link library (not necessarily the library used
+# at run time).  e.g. "/usr/local/lib/graphics/libpng.so".  It usually
+# doesn't matter if the library prefix and suffix are right -- you can
+# use "lib" and ".so" or ".a" regardless of what your system actually
+# uses because these just turn into "-L" and "-l" linker options
+# anyway.  ".a" implies a static library for some purposes, though.
+# If you don't have the library in question, use a value of NONE for
+# LIBxxx and the build will simply skip the programs that require that
+# library.  If the library is in your linker's (or the Netpbm build's)
+# default search path, leave off the directory part, e.g. "libpng.so".
+
+# The xxxHDR_DIR variable is the directory in which the interface
+# headers for the library live (e.g. /usr/include).  If they are in your
+# compiler's default search path, set this variable to null.
+
+# This is where the Netpbm shared libraries will reside when Netpbm is
+# fully installed.  In some configurations, the Netpbm builder builds
+# this information into the Netpbm executables.  This does NOT affect
+# where the Netpbm installer installs the libraries.  A null value
+# means the libraries are in a default search path used by the runtime
+# library loader.
+NETPBMLIB_RUNTIME_PATH = 
+#NETPBMLIB_RUNTIME_PATH = /usr/lib/netpbm
+
+# The TIFF library.  See above.  If you want to build the tiff
+# converters, you must have the tiff library already installed.
+
+TIFFLIB = NONE
+TIFFHDR_DIR =
+
+#TIFFLIB = libtiff.so
+#TIFFHDR_DIR = /usr/include/libtiff
+#NetBSD:
+#TIFFLIB = $(LOCALBASE)/lib/libtiff.so
+#TIFFHDR_DIR = $(LOCALBASE)/include
+# OSF, Tru64:
+#TIFFLIB = /usr/local1/DEC/lib/libtiff.so
+#TIFFHDR_DIR = /usr/local1/DEC/include
+
+# Some TIFF libraries do Jpeg and/or Z (flate) compression and thus any
+# program linked with the TIFF library needs a Jpeg and/or Z library.
+# Some TIFF libraries have such library statically linked in, but others
+# need it to be dynamically linked at program load time.
+# Make this 'N' if youf TIFF library doesn't need such dynamic linking.
+# As of 2005.01, the most usual build of the TIFF library appears to require
+# both.
+TIFFLIB_NEEDS_JPEG = Y
+TIFFLIB_NEEDS_Z = Y
+
+# The JPEG library.  See above.  If you want to build the jpeg
+# converters you must have the jpeg library already installed.
+
+# Tiff files can use JPEG compression, so the Tiff library can reference
+# the JPEG library.  If your Tiff library references a dynamic JPEG 
+# library, you must specify at least JPEGLIB here, or the Tiff
+# converters will not build.  Note that your Tiff library may have the
+# JPEG stuff statically linked in, in which case you won't need 
+# JPEGLIB in order to build the Tiff converters.
+
+JPEGLIB = NONE
+JPEGHDR_DIR =
+#JPEGLIB = libjpeg.so
+#JPEGHDR_DIR = /usr/include/jpeg
+# Netbsd:
+#JPEGLIB = ${LOCALBASE}/lib/libjpeg.so
+#JPEGHDR_DIR = ${LOCALBASE}/include
+# OSF, Tru64:
+#JPEGLIB = /usr/local1/DEC/libjpeg.so
+#JPEGHDR_DIR = /usr/local1/DEC/include
+# Typical:
+#JPEGLIB = /usr/local/lib/libjpeg.so
+#JPEGHDR_DIR = /usr/local/include
+# Don't build JPEG stuff:
+#JPEGLIB = NONE
+
+
+# The PNG library.  See above.  If you want to build the PNG
+# converters you must have the PNG library already installed.
+
+# The PNG library, by convention starting around April 2002, gets installed
+# with names that include a version number, such as libpng10.a and header
+# files in /usr/include/libpng10.
+# option.
+PNGLIB = NONE
+PNGHDR_DIR =
+PNGVER = 
+#PNGLIB = libpng$(PNGVER).so
+#PNGHDR_DIR = /usr/include/libpng$(PNGVER)
+# NetBSD:
+#PNGLIB = $(LOCALBASE)/lib/libpng$(PNGVER).so
+#PNGHDR_DIR = $(LOCALBASE)/include
+# OSF/Tru64:
+#PNGLIB = /usr/local1/DEC/lib/libpng$(PNGVER).so
+#PNGHDR_DIR = /usr/local1/DEC/include
+
+# The zlib compression library.  See above.  You need it to build
+# anything that needs the PNG library (see above).  If you selected
+# NONE for the PNG library, it doesn't matter what you specify here --
+# it won't get used.
+
+ZLIB = NONE
+ZHDR_DIR = 
+#ZLIB = libz.so
+
+# The JBIG lossless image compression library (aka JBIG-KIT):
+
+JBIGLIB = $(BUILDDIR)/converter/other/jbig/libjbig.a
+JBIGHDR_DIR = $(SRCDIR)/converter/other/jbig
+
+# The Jasper JPEG-2000 image compression library (aka JasPer):
+JASPERLIB = $(INTERNAL_JASPERLIB)
+JASPERHDR_DIR = $(INTERNAL_JASPERHDR_DIR)
+# JASPERDEPLIBS is the libraries (-l options or file names) on which
+# The Jasper library depends -- i.e. what you have to link into any
+# executable that links in the Jasper library.
+JASPERDEPLIBS =
+#JASPERDEPLIBS = -ljpeg
+
+# And the Utah Raster Toolkit (aka URT aka RLE) library:
+
+URTLIB = $(BUILDDIR)/urt/librle.a
+URTHDR_DIR = $(SRCDIR)/urt
+
+# The Linux SVGA library (Svgalib) is a facility for displaying graphics
+# on the Linux console.  It is required by Ppmsvgalib.
+
+LINUXSVGALIB = NONE
+LINUXSVGAHDR_DIR = 
+
+#LINUXSVGALIB_DIR = 
+#LINUXSVGAHDR_DIR = /usr/include/vgalib
+
+# If you don't want any network functions, set OMIT_NETWORK to "y".
+# The only thing that requires network functions is the option in
+# ppmtompeg to run it on multiple computers simultaneously.  On some
+# systems network functions don't work or we haven't figured out how to 
+# make them work, or they just aren't worth the effort.  
+OMIT_NETWORK =
+#DJGPP/Windows, Tru64:
+#   (there's some minor header problem that prevents network functions from 
+#   building on Tru64 2000.10.06)
+#OMIT_NETWORK = y
+
+# These are -l options to link in the network libraries.  Often, these are
+# built into the standard C library, so this can be null.  This is irrelevant
+# if OMIT_NETWORK is "y".
+
+NETWORKLD = 
+# Solaris, SunOS:
+#NETWORKLD = -lsocket -lnsl
+# SCO:
+#NETWORKLD = -lsocket, -lresolv
+
+VMS = 
+#VMS:
+#VMS = yes
+
+# The following variables are used only by 'make install' (and the
+# variants of it).  Paths here don't, for example, get built into any
+# programs.
+
+# This is where everything goes when you do 'make package', unless you
+# override it by setting 'pkgdir' on the Make command line.
+PKGDIR_DEFAULT = /tmp/netpbm
+
+# File permissions for installed files.
+# Note that on some systems (e.g. Solaris), 'install' can't use the 
+# mnemonic permissions - you have to use octal.
+
+# binaries (pbmmake, etc)
+INSTALL_PERM_BIN =  755       # u=rwx,go=rx
+# shared libraries (libpbm.so, etc)
+INSTALL_PERM_LIBD = 755       # u=rwx,go=rx
+# static libraries (libpbm.a, etc)
+INSTALL_PERM_LIBS = 644       # u=rw,go=r
+# header files (pbm.h, etc)
+INSTALL_PERM_HDR =  644       # u=rw,go=r
+# man pages (pbmmake.1, etc)
+INSTALL_PERM_MAN =  644       # u=rw,go=r
+# data files (pnmtopalm color maps, etc)
+INSTALL_PERM_DATA = 644       # u=rw,go=r
+
+# Specify the suffix that want the man pages to have.
+
+SUFFIXMANUALS1 = 1
+SUFFIXMANUALS3 = 3
+SUFFIXMANUALS5 = 5
+
+#NETPBMLIBTYPE tells the kind of libraries that will get built to hold the
+#Netpbm library functions.  The value is used only in make file tests.
+# "unixshared" means a unix-style shared library, typically named like 
+# libxyz.so.2.3
+NETPBMLIBTYPE = unixshared
+# "unixstatic" means a unix-style static library, (like libxyz.a)
+#NETPBMLIBTYPE = unixstatic
+# "dll" means a Windows DLL shared library
+#NETPBMLIBTYPE = dll
+# "dylib" means a Darwin/Mac OS shared library
+#NETPBMLIBTYPE = dylib
+
+#NETPBMLIBSUFFIX is the suffix used on whatever kind of library is 
+#selected above.  All this is used for is to construct library names.
+#The make files never examine the actual value.
+NETPBMLIBSUFFIX = so
+
+# "a" is the suffix for unix-style static libraries.  It is also
+# traditionally used for shared libraries on AIX.  The Visual Age C
+# manual says sometimes .so works on AIX, and GNU software for AIX
+# 5.1.0 does indeed use it.  In our experiments, it works fine if you
+# name the library file explicitly on the link, but isn't in the -l
+# search order.  If you name the library explicitly on the link, the
+# library must live in exactly the same position at run time, so we
+# can't use that.  Therefore, you cannot build both static and shared
+# libraries with AIX.  You have to choose.
+#NETPBMLIBSUFFIX = a
+# For HP-UX shared libraries:
+#NETPBMLIBSUFFIX = sl
+# Darwin/Mac OS shared library:
+#NETPBMLIBSUFFIX = dylib
+# Windows shared library:
+#NETPBMLIBSUFFIX = dll
+
+#STATICLIB_TOO is "y" to signify that you want a static library built
+#and installed in addition to whatever library type you specified by
+#NETPBMLIBTYPE.  If NETPBMLIBTYPE specified a static library,
+#STATICLIB_TOO simply has no effect.
+STATICLIB_TOO = y
+#STATICLIB_TOO = n
+
+#STATICLIBSUFFIX is the suffix that static libraries have.  It's
+#meaningless if you aren't building static libraries.
+STATICLIBSUFFIX = a
+
+#SHLIBPREFIXLIST is a blank-delimited list of prefixes that a filename
+#of a shared library may have on this system.  Traditionally, it's
+#just "lib", as in libc or libnetpbm.  On Windows, though, varying
+#prefixes are used when multiple alternative forms of a library are
+#available.  The first prefix in this list is what we use to name the
+#Netpbm shared libraries.
+#
+# This variable controls how 'libopt' gets built.
+#
+SHLIBPREFIXLIST = lib
+#Cygwin:
+#SHLIBPREFIXLIST = cyg lib
+
+NETPBMSHLIBPREFIX = $(firstword $(SHLIBPREFIXLIST))
+
+#DLLVER is used to version the DLLs built on cygwin or other
+#windowsish platforms.  We can't add this to LIBROOT, or we'd
+#version the static libs (which is bad).  We can't add this
+#at the end of the name (like unix does with so numbers) because
+#windows will only load dlls whose name ends in "dll".  So,
+#we have this variable, which becomes the end of the library "root" name
+#for DLLs only.
+#
+# This variable controls how 'libopt' gets built.
+#
+DLLVER =
+#Cygwin
+#DLLVER = $(NETPBM_MAJOR_RELEASE)
+
+#NETPBM_DOCURL is the URL of the main documentation page for Netpbm.
+#This is a directory which contains a file for each Netpbm program,
+#library, and file type.  E.g. The documentation for jpegtopnm might be in
+#http://netpbm.sourceforge.net/doc/jpegtopnm.html .  This value gets
+#installed in the man pages (which say no more than to read the webpage)
+#and in the Webman netpbm.url file.
+NETPBM_DOCURL = http://netpbm.sourceforge.net/doc/
+#For a system with no web access, but a local copy of the doc:
+#NETPBM_DOCURL = file:/usr/doc/netpbm/
+
+
+
+
+####Lines above were copied from Makefile.config.in by 'configure'.
+####Lines below were added by 'configure' based on the GNU platform.
+DEFAULT_TARGET = nonmerge
+NETPBMLIBTYPE=unixstatic
+NETPBMLIBSUFFIX=a
+STATICLIB_TOO=y
+CFLAGS = -O3 -ffast-math  -pedantic -Wall -Wno-uninitialized -Wmissing-declarations -Wimplicit -Wwrite-strings -Wmissing-prototypes
+CFLAGS_MERGE = -Wno-missing-declarations -Wno-missing-prototypes
+LDRELOC = ld --reloc
+LINKER_CAN_DO_EXPLICIT_LIBRARY=Y
+LINKERISCOMPILER = Y
+JPEGLIB = libjpeg.so
+PNGLIB = libpng.so
+ZLIB = libz.so
+NETPBM_DOCURL = http://netpbm.sourceforge.net/doc/
+INTTYPES_H = "inttypes_netpbm.h"
+HAVE_INT64 = N
--- netpbm-10.28/inttypes_netpbm.h.diet	2005-07-04 22:04:21.000000000 +0200
+++ netpbm-10.28/inttypes_netpbm.h	2005-07-04 22:04:21.000000000 +0200
@@ -0,0 +1,6 @@
+/* This was generated by the program 'typegen' */
+#ifndef INTTYPES_H_NETPBM
+#define INTTYPES_H_NETPBM
+typedef signed int int_fast32_t;
+typedef unsigned int uint_fast32_t;
+#endif
--- netpbm-10.28/converter/other/Makefile.diet	2005-07-04 22:04:18.000000000 +0200
+++ netpbm-10.28/converter/other/Makefile	2005-07-04 22:04:21.000000000 +0200
@@ -60,8 +60,8 @@
 PORTBINARIES =  bmptopnm fitstopnm \
 		gemtopnm giftopnm hdifftopam infotopam \
 		pamtodjvurle \
-		pamtohdiff pamtohtmltbl pamtopfm pamtopnm pamtouil \
-		pbmtopgm pfmtopam \
+		pamtohdiff pamtohtmltbl pamtopnm pamtouil \
+		pbmtopgm \
 	        pgmtopbm pgmtoppm ppmtopgm pnmtoddif pnmtofits \
 		pnmtopclxl \
 		pnmtosgi pnmtosir pamtotga pnmtoxwd pstopnm \
--- netpbm-10.28/converter/other/cameratopam/foveon.c.diet	2005-04-11 18:23:11.000000000 +0200
+++ netpbm-10.28/converter/other/cameratopam/foveon.c	2005-07-04 22:04:21.000000000 +0200
@@ -337,7 +337,7 @@
     return 1;
 }
 
-static float  foveon_avg (ushort *pix, int range[2], float cfilt)
+static float  foveon_avg (unsigned short *pix, int range[2], float cfilt)
 {
     int i;
     float val, min=FLT_MAX, max=-FLT_MAX, sum=0;
@@ -384,8 +384,8 @@
 
 static int  foveon_apply_curve (short *curve, int i)
 {
-    if (abs(i) >= (ushort)curve[0]) return 0;
-    return i < 0 ? -(ushort)curve[1-i] : (ushort)curve[1+i];
+    if (abs(i) >= (unsigned short)curve[0]) return 0;
+    return i < 0 ? -(unsigned short)curve[1-i] : (unsigned short)curve[1+i];
 }
 
 void  
--- netpbm-10.28/converter/other/cameratopam/canon.c.diet	2005-05-22 19:02:16.000000000 +0200
+++ netpbm-10.28/converter/other/cameratopam/canon.c	2005-07-04 22:04:21.000000000 +0200
@@ -11,7 +11,7 @@
 void 
 canon_600_load_raw(void) {
     unsigned char  data[1120], *dp;
-    ushort pixel[896], *pix;
+    unsigned short pixel[896], *pix;
     int irow, orow, col;
 
     for (irow=orow=0; irow < height; irow++)
@@ -44,7 +44,7 @@
 void
 canon_a5_load_raw(void) {
     unsigned char  data[1940], *dp;
-    ushort pixel[1552], *pix;
+    unsigned short pixel[1552], *pix;
     int row, col;
 
     for (row=0; row < height; row++) {
@@ -98,7 +98,7 @@
 
 void 
 canon_compressed_load_raw(void) {
-    ushort *pixel, *prow;
+    unsigned short *pixel, *prow;
     int lowbits, i, row, r, col, save, val;
     unsigned irow, icol;
     struct decode *decode, *dindex;
--- netpbm-10.28/converter/other/cameratopam/camera.c.diet	2005-04-11 18:23:36.000000000 +0200
+++ netpbm-10.28/converter/other/cameratopam/camera.c	2005-07-04 22:04:21.000000000 +0200
@@ -48,7 +48,7 @@
 
 
 static void  
-adobe_copy_pixel (int row, int col, ushort **rp, bool use_secondary)
+adobe_copy_pixel (int row, int col, unsigned short **rp, bool use_secondary)
 {
   unsigned r=row, c=col;
 
@@ -74,7 +74,7 @@
 {
   int save, twide, trow=0, tcol=0, jrow, jcol;
   struct jhead jh;
-  ushort *rp;
+  unsigned short *rp;
 
   while (1) {
     save = ftell(ifp);
@@ -109,7 +109,7 @@
 void
 adobe_dng_load_raw_nc()
 {
-    ushort *pixel, *rp;
+    unsigned short *pixel, *rp;
     int row, col;
 
     pixel = calloc (raw_width * tiff_samples, sizeof *pixel);
@@ -134,7 +134,7 @@
         5,4,3,6,2,7,1,0,8,9,11,10,12
     };
     int csize, row, col, i, diff;
-    ushort vpred[4], hpred[2], *curve;
+    unsigned short vpred[4], hpred[2], *curve;
 
     init_decoder();
     make_decoder (nikon_tree, 0);
@@ -290,7 +290,7 @@
 nikon_e2100_load_raw()
 {
   unsigned char   data[3432], *dp;
-  ushort pixel[2288], *pix;
+  unsigned short pixel[2288], *pix;
   int row, col;
 
   for (row=0; row <= height; row+=2) {
@@ -336,7 +336,7 @@
 void
 fuji_s2_load_raw()
 {
-  ushort pixel[2944];
+  unsigned short pixel[2944];
   int row, col, r, c;
 
   fseek (ifp, (2944*24+32)*2, SEEK_CUR);
@@ -353,7 +353,7 @@
 void
 fuji_s3_load_raw()
 {
-  ushort pixel[4352];
+  unsigned short pixel[4352];
   int row, col, r, c;
 
   fseek (ifp, (4352*2+32)*2, SEEK_CUR);
@@ -369,7 +369,7 @@
 
 static void  fuji_common_load_raw (int ncol, int icol, int nrow)
 {
-  ushort pixel[2048];
+  unsigned short pixel[2048];
   int row, col, r, c;
 
   for (row=0; row < nrow; row++) {
@@ -403,7 +403,7 @@
 void
 fuji_f700_load_raw()
 {
-  ushort pixel[2944];
+  unsigned short pixel[2944];
   int row, col, r, c, val;
 
   for (row=0; row < 2168; row++) {
@@ -448,7 +448,7 @@
 phase_one_load_raw()
 {
   int row, col, a, b;
-  ushort *pixel, akey, bkey;
+  unsigned short *pixel, akey, bkey;
 
   fseek (ifp, 8, SEEK_CUR);
   fseek (ifp, get4(ifp) + 296, SEEK_CUR);
@@ -474,7 +474,7 @@
 void
 ixpress_load_raw()
 {
-  ushort pixel[4090];
+  unsigned short pixel[4090];
   int row, col;
 
   order = 0x4949;
@@ -489,7 +489,7 @@
 void
 leaf_load_raw()
 {
-  ushort *pixel;
+  unsigned short *pixel;
   int r, c, row, col;
 
   pixel = calloc (raw_width, sizeof *pixel);
@@ -523,7 +523,7 @@
 void
 unpacked_load_raw()
 {
-  ushort *pixel;
+  unsigned short *pixel;
   int row, col;
 
   pixel = calloc (raw_width, sizeof *pixel);
@@ -540,13 +540,13 @@
 olympus_e300_load_raw()
 {
   unsigned char  *data,  *dp;
-  ushort *pixel, *pix;
+  unsigned short *pixel, *pix;
   int dwide, row, col;
 
   dwide = raw_width * 16 / 10;
   data = malloc (dwide + raw_width*2);
   merror (data, "olympus_e300_load_raw()");
-  pixel = (ushort *) (data + dwide);
+  pixel = (unsigned short *) (data + dwide);
   for (row=0; row < height; row++) {
     fread (data, 1, dwide, ifp);
     for (dp=data, pix=pixel; pix < pixel+raw_width; dp+=3, pix+=2) {
@@ -597,7 +597,7 @@
 casio_qv5700_load_raw()
 {
   unsigned char  data[3232],  *dp;
-  ushort pixel[2576], *pix;
+  unsigned short pixel[2576], *pix;
   int row, col;
 
   for (row=0; row < height; row++) {
@@ -617,7 +617,7 @@
 void
 nucore_load_raw()
 {
-  ushort *pixel;
+  unsigned short *pixel;
   int irow, row, col;
 
   pixel = calloc (width, 2);
@@ -816,7 +816,7 @@
     fread (pixel, 848, 1, ifp);
     shift = row * mul[row & 3] + add[row & 3];
     for (col=0; col < width; col++)
-      BAYER(row,col) = (ushort) pixel[(col + shift) % 848];
+      BAYER(row,col) = (unsigned short) pixel[(col + shift) % 848];
   }
   maximum = 0xff;
 }
@@ -855,7 +855,7 @@
     for (col=0; col < raw_width; col++) {
       icol = col - left_margin;
       if (icol < width)
-    BAYER(row,icol) = (ushort) curve[pixel[col]];
+    BAYER(row,icol) = (unsigned short) curve[pixel[col]];
       else
     black += curve[pixel[col]];
     }
@@ -872,7 +872,7 @@
 kodak_compressed_load_raw()
 {
   unsigned char c, blen[256];
-  ushort raw[6];
+  unsigned short raw[6];
   unsigned row, col, len, save, i, israw=0, bits=0, pred[2];
   INT64 bitbuf=0;
   int diff;
@@ -939,7 +939,7 @@
   unsigned row, col, len, bits=0;
   INT64 bitbuf=0;
   int i, li=0, si, diff, six[6], y[4], cb=0, cr=0, rgb[3];
-  ushort *ip;
+  unsigned short *ip;
 
   assert(have64BitArithmetic);
 
@@ -1012,7 +1012,7 @@
 sony_load_raw()
 {
   unsigned char head[40];
-  ushort *pixel;
+  unsigned short *pixel;
   unsigned i, key, row, col;
 
   fseek (ifp, 200896, SEEK_SET);
@@ -1080,7 +1080,7 @@
  */
 static void  ciff_block_1030()
 {
-  static const ushort key[] = { 0x410, 0x45f3 };
+  static const unsigned short key[] = { 0x410, 0x45f3 };
   int i, bpp, row, col, vbits=0;
   unsigned long bitbuf=0;
 
@@ -1113,7 +1113,7 @@
   static const int remap[] = { 1,2,3,4,5,1 };
   static const int remap_10d[] = { 0,1,3,4,5,6,0,0,2,8 };
   static const int remap_s70[] = { 0,1,2,9,4,3,6,7,8,9,10,0,0,0,7,0,0,8 };
-  ushort key[] = { 0x410, 0x45f3 };
+  unsigned short key[] = { 0x410, 0x45f3 };
 
   if (strcmp(model,"Canon PowerShot G6") &&
       strcmp(model,"Canon PowerShot S70") &&
@@ -1494,7 +1494,7 @@
   char software[64];
   static const int flip_map[] = { 0,1,3,2,4,6,7,5 };
   unsigned char cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
-  ushort scale[4];
+  unsigned short scale[4];
   double dblack, cc[4][4], cm[4][3];
   double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
 
