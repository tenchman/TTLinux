--- netqmail-1.06/Makefile.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/Makefile	2008-06-27 11:31:26.000000000 +0200
@@ -104,6 +104,14 @@ auto_usera.o: \
 compile auto_usera.c
 	./compile auto_usera.c
 
+base64.o: \
+compile base64.c base64.h stralloc.h substdio.h str.h
+	./compile base64.c
+
+sslSocket.o: \
+compile sslSocket.c sslSocket.h
+	./compile sslSocket.c
+
 binm1: \
 binm1.sh conf-qmail
 	cat binm1.sh \
@@ -764,7 +772,7 @@ ipalloc.h ip.h gen_alloc.h exit.h
 	./compile ipmeprint.c
 
 it: \
-qmail-local qmail-lspawn qmail-getpw qmail-remote qmail-rspawn \
+qmail-local qmail-lspawn qmail-getpw qmail-rspawn qmail-remote \
 qmail-clean qmail-send qmail-start splogger qmail-queue qmail-inject \
 predate datemail mailsubj qmail-upq qmail-showctl qmail-newu \
 qmail-pw2u qmail-qread qmail-qstat qmail-tcpto qmail-tcpok \
@@ -1415,12 +1423,13 @@ qmail-remote: \
 load qmail-remote.o control.o timeoutread.o timeoutwrite.o \
 timeoutconn.o constmap.o tcpto.o now.o dns.o ip.o ipalloc.o ipme.o quote.o \
 ndelay.a case.a sig.a open.a lock.a seek.a getln.a stralloc.a alloc.a \
-substdio.a error.a str.a fs.a auto_qmail.o dns.lib socket.lib
+substdio.a error.a str.a fs.a auto_qmail.o sslSocket.o dns.lib socket.lib
 	./load qmail-remote control.o timeoutread.o \
 	timeoutwrite.o timeoutconn.o constmap.o tcpto.o now.o dns.o ip.o \
 	ipalloc.o ipme.o quote.o ndelay.a case.a sig.a open.a \
 	lock.a seek.a getln.a stralloc.a alloc.a substdio.a error.a \
-	str.a fs.a auto_qmail.o  `cat dns.lib` `cat socket.lib`
+	str.a fs.a auto_qmail.o sslSocket.o `cat dns.lib` `cat socket.lib` \
+	-lmatrixssl
 
 qmail-remote.0: \
 qmail-remote.8
@@ -1431,7 +1440,7 @@ compile qmail-remote.c sig.h stralloc.h 
 subfd.h substdio.h scan.h case.h error.h auto_qmail.h control.h dns.h \
 alloc.h quote.h ip.h ipalloc.h ip.h gen_alloc.h ipme.h ip.h ipalloc.h \
 gen_alloc.h gen_allocdefs.h str.h now.h datetime.h exit.h constmap.h \
-tcpto.h readwrite.h timeoutconn.h timeoutread.h timeoutwrite.h
+tcpto.h readwrite.h timeoutconn.h timeoutread.h timeoutwrite.h sslSocket.h
 	./compile qmail-remote.c
 
 qmail-rspawn: \
@@ -1514,13 +1523,13 @@ load qmail-smtpd.o rcpthosts.o commands.
 timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o received.o \
 date822fmt.o now.o qmail.o cdb.a fd.a wait.a datetime.a getln.a \
 open.a sig.a case.a env.a stralloc.a alloc.a substdio.a error.a str.a \
-fs.a auto_qmail.o str.a qmail-spp.o socket.lib
+fs.a auto_qmail.o str.a base64.o qmail-spp.o sslSocket.o socket.lib
 	./load qmail-smtpd rcpthosts.o commands.o timeoutread.o \
 	timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o \
 	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
 	datetime.a getln.a open.a sig.a case.a qmail-spp.o env.a stralloc.a \
-	alloc.a substdio.a error.a str.a fs.a auto_qmail.o \
-	str.a `cat socket.lib`
+	alloc.a substdio.a error.a str.a fs.a auto_qmail.o base64.o \
+	sslSocket.o `cat socket.lib` -lmatrixssl
 
 qmail-smtpd.0: \
 qmail-smtpd.8
@@ -1531,7 +1540,8 @@ compile qmail-smtpd.c sig.h readwrite.h 
 substdio.h alloc.h auto_qmail.h control.h received.h constmap.h \
 error.h ipme.h ip.h ipalloc.h ip.h gen_alloc.h ip.h qmail.h \
 substdio.h str.h fmt.h scan.h byte.h case.h env.h now.h datetime.h \
-exit.h rcpthosts.h timeoutread.h timeoutwrite.h commands.h qmail-spp.h
+exit.h rcpthosts.h timeoutread.h timeoutwrite.h commands.h qmail-spp.h \
+wait.h fd.h base64.h sslSocket.h
 	./compile qmail-smtpd.c
 
 qmail-start: \
@@ -2121,3 +2131,23 @@ compile wait_nohang.c haswaitp.h
 wait_pid.o: \
 compile wait_pid.c error.h haswaitp.h
 	./compile wait_pid.c
+
+cert:
+	openssl req -new -x509 -nodes \
+	-out /var/qmail/control/servercert.pem -days 366 \
+	-keyout /var/qmail/control/servercert.pem
+	chmod 640 /var/qmail/control/servercert.pem
+	chown qmaild.qmail /var/qmail/control/servercert.pem
+	ln -s /var/qmail/control/servercert.pem /var/qmail/control/clientcert.pem
+
+cert-req:
+	openssl req -new -nodes \
+	-out req.pem \
+	-keyout /var/qmail/control/servercert.pem
+	chmod 640 /var/qmail/control/servercert.pem
+	chown qmaild.qmail /var/qmail/control/servercert.pem
+	ln -s /var/qmail/control/servercert.pem /var/qmail/control/clientcert.pem
+	@echo
+	@echo "Send req.pem to your CA to obtain signed_req.pem, and do:"
+	@echo "cat signed_req.pem >> /var/qmail/control/servercert.pem"
+
--- netqmail-1.06/conf-cc.matrixssl_auth	1998-06-15 12:53:16.000000000 +0200
+++ netqmail-1.06/conf-cc	2008-06-27 11:31:27.000000000 +0200
@@ -1,3 +1 @@
-cc -O2
-
-This will be used to compile .c files.
+i386-tt-linux-dietlibc-gcc -I/opt/diet/include -Os -fomit-frame-pointer -fno-builtin -UAUTHCRAM -Wall -DTLS -DMATRIXSSL
--- netqmail-1.06/sslSocket.c.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/sslSocket.c	2008-06-27 11:31:26.000000000 +0200
@@ -0,0 +1,1024 @@
+/*
+ *	socketLayer.c
+ *	Release $Name: MATRIXSSL_1_2_2_OPEN $
+ *
+ *	Sample SSL socket layer for MatrixSSL example exectuables
+ */
+/*
+ *	Copyright (c) PeerSec Networks, 2002-2004. All Rights Reserved.
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software 
+ *	into proprietary programs.  If you are unable to comply with the GPL, a 
+ *	commercial license for this software may be purchased from PeerSec Networks
+ *	at http://www.peersec.com
+ *	
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the 
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ *	See the GNU General Public License for more details.
+ *	
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#if defined(__linux__)
+#include <fcntl.h>
+#include <unistd.h>
+#endif
+#include "sslSocket.h"
+
+#ifdef DEBUG_IO
+static void out2(char *s)
+{
+  write(2, s, strlen(s));
+}
+#else
+#define out2(s)
+#endif
+
+static int socketWrite(SOCKET sock, sslBuf_t *out);
+
+/******************************************************************************/
+/*
+	An EXAMPLE socket layer API for the MatrixSSL library.  
+*/
+
+/******************************************************************************/
+/*
+	Server side.  Set up a listen socket.  This code is not specific to SSL.
+*/
+SOCKET socketListen(short port, int *err)
+{
+	struct sockaddr_in	addr;
+	SOCKET				fd;
+	int					rc;
+
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(port);
+	addr.sin_addr.s_addr = INADDR_ANY;
+	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		out2("Error creating listen socket\n");
+		*err = getSocketError();
+		return INVALID_SOCKET;
+	}
+/*
+	Make sure the socket is not inherited by exec'd processes
+	Set the REUSE flag to minimize the number of sockets in TIME_WAIT
+*/
+	fcntl(fd, F_SETFD, FD_CLOEXEC);
+	rc = 1;
+	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&rc, sizeof(rc));
+
+	if (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		out2("Can't bind socket. Port in use or insufficient privilege\n");
+		*err = getSocketError();
+		return INVALID_SOCKET;
+	}
+	if (listen(fd, SOMAXCONN) < 0) {
+		out2("Error listening on socket\n");
+		*err = getSocketError();
+		return INVALID_SOCKET;
+	}
+	return fd;
+}
+
+/******************************************************************************/
+/*
+	Server side.  Accept a new socket connection off our listen socket.  
+	This code is not specific to SSL.
+*/
+SOCKET socketAccept(SOCKET listenfd, int *err)
+{
+	struct sockaddr_in	addr;
+	SOCKET				fd;
+	int					len;
+/*
+	Wait(blocking)/poll(non-blocking) for an incoming connection
+*/
+	len = sizeof(addr);
+	if ((fd = accept(listenfd, (struct sockaddr *)&addr, &len)) 
+			== INVALID_SOCKET) {
+		*err = getSocketError();
+		if (*err != WOULD_BLOCK) {
+			out2("Error accepting new socket\n");
+		}
+		return INVALID_SOCKET;
+	}
+/*
+	fd is the newly accepted socket. Disable Nagle on this socket.
+	Set blocking mode as default
+*/
+	setSocketNodelay(fd);
+	setSocketBlock(fd);
+	return fd;
+}
+
+/******************************************************************************/
+/*
+	Client side. Open a socket connection to a remote ip and port.
+	This code is not specific to SSL.
+*/
+SOCKET socketConnect(char *ip, short port, int *err)
+{
+	struct sockaddr_in	addr;
+	SOCKET				fd;
+	int					rc;
+
+	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		out2("Error creating socket\n");
+		*err = getSocketError();
+		return INVALID_SOCKET;
+	}
+/*
+	Make sure the socket is not inherited by exec'd processes
+	Set the REUSEADDR flag to minimize the number of sockets in TIME_WAIT
+*/
+	fcntl(fd, F_SETFD, FD_CLOEXEC);
+	rc = 1;
+	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&rc, sizeof(rc));
+	setSocketNodelay(fd);
+/*
+	Turn on blocking mode for the connecting socket
+*/
+	setSocketBlock(fd);
+
+	memset((char *) &addr, 0x0, sizeof(addr));
+	addr.sin_family = AF_INET;
+	addr.sin_port = htons(port);
+	addr.sin_addr.s_addr = inet_addr(ip);
+	rc = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
+#if WIN
+	if (rc != 0) {
+#else
+	if (rc < 0) {
+#endif
+		*err = getSocketError();
+		return INVALID_SOCKET;
+	}
+	return fd;
+}
+
+/******************************************************************************/
+/*
+	Server side.  Accept an incomming SSL connection request.
+	'conn' will be filled in with information about the accepted ssl connection
+
+	return -1 on error, 0 on success, or WOULD_BLOCK for non-blocking sockets
+*/
+int sslAccept(sslConn_t **cpp, SOCKET fd, sslKeys_t *keys,
+			  int (*certValidator)(sslCertInfo_t *t, void *arg), int flags)
+{
+	sslConn_t	*conn;
+	unsigned char	buf[1024];
+	int		status, rc;
+/*
+	Associate a new ssl session with this socket.  The session represents
+	the state of the ssl protocol over this socket.  Session caching is
+	handled automatically by this api.
+*/
+	conn = calloc(sizeof(sslConn_t), 1);
+	conn->fd = fd;
+	if (matrixSslNewSession(&conn->ssl, keys, NULL,
+			SSL_FLAGS_SERVER | flags) < 0) {
+		sslFreeConnection(&conn);
+		return -1;
+	}
+/*
+	MatrixSSL doesn't provide buffers for data internally.  Define them
+	here to support buffered reading and writing for non-blocking sockets.
+	Although it causes quite a bit more work, we support dynamically growing
+	the buffers as needed.  Alternately, we could define 16K buffers here
+	and not worry about growing them.
+*/
+	memset(&conn->inbuf, 0x0, sizeof(sslBuf_t));
+	conn->insock.size = 1024;
+	conn->insock.start = conn->insock.end = conn->insock.buf = 
+		(unsigned char *)malloc(conn->insock.size);
+	conn->outsock.size = 1024;
+	conn->outsock.start = conn->outsock.end = conn->outsock.buf = 
+		(unsigned char *)malloc(conn->outsock.size);
+	conn->inbuf.size = 0;
+	conn->inbuf.start = conn->inbuf.end = conn->inbuf.buf = NULL;
+	*cpp = conn;
+
+readMore:
+	rc = sslRead(conn, buf, sizeof(buf), &status);
+/*
+	Reading handshake records should always return 0 bytes, we aren't
+	expecting any data yet.
+*/
+	if (rc == 0) {
+		if (status == SSLSOCKET_EOF || status == SSLSOCKET_CLOSE_NOTIFY) {
+			sslFreeConnection(&conn);
+			return -1;
+		}
+		if (matrixSslHandshakeIsComplete(conn->ssl) == 0) {
+			goto readMore;
+		}
+	} else if (rc > 0) {
+		sslAssert(0);
+		return -1;
+	} else {
+		out2("sslRead error in sslAccept\n");
+		sslFreeConnection(&conn);
+		return -1;
+	}
+	*cpp = conn;
+
+	return 0;
+}
+
+/******************************************************************************/
+/*
+	Client side.  Make a socket connection and go through the SSL handshake
+	phase in blocking mode.  The last parameter is an optional function
+	callback for user-level certificate validation.  NULL if not needed.
+*/
+int sslConnect(sslConn_t **cpp, SOCKET fd, sslKeys_t *keys, 
+			   sslSessionId_t *id, short cipherSuite, 
+			   int (*certValidator)(sslCertInfo_t *t, void *arg),void *userdata)
+{
+	sslConn_t	*conn;
+
+/*
+	Create a new SSL session for the new socket and register the
+	user certificate validator 
+*/
+	conn = calloc(sizeof(sslConn_t), 1);
+	conn->fd = fd;
+	if (matrixSslNewSession(&conn->ssl, keys, id, 0) < 0) {
+		sslFreeConnection(&conn);
+		return -1;
+	}
+	matrixSslSetCertValidator(conn->ssl, certValidator, userdata);
+
+	*cpp = sslDoHandshake(conn, cipherSuite);
+	
+	if (*cpp == NULL) {
+		return -1;
+	}
+	return 0;
+}
+
+/*
+	Construct the initial HELLO message to send to the server and initiate
+	the SSL handshake
+*/
+sslConn_t *sslDoHandshake(sslConn_t *conn, short cipherSuite)
+{
+	char	buf[1024];
+	int		bytes, status, rc;
+
+/*
+	MatrixSSL doesn't provide buffers for data internally.  Define them
+	here to support buffered reading and writing for non-blocking sockets.
+	Although it causes quite a bit more work, we support dynamically growing
+	the buffers as needed.  Alternately, we could define 16K buffers here
+	and not worry about growing them.
+*/
+#ifdef DEBUG
+	out2("sslDoHandshake\n");
+#endif
+	conn->insock.size = 1024;
+	conn->insock.start = conn->insock.end = conn->insock.buf = 
+		(unsigned char *)malloc(conn->insock.size);
+	conn->outsock.size = 1024;
+	conn->outsock.start = conn->outsock.end = conn->outsock.buf = 
+		(unsigned char *)malloc(conn->outsock.size);
+	conn->inbuf.size = 0;
+	conn->inbuf.start = conn->inbuf.end = conn->inbuf.buf = NULL;
+
+	bytes = matrixSslEncodeClientHello(conn->ssl, &conn->outsock, cipherSuite);
+	if (bytes < 0) {
+		sslAssert(bytes < 0);
+		goto error;
+	}
+/*
+	Send the hello with a blocking write
+*/
+	if (socketWrite(conn->fd, &conn->outsock) < 0) {
+		out2("Error in socketWrite\n");
+		goto error;
+	}
+	conn->outsock.start = conn->outsock.end = conn->outsock.buf;
+/*
+	Call sslRead to work through the handshake.  Not actually expecting
+	data back, so the finished case is simply when the handshake is
+	complete.
+*/
+readMore:
+	rc = sslRead(conn, buf, sizeof(buf), &status);
+/*
+	Reading handshake records should always return 0 bytes, we aren't
+	expecting any data yet.
+*/
+	if (rc == 0) {
+		if (status == SSLSOCKET_EOF || status == SSLSOCKET_CLOSE_NOTIFY) {
+			goto error;
+		}
+		if (matrixSslHandshakeIsComplete(conn->ssl) == 0) {
+			goto readMore;
+		}
+	} else if (rc > 0) {
+		out2("sslRead got unexpected data in sslConnect\n");
+		goto error;
+	} else {
+		out2("sslRead error in sslDoHandhake\n");
+		goto error;
+	}
+
+	return conn;
+
+error:
+	sslFreeConnection(&conn);
+	return NULL;
+}
+
+/******************************************************************************/
+/*
+	An example socket sslRead implementation that handles the ssl handshake
+	transparently.  Caller passes in allocated buf and length. 
+	
+	Return codes are as follows:
+
+	-1 return code is an error.  If a socket level error, error code is
+		contained in status parameter.  If using a non-blocking socket
+		implementation the caller should check for non-fatal errors such as
+		WOULD_BLOCK before closing the connection.  A zero value
+		in status indicates an error with this routine.  
+
+	A positive integer return code is the number of bytes successfully read
+		into the supplied buffer.  User can call sslRead again on the updated
+		buffer is there is more to be read.
+
+	0 return code indicates the read was successful, but there was no data
+		to be returned.  If status is set to zero, this is a case internal
+		to the sslAccept and sslConnect functions that a handshake
+		message has been exchanged.  If status is set to SOCKET_EOF
+		the connection has been closed by the other side.
+
+*/
+int sslRead(sslConn_t *cp, char *buf, int len, int *status)
+{
+	int				bytes, rc, remaining;
+	unsigned char	error, alertLevel, alertDescription, performRead;
+
+	*status = 0;
+
+	if (cp->ssl == NULL || len <= 0) {
+		return -1;
+	}
+/*
+	If inbuf is valid, then we have previously decoded data that must be
+	returned, return as much as possible.  Once all buffered data is
+	returned, free the inbuf.
+*/
+	if (cp->inbuf.buf) {
+		if (cp->inbuf.start < cp->inbuf.end) {
+			remaining = (int)(cp->inbuf.end - cp->inbuf.start);
+			bytes = (int)min(len, remaining);
+			memcpy(buf, cp->inbuf.start, bytes);
+			cp->inbuf.start += bytes;
+			return bytes;
+		}
+		free(cp->inbuf.buf);
+		cp->inbuf.buf = NULL;
+	}
+/*
+	Pack the buffered socket data (if any) so that start is at zero.
+*/
+	if (cp->insock.buf < cp->insock.start) {
+		if (cp->insock.start == cp->insock.end) {
+			cp->insock.start = cp->insock.end = cp->insock.buf;
+		} else {
+			memmove(cp->insock.buf, cp->insock.start, cp->insock.end - cp->insock.start);
+			cp->insock.end -= (cp->insock.start - cp->insock.buf);
+			cp->insock.start = cp->insock.buf;
+		}
+	}
+/*
+	Read up to as many bytes as there are remaining in the buffer.  We could
+	Have encrypted data already cached in conn->insock, but might as well read more
+	if we can.
+*/
+	performRead = 0;
+readMore:
+	if (cp->insock.end == cp->insock.start || performRead) {
+		performRead = 1;
+		bytes = recv(cp->fd, (char *)cp->insock.end, 
+			(int)((cp->insock.buf + cp->insock.size) - cp->insock.end), MSG_NOSIGNAL);
+		if (bytes == SOCKET_ERROR) {
+			*status = getSocketError();
+			return -1;
+		}
+		if (bytes == 0) {
+			*status = SSLSOCKET_EOF;
+			return 0;
+		}
+		cp->insock.end += bytes;
+	}
+/*
+	Define a temporary sslBuf
+*/
+	cp->inbuf.start = cp->inbuf.end = cp->inbuf.buf = malloc(len);
+	cp->inbuf.size = len;
+/*
+	Decode the data we just read from the socket
+*/
+decodeMore:
+	error = 0;
+	alertLevel = 0;
+	alertDescription = 0;
+
+	rc = matrixSslDecode(cp->ssl, &cp->insock, &cp->inbuf, &error, &alertLevel, 
+		&alertDescription);
+	switch (rc) {
+/*
+	Successfully decoded a record that did not return data or require a response.
+*/
+	case SSL_SUCCESS:
+#ifdef DEBUG
+		out2("SSL_SUCCESS\n");
+#endif
+		return 0;
+/*
+	Successfully decoded an application data record, and placed in tmp buf
+*/
+	case SSL_PROCESS_DATA:
+/*
+		Copy as much as we can from the temp buffer into the caller's buffer
+		and leave the remainder in conn->inbuf until the next call to read
+		It is possible that len > data in buffer if the encoded record
+		was longer than len, but the decoded record isn't!
+*/
+		rc = (int)(cp->inbuf.end - cp->inbuf.start);
+		rc = min(rc, len);
+		memcpy(buf, cp->inbuf.start, rc);
+		cp->inbuf.start += rc;
+		return rc;
+/*
+	We've decoded a record that requires a response into tmp
+	If there is no data to be flushed in the out buffer, we can write out
+	the contents of the tmp buffer.  Otherwise, we need to append the data 
+	to the outgoing data buffer and flush it out.
+*/
+	case SSL_SEND_RESPONSE:
+#ifdef DEBUG
+		out2("SSL_SEND_RESPONSE\n");
+#endif
+		bytes = send(cp->fd, (char *)cp->inbuf.start, 
+			(int)(cp->inbuf.end - cp->inbuf.start), MSG_NOSIGNAL);
+		if (bytes == SOCKET_ERROR) {
+			*status = getSocketError();
+			if (*status != WOULD_BLOCK) {
+				out2("Socket send error\n");
+				goto readError;
+			}
+			*status = 0;
+		}
+		cp->inbuf.start += bytes;
+		if (cp->inbuf.start < cp->inbuf.end) {
+/*
+			This must be a non-blocking socket since it didn't all get sent
+			out and there was no error.  We want to finish the send here
+			simply because we are likely in the SSL handshake.
+*/
+			setSocketBlock(cp->fd);
+			bytes = send(cp->fd, (char *)cp->inbuf.start, 
+				(int)(cp->inbuf.end - cp->inbuf.start), MSG_NOSIGNAL);
+			if (bytes == SOCKET_ERROR) {
+				*status = getSocketError();
+				goto readError;
+			}
+			cp->inbuf.start += bytes;
+			sslAssert(cp->inbuf.start == cp->inbuf.end);
+/*
+			Can safely set back to non-blocking because we wouldn't
+			have got here if this socket wasn't non-blocking to begin with.
+*/
+			setSocketNonblock(cp->fd);
+		}
+		cp->inbuf.start = cp->inbuf.end = cp->inbuf.buf;
+		return 0;
+/*
+	There was an error decoding the data, or encoding the out buffer.
+	There may be a response data in the out buffer, so try to send.
+	We try a single hail-mary send of the data, and then close the socket.
+	Since we're closing on error, we don't worry too much about a clean flush.
+*/
+	case SSL_ERROR:
+		out2("SSL: Closing on protocol error\n");
+		if (cp->inbuf.start < cp->inbuf.end) {
+			setSocketNonblock(cp->fd);
+			bytes = send(cp->fd, (char *)cp->inbuf.start, 
+				(int)(cp->inbuf.end - cp->inbuf.start), MSG_NOSIGNAL);
+		}
+		goto readError;
+/*
+	We've decoded an alert.  The level and description passed into
+	matrixSslDecode are filled in with the specifics.
+*/
+	case SSL_ALERT:
+		if (alertDescription == SSL_ALERT_CLOSE_NOTIFY) {
+			*status = SSLSOCKET_CLOSE_NOTIFY;
+			goto readZero;
+		}
+		out2("SSL: Closing on client alert\n");
+		goto readError;
+/*
+	We have a partial record, we need to read more data off the socket.
+	If we have a completely full conn->insock buffer, we'll need to grow it
+	here so that we CAN read more data when called the next time.
+*/
+	case SSL_PARTIAL:
+#ifdef DEBUG
+		out2("SSL_PARTIAL\n");
+#endif
+		if (cp->insock.start == cp->insock.buf && cp->insock.end == 
+				(cp->insock.buf + cp->insock.size)) {
+			if (cp->insock.size > SSL_MAX_BUF_SIZE) {
+				goto readError;
+			}
+			cp->insock.size *= 2;
+			cp->insock.start = cp->insock.buf = 
+				(unsigned char *)realloc(cp->insock.buf, cp->insock.size);
+			cp->insock.end = cp->insock.buf + (cp->insock.size / 2);
+		}
+		if (!performRead) {
+			performRead = 1;
+			free(cp->inbuf.buf);
+			cp->inbuf.buf = NULL;
+			goto readMore;
+		} else {
+			goto readZero;
+		}
+/*
+	The out buffer is too small to fit the decoded or response
+	data.  Increase the size of the buffer and call decode again
+*/
+	case SSL_FULL:
+#ifdef DEBUG
+		out2("SSL_FULL\n");
+#endif
+		cp->inbuf.size *= 2;
+		if (cp->inbuf.buf != (unsigned char*)buf) {
+			free(cp->inbuf.buf);
+			cp->inbuf.buf = NULL;
+		}
+		cp->inbuf.start = cp->inbuf.end = cp->inbuf.buf = 
+			(unsigned char *)malloc(cp->inbuf.size);
+		goto decodeMore;
+	}
+/*
+	We consolidated some of the returns here because we must ensure
+	that conn->inbuf is cleared if pointing at caller's buffer, otherwise
+	it will be freed later on.
+*/
+readZero:
+	if (cp->inbuf.buf == (unsigned char*)buf) {
+		cp->inbuf.buf = NULL;
+	}
+	return 0;
+readError:
+	if (cp->inbuf.buf == (unsigned char*)buf) {
+		cp->inbuf.buf = NULL;
+	}
+	return -1;
+}
+
+/******************************************************************************/
+/*
+	Example sslWrite functionality.  Takes care of encoding the input buffer
+	and sending it out on the connection.
+
+	Return codes are as follows:
+
+	-1 return code is an error.  If a socket level error, error code is
+		contained in status.  If using a non-blocking socket
+		implementation the caller should check for non-fatal errors such as
+		WOULD_BLOCK before closing the connection.  A zero value
+		in status indicates an error with this routine.
+
+	A positive integer return value indicates the number of bytes succesfully
+		written on the connection.  Should always match the len parameter.
+
+	0 return code indicates the write must be called again with the same
+		parameters.
+*/
+int sslWrite(sslConn_t *cp, char *buf, int len, int *status)
+{
+	int		rc;
+
+	*status = 0;
+/*
+	Pack the buffered socket data (if any) so that start is at zero.
+*/
+	if (cp->outsock.buf < cp->outsock.start) {
+		if (cp->outsock.start == cp->outsock.end) {
+			cp->outsock.start = cp->outsock.end = cp->outsock.buf;
+		} else {
+			memmove(cp->outsock.buf, cp->outsock.start, cp->outsock.end - cp->outsock.start);
+			cp->outsock.end -= (cp->outsock.start - cp->outsock.buf);
+			cp->outsock.start = cp->outsock.buf;
+		}
+	}
+/*
+	If there is buffered output data, the caller must be trying to
+	send the same amount of data as last time.  We don't support 
+	sending additional data until the original buffered request has
+	been completely sent.
+*/
+	if (cp->outBufferCount > 0 && len != cp->outBufferCount) {
+		sslAssert(len != cp->outBufferCount);
+		return -1;
+	}
+/*
+	If we don't have buffered data, encode the caller's data
+*/
+	if (cp->outBufferCount == 0) {
+retryEncode:
+		rc = matrixSslEncode(cp->ssl, (unsigned char *)buf, len, &cp->outsock);
+		switch (rc) {
+		case SSL_ERROR:
+			return -1;
+		case SSL_FULL:
+			if (cp->outsock.size > SSL_MAX_BUF_SIZE) {
+				return -1;
+			}
+			cp->outsock.size *= 2;
+			cp->outsock.buf = 
+				(unsigned char *)realloc(cp->outsock.buf, cp->outsock.size);
+			cp->outsock.end = cp->outsock.buf + (cp->outsock.end - cp->outsock.start);
+			cp->outsock.start = cp->outsock.buf;
+			goto retryEncode;
+		}
+	}
+/*
+	We've got data to send.
+*/
+	rc = send(cp->fd, (char *)cp->outsock.start, 
+		(int)(cp->outsock.end - cp->outsock.start), MSG_NOSIGNAL);
+	if (rc == SOCKET_ERROR) {
+		*status = getSocketError();
+		return -1;
+	}
+	cp->outsock.start += rc;
+/*
+	If we wrote it all return the length, otherwise remember the number of
+	bytes passed in, and return 0 to be called again later.
+*/
+	if (cp->outsock.start == cp->outsock.end) {
+		cp->outBufferCount = 0;
+		return len;
+	}
+	cp->outBufferCount = len;
+	return 0;
+}
+
+/******************************************************************************/
+/*
+	Send a close alert
+*/
+void sslWriteClosureAlert(sslConn_t *cp)
+{
+	if (cp != NULL) {
+		cp->outsock.start = cp->outsock.end = cp->outsock.buf;
+			matrixSslEncodeClosureAlert(cp->ssl, &cp->outsock);
+		setSocketNonblock(cp->fd);
+		send(cp->fd, cp->outsock.start,
+			(int)(cp->outsock.end - cp->outsock.start), MSG_NOSIGNAL);
+	}
+}
+
+/******************************************************************************/
+/*
+	Server initiated rehandshake.  Builds and sends the HELLO_REQUEST message
+*/
+void sslRehandshake(sslConn_t *cp)
+{
+	matrixSslEncodeHelloRequest(cp->ssl, &cp->outsock);
+	socketWrite(cp->fd, &cp->outsock);
+	cp->outsock.start = cp->outsock.end = cp->outsock.buf;
+}
+
+/******************************************************************************/
+/*
+	Close a seesion that was opened with sslAccept or sslConnect and
+	free the insock and outsock buffers
+*/
+void sslFreeConnection(sslConn_t **cpp)
+{
+	sslConn_t	*conn;
+
+	conn = *cpp;
+	matrixSslDeleteSession(conn->ssl);
+	conn->ssl = NULL;
+	if (conn->insock.buf) {
+		free(conn->insock.buf);
+		conn->insock.buf = NULL;
+	}
+	if (conn->outsock.buf) {
+		free(conn->outsock.buf);
+		conn->outsock.buf = NULL;
+	}
+	if (conn->inbuf.buf) {
+		free(conn->inbuf.buf);
+		conn->inbuf.buf = NULL;
+	}
+	free(conn);
+	*cpp = NULL;
+}
+
+/******************************************************************************/
+/*
+	free the insock and outsock buffers
+*/
+void sslFreeConnectionBuffers(sslConn_t **cpp)
+{
+	sslConn_t	*conn;
+
+	conn = *cpp;
+	if (conn->insock.buf) {
+		free(conn->insock.buf);
+		conn->insock.buf = NULL;
+	}
+	if (conn->outsock.buf) {
+		free(conn->outsock.buf);
+		conn->outsock.buf = NULL;
+	}
+	if (conn->inbuf.buf) {
+		free(conn->inbuf.buf);
+		conn->inbuf.buf = NULL;
+	}
+}
+
+/******************************************************************************/
+/*
+	Set the socket to non blocking mode and perform a few extra tricks
+	to make sure the socket closes down cross platform
+*/
+void socketShutdown(SOCKET sock)
+{
+	char	buf[32];
+
+	if (sock != INVALID_SOCKET) {
+		setSocketNonblock(sock);
+		if (shutdown(sock, 1) >= 0) {
+			while (recv(sock, buf, sizeof(buf), 0) > 0);
+		}
+		closesocket(sock);
+	}
+}
+
+/******************************************************************************/
+/*
+	Perform a blocking write of data to a socket
+*/
+static int socketWrite(SOCKET sock, sslBuf_t *out)
+{
+	unsigned char	*s;
+	int				bytes;
+
+	s = out->start;
+	while (out->start < out->end) {
+		bytes = send(sock, out->start, (int)(out->end - out->start), MSG_NOSIGNAL);
+		if (bytes == SOCKET_ERROR) {
+			return -1;
+		}
+		out->start += bytes;
+	}
+	return (int)(out->start - s);
+}
+
+/******************************************************************************/
+/*
+	Turn on socket blocking mode (and set CLOEXEC on LINUX for kicks).
+*/
+void setSocketBlock(SOCKET sock)
+{
+#if _WIN32
+	int		block = 0;
+	ioctlsocket(sock, FIONBIO, &block);
+#elif LINUX
+	fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) & ~O_NONBLOCK);
+	fcntl(sock, F_SETFD, FD_CLOEXEC);
+#endif
+}
+
+/******************************************************************************/
+/*
+	Turn off socket blocking mode.
+*/
+void setSocketNonblock(SOCKET sock)
+{
+#if _WIN32
+	int		block = 1;
+	ioctlsocket(sock, FIONBIO, &block);
+#elif LINUX
+	fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
+#endif
+}
+
+/******************************************************************************/
+/*
+	Disable the Nagle algorithm for less latency in RPC
+	http://www.faqs.org/rfcs/rfc896.html
+	http://www.w3.org/Protocols/HTTP/Performance/Nagle/
+*/
+void setSocketNodelay(SOCKET sock)
+{
+#if _WIN32
+	BOOL	tmp = TRUE;
+#else
+	int		tmp = 1;
+#endif /* WIN32 */
+	setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&tmp, sizeof(tmp));
+}
+
+/******************************************************************************/
+/*
+	Set a breakpoint in this function to catch asserts.
+	This function is called whenever an assert is triggered.  Useful because
+	VisualStudio often won't show the right line of code if DebugBreak() is 
+	called directly, and abort() may not be desireable on LINUX.
+*/
+void breakpoint()
+{
+	static int preventInline = 0;
+#if _WIN32
+	DebugBreak();
+#elif LINUX
+	abort();
+#endif
+}
+
+
+
+/******************************************************************************/
+/*
+ 	Parse an ASCII command line string.  Assumes a NULL terminated space 
+ 	separated list of command line arguments.  Uses this info to create an argv
+ 	array.
+ 
+ 	Notes:
+ 		handles double quotes
+ 		args gets hacked up!  can't pass in static string!
+ 		not thread safe, so should be called b4 any thread creation
+ 		we currently hardcode argv[0] cause none of our apps need it
+ */
+
+#if WINCE || VXWORKS
+
+void parseCmdLineArgs(char *args, int *pargc, char ***pargv)
+{
+	char			**argv;
+	char			*ptr;
+	int				size, i;
+
+/*
+ *	Figure out the number of elements in our argv array.  
+ *	We know we need an argv array of at least 3, since we have the
+ *	program name, an argument, and a NULL in the array.
+ */
+	for (size = 3, ptr = args; ptr && *ptr != '\0'; ptr++) {
+		if (isspace(*ptr)) {
+			size++;
+			while (isspace(*ptr)) {
+				ptr++;
+			}
+			if (*ptr == '\0') {
+				break;
+			}
+		}
+	}
+/*
+ *	This is called from main, so don't use sslMalloc here or
+ *	all the stats will be wrong.
+ */
+	argv = (char**) malloc(size * sizeof(char*));
+	*pargv = argv;
+
+	for (i = 1, ptr = args; ptr && *ptr != '\0'; i++) {
+		while (isspace(*ptr)) {
+			ptr++;
+		}
+		if (*ptr == '\0')  {
+			break;
+		}
+/*
+ *		Handle double quoted arguments.  Treat everything within
+ *		the double quote as one arg.
+ */
+		if (*ptr == '"') {
+			ptr++;
+			argv[i] = ptr;
+			while ((*ptr != '\0') && (*ptr != '"')) {
+				ptr++;
+			}
+		} else {
+			argv[i] = ptr;
+			while (*ptr != '\0' && !isspace(*ptr)) {
+				ptr++;
+			}
+		}
+		if (*ptr != '\0') {
+			*ptr = '\0';
+			ptr++;
+		}
+	}
+	argv[i] = NULL;
+	*pargc = i ;
+
+	argv[0] = "PeerSec";
+	for (ptr = argv[0]; *ptr; ptr++) {
+		if (*ptr == '\\') {
+			*ptr = '/';
+		}
+	}
+}
+#endif /* WINCE || VXWORKS */
+
+#ifdef WINCE
+
+/******************************************************************************/
+/*
+ 	The following functions implement a unixlike time() function for WINCE.
+
+	NOTE: this code is copied from the os layer in win.c to expose it for use
+	in example applications.
+ */
+
+static FILETIME YearToFileTime(WORD wYear)
+{	
+	SYSTEMTIME sbase;
+	FILETIME fbase;
+
+	sbase.wYear         = wYear;
+	sbase.wMonth        = 1;
+	sbase.wDayOfWeek    = 1; //assumed
+	sbase.wDay          = 1;
+	sbase.wHour         = 0;
+	sbase.wMinute       = 0;
+	sbase.wSecond       = 0;
+	sbase.wMilliseconds = 0;
+
+	SystemTimeToFileTime( &sbase, &fbase );
+
+	return fbase;
+}
+
+time_t time() {
+
+	__int64 time1, time2, iTimeDiff;
+	FILETIME fileTime1, fileTime2;
+	SYSTEMTIME  sysTime;
+
+/*
+	Get 1970's filetime.
+*/
+	fileTime1 = YearToFileTime(1970);
+
+/*
+	Get the current filetime time.
+*/
+	GetSystemTime(&sysTime);
+	SystemTimeToFileTime(&sysTime, &fileTime2);
+
+
+/* 
+	Stuff the 2 FILETIMEs into their own __int64s.
+*/	
+	time1 = fileTime1.dwHighDateTime;
+	time1 <<= 32;				
+	time1 |= fileTime1.dwLowDateTime;
+
+	time2 = fileTime2.dwHighDateTime;
+	time2 <<= 32;				
+	time2 |= fileTime2.dwLowDateTime;
+
+/*
+	Get the difference of the two64-bit ints.
+
+	This is he number of 100-nanosecond intervals since Jan. 1970.  So
+	we divide by 10000 to get seconds.
+ */
+	iTimeDiff = (time2 - time1) / 10000000;
+	return (int)iTimeDiff;
+}
+#endif /* WINCE */
+
+/******************************************************************************/
+
+
+
--- netqmail-1.06/dns.c.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/dns.c	2008-06-27 11:31:26.000000000 +0200
@@ -285,6 +285,14 @@ int pref;
 {
  int r;
  struct ip_mx ix;
+#ifdef TLS
+ stralloc fqdn = {0};
+
+ if (!stralloc_copy(&fqdn,sa)) return DNS_MEM;
+ if (!stralloc_0(&fqdn)) return DNS_MEM;
+ ix.fqdn = fqdn.s;
+ alloc_free(fqdn);
+#endif
 
  if (!stralloc_copy(&glue,sa)) return DNS_MEM;
  if (!stralloc_0(&glue)) return DNS_MEM;
@@ -345,6 +353,9 @@ unsigned long random;
    ix.pref = 0;
    if (!glue.s[ip_scan(glue.s,&ix.ip)] || !glue.s[ip_scanbracket(glue.s,&ix.ip)])
     {
+#ifdef TLS
+     ix.fqdn = NULL;
+#endif
      if (!ipalloc_append(ia,&ix)) return DNS_MEM;
      return 0;
     }
--- netqmail-1.06/TARGETS.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/TARGETS	2008-06-27 11:31:26.000000000 +0200
@@ -245,6 +245,7 @@ qmail-qmqpd
 qmail-qmtpd.o
 rcpthosts.o
 qmail-qmtpd
+base64.o
 qmail-smtpd.o
 qmail-smtpd
 sendmail.o
--- netqmail-1.06/qmail-remote.c.matrixssl_auth	1998-06-15 12:53:16.000000000 +0200
+++ netqmail-1.06/qmail-remote.c	2008-06-27 11:31:26.000000000 +0200
@@ -7,6 +7,7 @@
 #include "substdio.h"
 #include "subfd.h"
 #include "scan.h"
+#include "fmt.h"
 #include "case.h"
 #include "error.h"
 #include "auto_qmail.h"
@@ -29,6 +30,19 @@
 #include "timeoutread.h"
 #include "timeoutwrite.h"
 
+#ifdef TLS
+#define CLIENTCERT "control/clientcert.pem"
+#define SERVERCA   "control/serverca.pem"
+#define LINUX 1
+#include <matrixssl/matrixSsl.h>
+#include <sys/stat.h>
+#include "sslSocket.h"
+sslConn_t      *ssl       = NULL;
+sslCertInfo_t  *cert      = NULL;
+sslSessionId_t *sessionid = NULL;
+stralloc tlsclientciphers = {0};
+#endif
+
 #define HUGESMTPTEXT 5000
 
 #define PORT_SMTP 25 /* silly rabbit, /etc/services is for users */
@@ -86,6 +100,17 @@ Sorry. Although I'm listed as a best-pre
 it isn't in my control/locals file, so I don't treat it as local. (#5.4.6)\n");
 zerodie(); }
 
+#ifdef DEBUG
+static void out2(char *s1, char *s2)
+{
+  if (s1) {
+    write(2, s1, strlen(s1));
+    if (s2) write(2, s2, strlen(s2));
+    write(2, "\n", 1);
+  }
+}
+#endif
+
 void outhost()
 {
   char x[IPFMT];
@@ -107,17 +132,112 @@ int timeoutconnect = 60;
 int smtpfd;
 int timeout = 1200;
 
+#ifdef TLS
+int flagtimedout = 0;
+void sigalrm()
+{
+  flagtimedout = 1;
+}
+
+int ssl_timeoutread(timeout,fd,buf,n) int timeout; int fd; char *buf; int n;
+{
+  int r; int saveerrno; int status;
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  alarm(timeout);
+  while (((r = sslRead(ssl,buf,n,&status))==0) && !status);
+  if (status) {
+    out("ZTLS connection to "); outhost(); out(" died in sslRead()\n");
+    matrixSslClose(ssl);
+    zerodie();
+  }
+  saveerrno = errno;
+  alarm(0);
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  errno = saveerrno;
+  return r;
+}
+
+int ssl_timeoutwrite(timeout,fd,buf,n) int timeout; int fd; char *buf; int n;
+{
+  int r; int saveerrno; int status;
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  alarm(timeout);
+  if (ssl) {
+    while ((r = sslWrite(ssl,buf,n,&status)) == 0);
+    if (status) {
+      char buf[1024];
+      out("ZTLS connection to "); outhost(); out(" died in sslWrite()\n");
+      matrixSslClose(ssl);
+      zerodie();
+    }
+ } else r = write(fd,buf,n);
+ saveerrno = errno;
+ alarm(0);
+ if (flagtimedout) { errno = error_timeout; return -1; }
+ errno = saveerrno;
+ return r;
+}
+
+#ifdef DEBUG
+static void cert_info(sslCertInfo_t *cert)
+{
+  out2("==> verified:       ", cert->verified<0?"no":"yes");
+  out2("==> S.organization: ", cert->subject.organization);
+  out2("==> S.orgUnit:      ", cert->subject.orgUnit);
+  out2("==> S.commonName:   ", cert->subject.commonName);
+  out2("==> I.organization: ", cert->issuer.organization);
+  out2("==> I.orgUnit:      ", cert->issuer.orgUnit);
+  out2("==> I.commonName:   ", cert->issuer.commonName);
+}
+#endif
+
+static int verify_cb(sslCertInfo_t *certchain, void *arg)
+{
+  char *fqdn = (char *)arg;
+  sslCertInfo_t *cert = certchain;
+  int verified;
+  /* check the first certificate in the chain and return an error if:
+   *  1. no certificate given
+   *  2. no subject->commonname in certificate
+   *  3. subject->commonname is different from servers fqdn
+  **/
+  if (!cert || 
+      !cert->subject.commonName ||
+      str_diff(fqdn, cert->subject.commonName)) return -1;
+  return cert->verified;
+  /* now check all certificates in the chain */
+  while (cert) {
+#ifdef DEBUG
+    cert_info(cert);
+#endif
+    if ((verified=cert->verified)<0) break;
+    cert=cert->next;
+  }
+  return verified;
+}
+#endif 
+
 int saferead(fd,buf,len) int fd; char *buf; int len;
 {
   int r;
-  r = timeoutread(timeout,smtpfd,buf,len);
+#ifdef TLS
+  if (ssl)
+    r = ssl_timeoutread(timeout,smtpfd,buf,len);
+  else
+#endif
+    r = timeoutread(timeout,smtpfd,buf,len);
   if (r <= 0) dropped();
   return r;
 }
 int safewrite(fd,buf,len) int fd; char *buf; int len;
 {
   int r;
-  r = timeoutwrite(timeout,smtpfd,buf,len);
+#ifdef TLS
+  if (ssl)
+    r = ssl_timeoutwrite(timeout,smtpfd,buf,len);
+  else
+#endif
+    r = timeoutwrite(timeout,smtpfd,buf,len);
   if (r <= 0) dropped();
   return r;
 }
@@ -216,20 +336,113 @@ void blast()
 
 stralloc recip = {0};
 
+#ifdef TLS
+void smtp(fqdn)
+char *fqdn;
+#else
 void smtp()
+#endif
 {
   unsigned long code;
   int flagbother;
   int i;
- 
+#ifdef TLS
+  sslKeys_t *keys;
+  int needtlsauth = 0;
+  int saveerrno, r;
+
+  stralloc servercert = {0};
+  struct stat st;
+  if(fqdn){
+    if(!stralloc_copys(&servercert, "control/tlshosts/")) temp_nomem();
+    if(!stralloc_catb(&servercert, fqdn, str_len(fqdn))) temp_nomem();
+    if(!stralloc_catb(&servercert, ".pem", 4)) temp_nomem();
+    if(!stralloc_0(&servercert)) temp_nomem();
+    if(!stat(servercert.s,&st)) needtlsauth = 1;
+  }
+#endif
+
   if (smtpcode() != 220) quit("ZConnected to "," but greeting failed");
  
+#ifdef TLS
+  substdio_puts(&smtpto,"EHLO ");
+#else
   substdio_puts(&smtpto,"HELO ");
+#endif
   substdio_put(&smtpto,helohost.s,helohost.len);
   substdio_puts(&smtpto,"\r\n");
   substdio_flush(&smtpto);
+#ifdef TLS
+  if (smtpcode() != 250){
+   substdio_puts(&smtpto,"HELO ");
+   substdio_put(&smtpto,helohost.s,helohost.len);
+   substdio_puts(&smtpto,"\r\n");
+   substdio_flush(&smtpto);
+   if (smtpcode() != 250) quit("ZConnected to "," but my name was rejected");
+  }
+#else
   if (smtpcode() != 250) quit("ZConnected to "," but my name was rejected");
- 
+#endif
+
+#ifdef TLS
+  if (needtlsauth) { /* FIXME, quick hack (should be removed) */
+    i = 0; 
+    while((i += str_chr(smtptext.s+i,'\n') + 1) && (i+12 < smtptext.len) &&
+        str_diffn(smtptext.s+i+4,"STARTTLS\n",9));
+    if (i+12 < smtptext.len) {
+      substdio_puts(&smtpto,"STARTTLS\r\n");
+      substdio_flush(&smtpto);
+      if (smtpcode() == 220) {
+	if (matrixSslOpen() < 0) {
+	  out("ZTLS not available: error initializing SSL\n");
+	  zerodie();
+	}
+	if (stat("control/clientcert.pem", &st) == 0) {
+	  if (matrixSslReadKeys(&keys,CLIENTCERT,CLIENTCERT, NULL, NULL) < 0) {
+	    out("ZTLS error reading or parsing control/clientcert.pem\n");
+	    zerodie();
+	  }
+	}
+	if (needtlsauth) {
+	  if (matrixSslReadKeys(&keys,CLIENTCERT,CLIENTCERT, NULL, servercert.s) < 0) {
+	    out("ZTLS unable to load "); out(servercert.s); out("\n");
+	    zerodie();
+	  }
+	}
+	alarm(timeout);
+	if (needtlsauth)
+	  r = sslConnect(&ssl, smtpfd, keys, sessionid, 0, verify_cb, (void *)fqdn);
+	else
+	  r = sslConnect(&ssl, smtpfd, keys, sessionid, 0, NULL, NULL);
+	saveerrno = errno;
+	alarm(0); 
+	if (flagtimedout) {
+	  out("ZTLS not available: connect timed out\n");
+	  zerodie();
+	}
+	errno = saveerrno;
+	if (r < 0) {
+	  out("ZTLS not available: connect failed: ");
+	  matrixSslClose(ssl);
+	  zerodie();
+	}
+	substdio_puts(&smtpto,"EHLO ");
+	substdio_put(&smtpto,helohost.s,helohost.len);
+	substdio_puts(&smtpto,"\r\n");
+	substdio_flush(&smtpto);
+
+	if (smtpcode() != 250) {
+	  quit("ZTLS connected to "," but my name was rejected");
+	}
+      }
+    }
+  } /* FIXME */
+  if ((!ssl) && needtlsauth) {
+    out("ZNo TLS achieved while "); out(servercert.s); out(" exists.\n");
+    quit();
+  }
+#endif
+
   substdio_puts(&smtpto,"MAIL FROM:<");
   substdio_put(&smtpto,sender.s,sender.len);
   substdio_puts(&smtpto,">\r\n");
@@ -324,6 +537,11 @@ void getcontrols()
     case 1:
       if (!constmap_init(&maproutes,routes.s,routes.len,1)) temp_nomem(); break;
   }
+#ifdef TLS
+  if (control_rldef(&tlsclientciphers,"control/tlsclientciphers",0,"DEFAULT") != 1)
+    temp_control();
+  if(!stralloc_0(&tlsclientciphers)) temp_nomem();
+#endif
 }
 
 void main(argc,argv)
@@ -338,7 +556,10 @@ char **argv;
   int flagallaliases;
   int flagalias;
   char *relayhost;
- 
+
+#ifdef TLS
+  sig_alarmcatch(sigalrm);
+#endif
   sig_pipeignore();
   if (argc < 4) perm_usage();
   if (chdir(auto_qmail) == -1) temp_chdir();
@@ -417,7 +638,11 @@ char **argv;
     if (timeoutconn(smtpfd,&ip.ix[i].ip,(unsigned int) port,timeoutconnect) == 0) {
       tcpto_err(&ip.ix[i].ip,0);
       partner = ip.ix[i].ip;
+#ifdef TLS
+      smtp(ip.ix[i].fqdn); /* does not return */
+#else
       smtp(); /* does not return */
+#endif
     }
     tcpto_err(&ip.ix[i].ip,errno == error_timeout);
     close(smtpfd);
--- netqmail-1.06/base64.h.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/base64.h	2008-06-27 11:31:26.000000000 +0200
@@ -0,0 +1,7 @@
+#ifndef BASE64_H
+#define BASE64_H
+
+extern int b64decode();
+extern int b64encode();
+
+#endif
--- netqmail-1.06/base64.c.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/base64.c	2008-06-27 11:31:26.000000000 +0200
@@ -0,0 +1,90 @@
+#include "base64.h"
+#include "stralloc.h"
+#include "substdio.h"
+#include "str.h"
+
+static char *b64alpha =
+  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+#define B64PAD '='
+
+/* returns 0 ok, 1 illegal, -1 problem */
+
+int b64decode(in,l,out)
+const unsigned char *in;
+int l;
+stralloc *out; /* not null terminated */
+{
+  int i, j;
+  unsigned char a[4];
+  unsigned char b[3];
+  char *s;
+
+  if (l == 0)
+  {
+    if (!stralloc_copys(out,"")) return -1;
+    return 0;
+  }
+
+  if (!stralloc_ready(out,l + 2)) return -1; /* XXX generous */
+  s = out->s;
+
+  for (i = 0;i < l;i += 4) {
+    for (j = 0;j < 4;j++)
+      if ((i + j) < l && in[i + j] != B64PAD)
+      {
+        a[j] = str_chr(b64alpha,in[i + j]);
+        if (a[j] > 63) return 1;
+      }
+      else a[j] = 0;
+
+    b[0] = (a[0] << 2) | (a[1] >> 4);
+    b[1] = (a[1] << 4) | (a[2] >> 2);
+    b[2] = (a[2] << 6) | (a[3]);
+
+    *s++ = b[0];
+
+    if (in[i + 1] == B64PAD) break;
+    *s++ = b[1];
+
+    if (in[i + 2] == B64PAD) break;
+    *s++ = b[2];
+  }
+  out->len = s - out->s;
+  while (out->len && !out->s[out->len - 1]) --out->len; /* XXX avoid? */
+  return 0;
+}
+
+int b64encode(in,out)
+stralloc *in;
+stralloc *out; /* not null terminated */
+{
+  unsigned char a, b, c;
+  int i;
+  char *s;
+
+  if (in->len == 0)
+  {
+    if (!stralloc_copys(out,"")) return -1;
+    return 0;
+  }
+
+  if (!stralloc_ready(out,in->len / 3 * 4 + 4)) return -1;
+  s = out->s;
+
+  for (i = 0;i < in->len;i += 3) {
+    a = in->s[i];
+    b = i + 1 < in->len ? in->s[i + 1] : 0;
+    c = i + 2 < in->len ? in->s[i + 2] : 0;
+
+    *s++ = b64alpha[a >> 2];
+    *s++ = b64alpha[((a & 3 ) << 4) | (b >> 4)];
+
+    if (i + 1 >= in->len) *s++ = B64PAD;
+    else *s++ = b64alpha[((b & 15) << 2) | (c >> 6)];
+
+    if (i + 2 >= in->len) *s++ = B64PAD;
+    else *s++ = b64alpha[c & 63];
+  }
+  out->len = s - out->s;
+  return 0;
+}
--- netqmail-1.06/ipalloc.h.matrixssl_auth	1998-06-15 12:53:16.000000000 +0200
+++ netqmail-1.06/ipalloc.h	2008-06-27 11:31:26.000000000 +0200
@@ -3,7 +3,12 @@
 
 #include "ip.h"
 
+#ifdef TLS
+#include "stralloc.h"
+struct ip_mx { struct ip_address ip; int pref; char *fqdn; } ;
+#else
 struct ip_mx { struct ip_address ip; int pref; } ;
+#endif
 
 #include "gen_alloc.h"
 
--- netqmail-1.06/sslSocket.h.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/sslSocket.h	2008-06-27 11:31:26.000000000 +0200
@@ -0,0 +1,170 @@
+/*
+ *	vim:set ts=4:
+ * 
+ *	socketLayer.h
+ *	Release $Name: MATRIXSSL_1_2_2_OPEN $
+ *
+ *	Sample SSL socket layer header for MatrixSSL
+ */
+/*
+ *	Copyright (c) PeerSec Networks, 2002-2004. All Rights Reserved.
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software 
+ *	into proprietary programs.  If you are unable to comply with the GPL, a 
+ *	commercial license for this software may be purchased from PeerSec Networks
+ *	at http://www.peersec.com
+ *	
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the 
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ *	See the GNU General Public License for more details.
+ *	
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_SSLSOCKET
+#define _h_SSLSOCKET
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <matrixssl/matrixSsl.h>
+#if defined(__linux__)
+#define LINUX 1
+#endif
+/*
+	OS specific macros
+*/
+#if WIN32 || WINCE
+	#include	<windows.h>
+	#include	<winsock.h>
+	#define		fcntl(A, B, C)
+	#define		MSG_NOSIGNAL	0
+	#define		WOULD_BLOCK	WSAEWOULDBLOCK
+	#define		getSocketError()  WSAGetLastError()
+#elif LINUX
+	#include	<sys/socket.h>
+	#include	<netinet/in.h>
+	#include	<netinet/tcp.h>
+	#include	<arpa/inet.h>
+#ifdef OSX
+	#include	<sys/socket.h>
+	#define		MSG_NOSIGNAL	0
+#endif /* OSX */
+	#include	<string.h>
+	#include	<errno.h>
+	#define		SOCKET_ERROR -1
+	#define		getSocketError() errno 
+	#define		WOULD_BLOCK	EAGAIN
+	#define		closesocket close
+	#define		MAKEWORD(A, B)
+	#define		WSAStartup(A, B)
+	#define		WSACleanup()
+	#define		INVALID_SOCKET -1
+	typedef int	WSADATA;
+	typedef int	SOCKET;
+#elif VXWORKS
+	#include	<types.h>
+	#include	<socket.h>
+	#include	<netinet/in.h>
+	#include	<netinet/tcp.h>
+	#include	<fcntl.h>
+	#include	<errno.h>
+	#define		fcntl(A, B, C) ioctl(A, B, C)
+	#define		SOCKET_ERROR -1
+	#define		getSocketError() errno 
+	#define		WOULD_BLOCK	EAGAIN
+	#define		closesocket close
+	#define		MAKEWORD(A, B)
+	#define		WSAStartup(A, B)
+	#define		WSACleanup()
+	#define		INVALID_SOCKET -1
+	#define		MSG_NOSIGNAL	0
+	typedef int	WSADATA;
+	typedef int	SOCKET;
+#endif /* OS macros */
+
+#ifdef DEBUG
+extern void breakpoint();
+#define sslAssert(C) if (C) ; else {printf("%s:%d sslAssert(%s)\n",\
+						__FILE__, __LINE__, #C); breakpoint(); }
+#else
+#define sslAssert(C)
+#endif
+
+#ifndef min
+#define min(a,b)	(((a) < (b)) ? (a) : (b))
+#endif /* min */
+
+/*
+	sslRead and sslWrite status values
+*/
+#define SSLSOCKET_EOF			0x1
+#define SSLSOCKET_CLOSE_NOTIFY	0x2
+
+/*
+	Connection structure
+*/
+typedef struct {
+	ssl_t				*ssl;
+	sslBuf_t			inbuf;
+	sslBuf_t			insock;
+	sslBuf_t			outsock;
+	int					outBufferCount;
+	SOCKET				fd;
+} sslConn_t;
+
+/*
+	Secure Socket apis
+*/
+extern int			sslConnect(sslConn_t **cp, SOCKET fd, sslKeys_t *keys,
+						sslSessionId_t *id, short cipherSuite,
+						int (*certValidator)(sslCertInfo_t *t, void *arg), void *userdata);
+extern int			sslAccept(sslConn_t **cp, SOCKET fd, sslKeys_t *keys,
+						int (*certValidator)(sslCertInfo_t *t, void *arg), int flags);
+extern void			sslRehandshake(sslConn_t *cp);
+extern sslConn_t	*sslDoHandshake(sslConn_t *conn, short cipherSuite);
+extern void			sslFreeConnection(sslConn_t **cp);
+extern void			sslFreeConnectionBuffers(sslConn_t **cpp);
+
+extern int	sslRead(sslConn_t *cp, char *buf, int len, int *status);
+extern int	sslWrite(sslConn_t *cp, char *buf, int len, int *status);
+extern void	sslWriteClosureAlert(sslConn_t *cp);
+
+/*
+	Socket apis
+*/
+extern SOCKET	socketListen(short port, int *err);
+extern SOCKET	socketAccept(SOCKET listenfd, int *err);
+extern SOCKET	socketConnect(char *ip, short port, int *err);
+extern void		socketShutdown(SOCKET sock);
+
+extern void setSocketBlock(SOCKET sock);
+extern void setSocketNonblock(SOCKET sock);
+extern void setSocketNodelay(SOCKET sock);
+
+#if WINCE || VXWORKS
+extern void	parseCmdLineArgs(char *args, int *pargc, char ***pargv);
+#endif /* WINCE || VXWORKS */
+
+#if WINCE
+extern time_t time();
+#endif /* WINCE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _h_SSLSOCKET */
+
+/******************************************************************************/
--- netqmail-1.06/qmail-smtpd.c.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/qmail-smtpd.c	2008-06-27 11:32:07.000000000 +0200
@@ -24,6 +24,22 @@
 #include "timeoutwrite.h"
 #include "commands.h"
 #include "qmail-spp.h"
+#include "base64.h"
+#include "wait.h"
+#include "fd.h"
+  
+#ifdef TLS
+#define SERVERCERT "control/servercert.pem"
+#define SERVERKEY  "control/servercert.pem"
+#define CLIENTCA   "control/clientca.pem"
+#define LINUX 1
+#include <matrixssl/matrixSsl.h>
+#include "sslSocket.h"
+sslConn_t     *ssl  = NULL;
+sslCertInfo_t *cert = NULL;
+stralloc clientcert = {0};
+stralloc tlsserverciphers = {0};
+#endif
 
 int spp_val;
 
@@ -31,10 +47,56 @@ int spp_val;
 unsigned int databytes = 0;
 int timeout = 1200;
 
+#ifdef TLS
+int flagtimedout = 0;
+void sigalrm()
+{
+ flagtimedout = 1;
+}
+
+int ssl_write(sslConn_t *ssl, char *buf, int bufsiz)
+{
+  int status, r;
+  while ((r = sslWrite(ssl, buf, bufsiz, &status)) == 0);
+  return r;
+}
+
+int ssl_timeoutread(timeout,fd,buf,n) int timeout; int fd; char *buf; int n;
+{
+  int r; int saveerrno; int status;
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  alarm(timeout);
+  while (((r = sslRead(ssl,buf,n,&status))==0) && !status);
+  saveerrno = errno;
+  alarm(0);
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  errno = saveerrno;
+  return r;
+}
+
+int ssl_timeoutwrite(timeout,fd,buf,n) int timeout; int fd; char *buf; int n;
+{
+  int r, saveerrno, status;
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  alarm(timeout);
+  while ((r = sslWrite(ssl, buf, n, &status)) == 0);
+  saveerrno = errno;
+  alarm(0);
+  if (flagtimedout) { errno = error_timeout; return -1; }
+  errno = saveerrno;
+  return r;
+}
+#endif
+
 int safewrite(fd,buf,len) int fd; char *buf; int len;
 {
   int r;
-  r = timeoutwrite(timeout,fd,buf,len);
+#ifdef TLS
+  if (ssl)
+    r = ssl_timeoutwrite(timeout,fd,buf,len);
+  else
+#endif
+    r = timeoutwrite(timeout,fd,buf,len);
   if (r <= 0) _exit(1);
   return r;
 }
@@ -63,7 +125,17 @@ void err_wantrcpt() { out("503 RCPT firs
 void err_noop(arg) char *arg; { out("250 ok\r\n"); }
 void err_vrfy(arg) char *arg; { out("252 send some mail, i'll try my best\r\n"); }
 void err_qqt() { out("451 qqt failure (#4.3.0)\r\n"); }
+void err_nogwcert() { out("553 no valid cert for gatewaying (#5.7.1)\r\n"); }
+void err_authd() { out("503 you're already authenticated (#5.5.0)\r\n"); }
+void err_authmail() { out("503 no auth during mail transaction (#5.5.0)\r\n"); }
 
+int die_child() { out("454 oops, problem with child and I can't auth (#4.3.0)\r\n"); return -1; }
+int die_fork() { out("454 oops, child won't start and I can't auth (#4.3.0)\r\n"); return -1; }
+int die_pipe() { out("454 oops, unable to open pipe and I can't auth (#4.3.0)\r\n"); return -1; }
+int die_write() { out("454 oops, unable to write pipe and I can't auth (#4.3.0)\r\n"); return -1; }
+int die_noauth() { out("504 auth type unimplemented (#5.5.1)\r\n"); return -1; }
+int die_authabrt() { out("501 auth exchange cancelled (#5.0.0)\r\n"); return -1; }
+int die_input() { out("501 malformed auth input (#5.5.4)\r\n"); return -1; }
 
 stralloc greeting = {0};
 
@@ -86,6 +158,10 @@ char *remotehost;
 char *remoteinfo;
 char *local;
 char *relayclient;
+#ifdef TLS
+char *tlsciphers;
+int tlsenable = 0;
+#endif
 
 stralloc helohost = {0};
 char *fakehelo; /* pointer into helohost, or 0 */
@@ -108,6 +183,9 @@ void setup()
 {
   char *x;
   unsigned long u;
+#ifdef TLS
+  char *tlsciphers;
+#endif
  
   if (control_init() == -1) die_control();
   if (control_rldef(&greeting,"control/smtpgreeting",1,(char *) 0) != 1)
@@ -148,6 +226,18 @@ void setup()
   if (!remotehost) remotehost = "unknown";
   remoteinfo = env_get("TCPREMOTEINFO");
   relayclient = env_get("RELAYCLIENT");
+#ifdef TLS
+  control_readint(&tlsenable,"control/tlsenable");
+  if ((tlsciphers = env_get("TLSCIPHERS"))) {
+    if (!stralloc_copys(&tlsserverciphers,tlsciphers)) die_nomem();
+  }
+  else {
+    if (control_rldef(&tlsserverciphers,"control/tlsserverciphers",0,"DEFAULT") != 1)
+      die_control();
+  }
+  if (!stralloc_0(&tlsserverciphers)) die_nomem();
+#endif
+
   dohelo(remotehost);
 }
 
@@ -297,7 +386,12 @@ void smtp_size()
 void smtp_ehlo(arg) char *arg;
 {
   if(!spp_helo(arg)) return;
-  smtp_greet("250-"); out("\r\n250-PIPELINING\r\n250 8BITMIME\r\n");
+  smtp_greet("250-");
+  out("\r\n250-AUTH LOGIN PLAIN\r\n250-AUTH=LOGIN PLAIN");
+#ifdef TLS
+  if (!ssl && tlsenable) out("\r\n250-STARTTLS");
+#endif
+  out("\r\n250-PIPELINING\r\n250-8BITMIME\r\n");
   smtp_size();
   seenmail = 0; dohelo(arg);
 }
@@ -322,6 +416,13 @@ void smtp_mail(arg) char *arg;
   recipcount = 0;
   out("250 ok\r\n");
 }
+#ifdef TLS
+static int verify_cb(sslCertInfo_t *cert, void *arg)
+{
+  return cert->verified;
+}
+#endif
+
 void smtp_rcpt(arg) char *arg; {
   if (!seenmail) { err_wantmail(); return; }
   if (!addrparse(arg)) { err_syntax(); return; }
@@ -329,13 +430,32 @@ void smtp_rcpt(arg) char *arg; {
   if (!relayclient) allowed = addrallowed();
   else allowed = 1;
   if (!(spp_val = spp_rcpt(allowed))) return;
-  if (relayclient) {
-    --addr.len;
-    if (!stralloc_cats(&addr,relayclient)) die_nomem();
-    if (!stralloc_0(&addr)) die_nomem();
-  }
-  else if (spp_val == 1) {
-    if (!allowed) { err_nogateway(); return; }
+  if (spp_val == 1) {
+    if (relayclient) {
+      --addr.len;
+      if (!stralloc_cats(&addr,relayclient)) die_nomem();
+      if (!stralloc_0(&addr)) die_nomem();
+    }
+    else 
+#ifndef TLS
+      if (!allowed) { err_nogateway(); return; }
+#else
+      if (!allowed) {
+	if (ssl) {
+	  stralloc tlsclients = {0};
+	  struct constmap maptlsclients;
+	  if ((control_readfile(&tlsclients,"control/tlsclients",0) != 1) ||
+	      !constmap_init(&maptlsclients,tlsclients.s,tlsclients.len,0)) {
+	    err_nogateway();
+	    return;
+	  }
+	  sslRehandshake(ssl);
+	} else {
+	  err_nogateway();
+	  return;
+	}
+      }
+#endif
   }
   spp_rcpt_accepted();
   if (!stralloc_cats(&rcptto,"T")) die_nomem();
@@ -351,7 +471,12 @@ int saferead(fd,buf,len) int fd; char *b
 {
   int r;
   flush();
-  r = timeoutread(timeout,fd,buf,len);
+#ifdef TLS
+  if (ssl)
+    r = ssl_timeoutread(timeout,fd,buf,len);
+  else
+#endif
+    r = timeoutread(timeout,fd,buf,len);
   if (r == -1) if (errno == error_timeout) die_alarm();
   if (r <= 0) die_read();
   return r;
@@ -451,6 +576,9 @@ void smtp_data(arg) char *arg; {
   int hops;
   unsigned long qp;
   char *qqx;
+#ifdef TLS
+  stralloc protocolinfo = {0};
+#endif
  
   if (!seenmail) { err_wantmail(); return; }
   if (!rcptto.len) { err_wantrcpt(); return; }
@@ -461,8 +589,21 @@ void smtp_data(arg) char *arg; {
   if (qmail_open(&qqt) == -1) { err_qqt(); return; }
   qp = qmail_qp(&qqt);
   out("354 go ahead\r\n");
- 
+#ifdef TLS
+  if(ssl){
+    char *name = matrixSslGetCipherName(ssl->ssl);
+    if (!stralloc_copys(&protocolinfo, name)) die_nomem();
+    if (!stralloc_catb(&protocolinfo, " encrypted SMTP", 15)) die_nomem();
+    if (clientcert.len){
+      if (!stralloc_catb(&protocolinfo," cert ", 6)) die_nomem();
+      if (!stralloc_catb(&protocolinfo,clientcert.s, clientcert.len)) die_nomem();
+    }
+    if (!stralloc_0(&protocolinfo)) die_nomem();
+  } else if (!stralloc_copyb(&protocolinfo,"SMTP",5)) die_nomem();
+  received(&qqt,protocolinfo.s,local,remoteip,remotehost,remoteinfo,case_diffs(remotehost,helohost.s) ? helohost.s : 0);
+#else
   received(&qqt,"SMTP",local,remoteip,remotehost,remoteinfo,fakehelo);
+#endif
   qmail_put(&qqt,sppheaders.s,sppheaders.len); /* set in qmail-spp.c */
   spp_rset();
   blast(&hops);
@@ -479,23 +620,257 @@ void smtp_data(arg) char *arg; {
   out(qqx + 1);
   out("\r\n");
 }
+#ifdef TLS
+void smtp_tls(arg) char *arg;
+{
+  sslKeys_t *keys;
+  int ret;
+
+  if (*arg)
+  {
+    out("501 Syntax error (no parameters allowed) (#5.5.4)\r\n");
+    return;
+  }
+
+  if (matrixSslOpen() < 0)
+  {
+    out("454 TLS not available: unable to initialize ctx (#4.3.0)\r\n");
+    return;
+  }
+
+  /* currently matrixssl doesn't support server side validation of client
+   * certificates
+   */
+  if ((ret=matrixSslReadKeys(&keys, SERVERCERT, SERVERKEY, NULL, CLIENTCA)) < 0)
+  {
+    if (matrixSslReadKeys(&keys, SERVERCERT, SERVERKEY, NULL, NULL) < 0)
+    {
+      out("454 TLS not available: error reading or parsing certificates (#4.3.0)\r\n");
+      return;
+    }
+  }
+  out("220 ready for tls\r\n"); flush();
+  
+  if (sslAccept(&ssl, 0, keys, verify_cb, 0) != 0) die_read();
+  substdio_fdbuf(&ssout,ssl_write,ssl,ssoutbuf,sizeof(ssoutbuf));
+
+  remotehost = env_get("TCPREMOTEHOST");
+  if (!remotehost) remotehost = "unknown";
+  dohelo(remotehost);
+}
+#endif
+
+
+char unique[FMT_ULONG + FMT_ULONG + 3];
+static stralloc authin = {0};
+static stralloc user = {0};
+static stralloc pass = {0};
+static stralloc resp = {0};
+static stralloc slop = {0};
+char *hostname;
+char **childargs;
+substdio ssup;
+char upbuf[128];
+int authd = 0;
+
+int authgetl(void) {
+  int i;
+
+  if (!stralloc_copys(&authin, "")) die_nomem();
+
+  for (;;) {
+    if (!stralloc_readyplus(&authin,1)) die_nomem(); /* XXX */
+    i = substdio_get(&ssin,authin.s + authin.len,1);
+    if (i != 1) die_read();
+    if (authin.s[authin.len] == '\n') break;
+    ++authin.len;
+  }
+
+  if (authin.len > 0) if (authin.s[authin.len - 1] == '\r') --authin.len;
+  authin.s[authin.len] = 0;
+
+  if (*authin.s == '*' && *(authin.s + 1) == 0) { return die_authabrt(); }
+  if (authin.len == 0) { return die_input(); }
+  return authin.len;
+}
+
+int authenticate(void)
+{
+  int child;
+  int wstat;
+  int pi[2];
+
+  if (!stralloc_0(&user)) die_nomem();
+  if (!stralloc_0(&pass)) die_nomem();
+  if (!stralloc_0(&resp)) die_nomem();
+
+  if (fd_copy(2,1) == -1) return die_pipe();
+  close(3);
+  if (pipe(pi) == -1) return die_pipe();
+  if (pi[0] != 3) return die_pipe();
+  switch(child = fork()) {
+    case -1:
+      return die_fork();
+    case 0:
+      close(pi[1]);
+      sig_pipedefault();
+      execvp(*childargs, childargs);
+      _exit(1);
+  }
+  close(pi[0]);
+
+  substdio_fdbuf(&ssup,write,pi[1],upbuf,sizeof upbuf);
+  if (substdio_put(&ssup,user.s,user.len) == -1) return die_write();
+  if (substdio_put(&ssup,pass.s,pass.len) == -1) return die_write();
+  if (substdio_put(&ssup,resp.s,resp.len) == -1) return die_write();
+  if (substdio_flush(&ssup) == -1) return die_write();
+
+  close(pi[1]);
+  byte_zero(pass.s,pass.len);
+  byte_zero(upbuf,sizeof upbuf);
+  if (wait_pid(&wstat,child) == -1) return die_child();
+  if (wait_crashed(wstat)) return die_child();
+  if (wait_exitcode(wstat)) { sleep(5); return 1; } /* no */
+  return 0; /* yes */
+}
+
+int auth_login(arg) char *arg;
+{
+  int r;
+
+#ifdef TLS
+  if (!ssl) {
+    out("530 Must issue a STARTTLS command first (#5.7.0)\r\n");
+    return -1;
+  }
+#endif
+  if (*arg) {
+    if ((r = b64decode(arg,str_len(arg),&user)) == 1) return die_input();
+  }
+  else {
+    out("334 VXNlcm5hbWU6\r\n"); flush(); /* Username: */
+    if (authgetl() < 0) return -1;
+    if ((r = b64decode(authin.s,authin.len,&user)) == 1) return die_input();
+  }
+  if (r == -1) die_nomem();
+
+  out("334 UGFzc3dvcmQ6\r\n"); flush(); /* Password: */
+
+  if (authgetl() < 0) return -1;
+  if ((r = b64decode(authin.s,authin.len,&pass)) == 1) return die_input();
+  if (r == -1) die_nomem();
+
+  if (!user.len || !pass.len) return die_input();
+  return authenticate();  
+}
+
+int auth_plain(arg) char *arg;
+{
+  int r, id = 0;
+
+#ifdef TLS
+  if (!ssl) {
+    out("530 Must issue a STARTTLS command first (#5.7.0)\r\n");
+    return -1;
+  }
+#endif
+  if (*arg) {
+    if ((r = b64decode(arg,str_len(arg),&slop)) == 1) return die_input();
+  }
+  else {
+    out("334 \r\n"); flush();
+    if (authgetl() < 0) return -1;
+    if ((r = b64decode(authin.s,authin.len,&slop)) == 1) return die_input();
+  }
+  if (r == -1 || !stralloc_0(&slop)) die_nomem();
+  while (slop.s[id]) id++; /* ignore authorize-id */
+
+  if (slop.len > id + 1)
+    if (!stralloc_copys(&user,slop.s + id + 1)) die_nomem();
+  if (slop.len > id + user.len + 2)
+    if (!stralloc_copys(&pass,slop.s + id + user.len + 2)) die_nomem();
+
+  if (!user.len || !pass.len) return die_input();
+  return authenticate();
+}
+
+struct authcmd {
+  char *text;
+  int (*fun)();
+} authcmds[] = {
+  { "login", auth_login },
+  { "plain", auth_plain },
+  { 0, die_noauth }
+};
+
+void smtp_auth(arg)
+char *arg;
+{
+  int i;
+  char *cmd = arg;
+
+  if (!hostname || !*childargs)
+  {
+    out("503 auth not available (#5.3.3)\r\n");
+    return;
+  }
+  if (authd) { err_authd(); return; }
+  if (seenmail) { err_authmail(); return; }
+
+  if (!stralloc_copys(&user,"")) die_nomem();
+  if (!stralloc_copys(&pass,"")) die_nomem();
+  if (!stralloc_copys(&resp,"")) die_nomem();
+
+  i = str_chr(cmd,' ');   
+  arg = cmd + i;
+  while (*arg == ' ') ++arg;
+  cmd[i] = 0;
+
+  for (i = 0;authcmds[i].text;++i)
+    if (case_equals(authcmds[i].text,cmd)) break;
+
+  switch (authcmds[i].fun(arg)) {
+    case 0:
+      authd = 1;
+      relayclient = "";
+      remoteinfo = user.s;
+      if (!env_unset("TCPREMOTEINFO")) die_read();
+      if (!env_put2("TCPREMOTEINFO",remoteinfo)) die_nomem();
+      out("235 ok, go ahead (#2.0.0)\r\n");
+      break;
+    case 1:
+      out("535 authorization failed (#5.7.0)\r\n");
+  }
+}
 
 struct commands smtpcommands[] = {
   { "rcpt", smtp_rcpt, 0 }
 , { "mail", smtp_mail, 0 }
 , { "data", smtp_data, flush }
+, { "auth", smtp_auth, flush }
 , { "quit", smtp_quit, flush }
 , { "helo", smtp_helo, flush }
 , { "ehlo", smtp_ehlo, flush }
 , { "rset", smtp_rset, 0 }
 , { "help", smtp_help, flush }
+#ifdef TLS
+, { "starttls", smtp_tls, flush }
+#endif
 , { "noop", err_noop, flush }
 , { "vrfy", err_vrfy, flush }
 , { 0, err_unimpl, flush }
 } ;
 
-void main()
-{
+void main(argc,argv)
+int argc;
+char **argv;
+{
+  hostname = argv[1];
+  childargs = argv + 2;
+
+#ifdef TLS
+  sig_alarmcatch(sigalrm);
+#endif
   sig_pipeignore();
   if (chdir(auto_qmail) == -1) die_control();
   setup();
--- netqmail-1.06/qmail-smtpd.8.matrixssl_auth	1998-06-15 12:53:16.000000000 +0200
+++ netqmail-1.06/qmail-smtpd.8	2008-06-27 11:31:26.000000000 +0200
@@ -3,6 +3,11 @@
 qmail-smtpd \- receive mail via SMTP
 .SH SYNOPSIS
 .B qmail-smtpd
+[
+.I hostname
+.I checkprogram
+.I subprogram
+]
 .SH DESCRIPTION
 .B qmail-smtpd
 receives mail messages via the Simple Mail Transfer Protocol (SMTP)
@@ -23,7 +28,29 @@ or
 header fields.
 
 .B qmail-smtpd
-supports ESMTP, including the 8BITMIME and PIPELINING options.
+supports ESMTP, including the 8BITMIME, PIPELINING, and AUTH options.
+
+.B qmail-smtpd
+can accept LOGIN, PLAIN, and CRAM-MD5 AUTH types.  It invokes
+.IR checkprogram ,
+which reads on file descriptor 3 the username, a 0 byte, the password
+or challenge derived from
+.IR hostname ,
+another 0 byte, a CRAM-MD5 response (if applicable to the AUTH type),
+and a final 0 byte.
+.I checkprogram
+invokes
+.I subprogram
+upon successful authentication, which should in turn return 0 to
+.BR qmail-smtpd ,
+effectively setting the environment variables RELAYCLIENT and TCPREMOTEINFO
+(any supplied value replaced with the authenticated username).
+.B qmail-smtpd
+will reject the authentication attempt if it receives a nonzero return
+value from
+.I checkprogram
+or
+.IR subprogram .
 .SH TRANSPARENCY
 .B qmail-smtpd
 converts the SMTP newline convention into the UNIX newline convention
@@ -177,3 +204,6 @@ qmail-inject(8),
 qmail-newmrh(8),
 qmail-queue(8),
 qmail-remote(8)
+.SH "HISTORY"
+The patch enabling the ESMTP AUTH option is not part of the standard
+qmail-1.03 distribution.
--- netqmail-1.06/README.smtpauth.matrixssl_auth	2008-06-27 11:31:26.000000000 +0200
+++ netqmail-1.06/README.smtpauth	2008-06-27 11:31:26.000000000 +0200
@@ -0,0 +1,175 @@
+*** Warning! Cuidado! Vorsicht! ***
+===================================
+*** Version 0.30 of the patch changes the arguments which must be
+*** passed to qmail-smtpd.  If you are upgrading from a previous
+*** version of the patch, take care to ensure your invocation of
+*** qmail-smtpd uses the correct arguments.  Otherwise, your server
+*** may run as an open relay!
+===================================
+*** Warning! Cuidado! Vorsicht! ***
+
+
+This patch adds ESMTP AUTH authentication protocol support to
+qmail-1.03.  It's originally based on Mrs. Brisby's smtp-auth patch
+with many enhancements from Krzysztof Dabrowski <brush@elysium.pl>.
+
+Beginning with version 0.30, the patch was completely rewritten to
+use only djb's string functions by Eric M. Johnston <emj@postal.net>.
+
+You can always get the newest version from:
+http://members.elysium.pl/brush/qmail-smtpd-auth/
+
+To use all of it's functionality you will also have to obtain and
+install Krzysztof's cmd5checkpw utility available at:
+http://members.elysium.pl/brush/cmd5checkpw/
+
+If you need more information about SMTP-AUTH itself and the
+client/server support and configuration, visit:
+http://members.elysium.pl/brush/smtp-auth/
+
+---
+
+Detailed patch information:
+
+This patch adds the ESMTP AUTH option to qmail-1.03, allowing the
+LOGIN, PLAIN, and CRAM-MD5 AUTH types. An appropriate checkpassword
+tool is necessary to support the authentication.  See
+http://cr.yp.to/checkpwd.html for more information on the interface.
+Note that the checkpassword tool should support all of the AUTH types
+advertised by qmail-smtpd.
+
+As reflected in the modified qmail-smtpd(8) man page, qmail-smtpd
+must be invoked with three arguments: hostname, checkprogram, and
+subprogram.  If these arguments are missing, qmail-smtpd will still
+advertise availability of AUTH, but will fail with a permanent error
+when AUTH is used.
+
+hostname is simply used to form the CRAM-MD5 challenge.  qmail-smtpd
+invokes checkprogram, feeding it the username and password, in the
+case of LOGIN or PLAIN, or the username, challenge, and response, in
+the case of CRAM-MD5.  If the user is permitted, checkprogram invokes
+subprogram, which just has to exit with a status of 0 for the user to
+be authenticated.  Otherwise, checkprogram exits with a non-zero
+status.  subprogram can usually be /usr/bin/true (or /bin/true,
+depending on your flavor of OS).
+
+If the user is successfully authenticated, the RELAYCLIENT
+environment variable is effectively set for the SMTP session, and
+the TCPREMOTEINFO environment variable is set to the authenticated
+username, overriding any value that tcpserver may have set.  The
+value of TCPREMOTEINFO is reflected in a Received header.
+
+
+How to install it:
+
+Simply patch your qmail-1.03 distribution with the included patch
+file and recompile & install like usual.
+
+The steps to do this are as follows (assuming your virgin
+qmail-1.03 install is in "../qmail-1.03"):
+
+  cp README.auth base64.c base64.h ../qmail-1.03
+  patch -d ../qmail-1.03 < auth.patch
+
+Install qmail normally, with the exception of the new arguments
+to qmail-smtpd described elsewhere in this file.
+
+Also obtain, unpack, compile and install the cmd5checkpw utility
+(or some other checkpassword utility) and add a sample account to
+/etc/poppasswd file.  This file must be readable by the qmail-smtpd
+user, usually qmaild.
+
+
+How to use it:
+
+*** Warning: In version 0.30 the arguments have changed from
+*** previous versions of qmail-smtpd-auth.  Take care to make sure
+*** you update your startup scripts if updating!
+
+If you're running qmail-smtpd from inetd, you'll want to do the
+following:
+
+smtp stream tcp nowait qmaild /var/qmail/bin/tcp-env tcp-env \
+/var/qmail/bin/qmail-smtpd mail.acme.com /bin/cmd5checkpw /bin/true
+
+Replace mail.acme.com with your hostname.  The second argument to
+qmail-smtpd is your checkpassword utility (preferably cmd5checkpw
+or some alternative that can handle CRAM-MD5).  The third argument
+is the executable that the checkpassword utility execs when
+authentication is successful.  (Note that the location of "true"
+is OS dependent: you may need /usr/bin/true.)
+
+Invocations using tcpserver will require analagous changes.  Give
+your inetd a kill -HUP or restart tcpserver and away you go.
+
+
+Caveats:
+
+Please note that as authentication needs vary wildly across
+installations, no effort has been made to make this patch work ``out
+of the box.''  You'll have to procure or develop your own
+checkpassword program.  Also note that CRAM-MD5 will require you to
+keep plaintext passwords.  You'll probably want to disable this AUTH
+type if you're just using /etc/passwd (keeping in mind that PLAIN and
+LOGIN aren't quite as safe over the wire) -- just undefine AUTHCRAM
+in qmail-smtpd.
+
+Krzysztof Dabrowski's cmd5checkpw tool used as an example in this
+document supports the three AUTH types included in this patch.
+It's available at http://www.elysium.pl/members/brush/cmd5checkpw/.
+
+This patch has been generated against the stock qmail 1.03
+distribution.  The results of combining this patch with others are
+unknown.
+
+
+Features:
+
+This patch supports the following auth methods: LOGIN, PLAIN and
+CRAM-MD5.
+
+
+Compatibility:
+
+The following MUA's are confirmed to work with this patch:
+
+Eudora 4.2.2		-	CRAM-MD5
+Eudora 5.0.2 		- 	CRAM-MD5
+The Bat 1.39		-	LOGIN & CRAM-MD5
+Outlook Express 4	- 	LOGIN
+Outlook Express 5	-	LOGIN
+Outlook 2000 		- 	LOGIN
+Netscape 4.x		-	LOGIN & PLAIN
+Netscape 4.0x		-	LOGIN
+Pegasus Mail 3.1x	-	CRAM-MD5
+
+
+Various compatibility issues:
+
+Testing with Pegasus Mail 3.1 revealed that it requires the new style
+(RFC recommended) greeting message.  Both styles are now enabled to
+maintain the highest degree of compatibility with various clients.
+This fix was suggested by David Harris <David.Harris@pmail.gen.nz>,
+the developer of Pegasus Mail.
+
+
+Acknowledgments:
+
+This patch is based on work by Krzysztof Dabrowski at
+http://members.elysium.pl/brush/qmail-smtpd-auth/ and ``Mrs. Brisby''
+at http://www.nimh.org/hacks/qmail-smtpd.c which has been further
+developed by Eric M. Johnston <emj@postal.net>.
+
+---
+
+THIS SOFTWARE IS IN THE PUBLIC DOMAIN, IS PROVIDED BY THE AUTHOR
+``AS IS,'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
